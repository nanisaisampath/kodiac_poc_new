<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kodiak Retinal Image Viewer v0.1.0</title>

    <!-- Add the Google Font link here -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />

    <style>
      body {
        font-family: "Roboto", Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        background: linear-gradient(180deg, #338dcc, #eaf3f9);
        min-height: 100vh;
      }

      header {
        width: 100%;
        background-color: #f5f5f5;
        color: white;
        padding: 15px;
        text-align: center;
        font-size: 2.5rem;
      }

      /* Sidebar Styling */
      .sidebar {
        position: fixed;
        top: 0;
        bottom: 0;
        width: 60px;
        background-color: #0c2130;
        overflow: hidden;
        transition: width 0.3s ease;
        z-index: 2;
      }

      .sidebar:hover {
        width: 100px;
      }

      .sidebar nav {
        margin-top: 20px;
      }

      .sidebar h2 {
        color: white;
        padding: 20px;
        font-size: 1.4rem;
        text-align: center;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1;
      }

      .sidebar nav a {
        padding: 10px 10px;
        display: block;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .sidebar:hover nav a {
        opacity: 1;
      }

      .sidebar nav a:hover {
        background-color: #338dcc;
      }

      /* Right Toolbar Styling */
      .toolbar {
        position: fixed;
        top: 0;
        bottom: 0;
        right: 0;
        width: 60px;
        background-color: #0c2130;
        overflow: hidden;
        transition: width 0.3s ease;
        z-index: 2;
      }

      .toolbar nav {
        margin-top: 20px;
      }

      .toolbar:hover {
        width: 100px;
      }

      .toolbar h2 {
        color: white;
        padding: 20px;
        font-size: 1.25rem;
        text-align: center;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1;
      }

      .toolbar a {
        padding: 10px 10px;
        display: block;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .toolbar:hover a {
        opacity: 1;
      }

      .toolbar a:hover {
        background-color: #338dcc;
      }

      /* Main Content Adjustments */
      .main-content {
        margin-left: 60px;
        margin-right: 60px;
        display: flex;
        width: calc(100% - 120px);
        padding: 20px;
        overflow-y: auto;
        box-sizing: border-box;
        min-height: calc(100vh - 120px);
      }

      /* File Browser Layout */
      .file-browser-container {
        display: none;
        width: 100%;
        height: calc(100vh - 120px);
        overflow: hidden; /* Prevent page-level overflow */
      }

      .file-browser-layout {
        display: flex;
        height: 100%;
        gap: 20px;
        min-height: 0; /* Allow flex shrinking */
      }

      /* Enhanced Tree View with Drill-down */
      .tree-panel {
        width: 350px;
        background-color: white;
        border: 2px solid #0c2130;
        border-radius: 8px;
        padding: 15px;
        overflow-y: auto;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
      }

      .tree-panel h3 {
        margin-top: 0;
        color: #0c2130;
        border-bottom: 2px solid #338dcc;
        padding-bottom: 10px;
      }

      .tree-search {
        width: 100%;
        padding: 8px;
        margin-bottom: 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
      }

      /* Performance Controls Styling */
      .performance-controls {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 15px;
      }

      .performance-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .performance-header h4 {
        margin: 0;
        color: #495057;
        font-size: 14px;
      }

      .refresh-btn {
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.2s;
      }

      .refresh-btn:hover {
        background-color: #0056b3;
      }

      .listing-method {
        margin-bottom: 10px;
      }

      .listing-method label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #6c757d;
      }

      .custom-prefix-controls {
        border-top: 1px solid #dee2e6;
        padding-top: 10px;
        margin-top: 10px;
      }

      .custom-prefix-controls label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #6c757d;
      }

      .custom-prefix-input {
        margin-bottom: 10px;
      }

      .apply-prefixes-btn {
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background-color 0.2s;
      }

      .apply-prefixes-btn:hover {
        background-color: #1e7e34;
      }

      .performance-info {
        border-top: 1px solid #dee2e6;
        padding-top: 10px;
        margin-top: 10px;
      }

      .perf-metric {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 12px;
      }

      .perf-label {
        color: #6c757d;
        font-weight: 500;
      }

      .perf-value {
        color: #495057;
        font-weight: 600;
      }

      /* Navigation Header */
      .tree-navigation {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        padding: 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #e9ecef;
      }

      .back-button {
        background: none;
        border: none;
        color: #338dcc;
        cursor: pointer;
        font-size: 14px;
        padding: 4px 8px;
        border-radius: 3px;
        display: none;
        align-items: center;
        gap: 5px;
        transition: background-color 0.2s ease;
      }

      .back-button:hover {
        background-color: #e9ecef;
      }

      .back-button.visible {
        display: flex;
      }

      .current-path {
        font-size: 12px;
        color: #666;
        margin-left: auto;
        font-style: italic;
      }

      /* File Tree Container */
      .file-tree-container {
        flex: 1;
        overflow-y: auto;
      }

      .file-tree {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      /* Tree Items */
      .tree-item {
        display: flex;
        align-items: flex-start;
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.2s ease;
        user-select: none;
        margin-bottom: 2px;
        border: 1px solid transparent;
        position: relative;
        min-height: 36px;
      }

      .tree-item:hover {
        background-color: #f0f8ff;
        border-color: #e3f2fd;
      }

      .tree-item.selected {
        background-color: #338dcc;
        color: white;
      }

      .tree-item.loading {
        background-color: #fff3cd;
        border-color: #ffeaa7;
      }

      /* Tree Item Content */
      .tree-item-content {
        display: flex;
        align-items: flex-start;
        width: 100%;
        gap: 8px;
        min-height: 20px;
        position: relative;
        padding-right: 30px; /* Make room for checkbox */
      }

      .expand-arrow {
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: #666;
        cursor: pointer;
        transition: transform 0.2s ease;
        margin-top: 2px;
        flex-shrink: 0;
      }

      .expand-arrow.expanded {
        transform: rotate(0deg);
      }

      .expand-arrow.collapsed {
        transform: rotate(0deg);
      }

      .tree-icon {
        width: 18px;
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 1px;
        flex-shrink: 0;
      }

      .folder-icon {
        color: #ffd700;
      }

      .file-icon {
        color: #666;
      }

      .tree-item-name {
        flex: 1;
        font-size: 14px;
        white-space: normal;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        min-width: 0;
        line-height: 1.3;
        padding: 2px 0;
      }

      .tree-item-info {
        font-size: 11px;
        color: #999;
        margin-left: auto;
      }

      /* Enhanced Tooltip for Full File Names */
      .tree-item-tooltip {
        position: absolute;
        background-color: #2c3e50;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 13px;
        white-space: nowrap;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.3s ease,
          visibility 0.3s ease;
        pointer-events: none;
        max-width: 400px;
        word-break: break-all;
        left: 100%;
        top: 50%;
        transform: translateY(-50%);
        margin-left: 10px;
      }

      .tree-item-tooltip::before {
        content: "";
        position: absolute;
        top: 50%;
        left: -6px;
        transform: translateY(-50%);
        border: 6px solid transparent;
        border-right-color: #2c3e50;
      }

      .tree-item:hover .tree-item-tooltip {
        opacity: 1;
        visibility: visible;
      }

      /* Adjust tooltip position if it would go off-screen */
      .tree-item-tooltip.tooltip-left {
        left: auto;
        right: 100%;
        margin-left: 0;
        margin-right: 10px;
      }

      .tree-item-tooltip.tooltip-left::before {
        left: auto;
        right: -6px;
        border-right-color: transparent;
        border-left-color: #2c3e50;
      }

      /* Loading and Error States */
      .tree-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        color: #666;
      }

      .tree-error {
        padding: 15px;
        background-color: #ffebee;
        border: 1px solid #f8bbd9;
        border-radius: 4px;
        color: #d32f2f;
        text-align: center;
      }

      .tree-empty {
        padding: 20px;
        text-align: center;
        color: #999;
        font-style: italic;
      }

      /* Viewport Panel */
      /* Enhanced Viewport Panel with proper constraints */
      .viewport-panel {
        flex: 1;
        background-color: white;
        border: 2px solid #0c2130;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        min-width: 0; /* Allow flex shrinking */
        min-height: 0; /* Allow flex shrinking */
      }

      .viewport-panel h3 {
        margin-top: 0;
        color: #0c2130;
        border-bottom: 2px solid #338dcc;
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Layout Toggle Button */
      .layout-toggle {
        background-color: #338dcc;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.3s ease;
      }

      .layout-toggle:hover {
        background-color: #0c2130;
      }

      /* Viewports Container with proper flex constraints */
      .viewports-container {
        display: flex;
        gap: 2px;
        flex: 1;
        min-height: 0; /* Critical for flex children */
        overflow: hidden; /* Prevent container overflow */
      }

      .viewports-container.stacked {
        flex-direction: column;
      }

      /* Individual Viewport with strict boundaries */
      .viewport {
        flex: 1;
        border: 2px solid #ccc;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        background-color: #f9f9f9;
        transition:
          border-color 0.3s ease,
          box-shadow 0.3s ease;
        position: relative;
        min-width: 0; /* Allow shrinking */
        min-height: 0; /* Allow shrinking */
        box-sizing: border-box;
        overflow: hidden; /* Prevent viewport overflow */
      }

      .viewport h4 {
        margin-top: 0;
        text-align: center;
        color: #0c2130;
        border-bottom: 1px solid #ddd;
        padding-bottom: 8px;
      }

      /* Viewport Content with strict size constraints */
      .viewport-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 300px;
        max-height: 600px; /* Prevent excessive height */
        background-color: white;
        border: 1px dashed #ccc;
        border-radius: 4px;
        position: relative;
        overflow: hidden; /* Prevent image from extending outside */
        width: 100%;
        box-sizing: border-box;
        /* Ensure proper containment */
        contain: layout style paint;
      }

      /* Enhanced Image Constraints */
      .viewport-image {
        max-width: 100% !important;
        max-height: 100% !important;
        width: auto !important;
        height: auto !important;
        object-fit: contain; /* Maintain aspect ratio */
        cursor: grab;
        transition: transform 0.1s ease;
        transform-origin: center center;
        position: relative;
        display: block;
        box-sizing: border-box;
        /* Ensure image stays within container */
        overflow: hidden;
        /* Prevent image from extending outside container */
        contain: layout style paint;
      }

      .viewport-image:active {
        cursor: grabbing;
      }

      .viewport-placeholder {
        color: #666;
        text-align: center;
        font-style: italic;
      }

      .zoom-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
      }

      .zoom-btn {
        padding: 5px 10px;
        background-color: #338dcc;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .zoom-btn:hover {
        background-color: #0c2130;
      }

      .zoom-level {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #666;
      }

      /* Context Menu */
      .context-menu {
        position: absolute;
        display: none;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        z-index: 9999;
        min-width: 160px;
        padding: 5px 0;
      }

      .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
      }

      .context-menu-item:hover {
        background-color: #f0f8ff;
      }

      .context-menu-icon {
        margin-right: 8px;
        width: 16px;
      }

      /* Loading Spinner */
      .loader {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #338dcc;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Enhanced Progress Overlay with Shadow Image Effect */
      .progress-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.95),
          rgba(240, 248, 255, 0.98)
        );
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999; /* Very high z-index to ensure visibility */
        backdrop-filter: blur(2px);
        border-radius: 4px;
        pointer-events: auto; /* Ensure it can receive events */
      }

      .progress-overlay.active {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        z-index: 1000 !important;
        /* Ensure progress overlay is always visible even with overflow: hidden on parent */
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
      }

      .progress-overlay::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        height: 60%;
        background: linear-gradient(
          45deg,
          rgba(51, 141, 204, 0.1) 0%,
          rgba(51, 141, 204, 0.05) 25%,
          rgba(12, 33, 48, 0.1) 50%,
          rgba(51, 141, 204, 0.05) 75%,
          rgba(51, 141, 204, 0.1) 100%
        );
        border-radius: 8px;
        animation: shadowPulse 2s ease-in-out infinite;
        z-index: -1;
      }

      @keyframes shadowPulse {
        0%,
        100% {
          opacity: 0.3;
          transform: translate(-50%, -50%) scale(0.95);
        }
        50% {
          opacity: 0.6;
          transform: translate(-50%, -50%) scale(1.05);
        }
      }

      .progress-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        z-index: 2;
        text-align: center;
        max-width: 90%;
      }

      .progress-circle {
        position: relative;
        width: 80px;
        height: 80px;
      }

      .progress-ring {
        width: 80px;
        height: 80px;
        transform: rotate(-90deg);
      }

      .progress-ring-bg {
        fill: none;
        stroke: #e6e6e6;
        stroke-width: 6;
      }

      .progress-ring-fill {
        fill: none;
        stroke: #338dcc;
        stroke-width: 6;
        stroke-linecap: round;
        stroke-dasharray: 226;
        stroke-dashoffset: 226;
        transition: stroke-dashoffset 0.3s ease;
      }

      .progress-percentage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 16px;
        font-weight: bold;
        color: #0c2130;
      }

      .progress-text {
        color: #0c2130;
        font-weight: 500;
        font-size: 14px;
        margin: 0;
      }

      .progress-metadata {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        margin-top: 10px;
      }

      .metadata-tag {
        background: linear-gradient(135deg, #338dcc, #0c2130);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        animation: tagFadeIn 0.5s ease-out;
      }

      @keyframes tagFadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .progress-steps {
        display: flex;
        gap: 8px;
        margin-top: 15px;
      }

      .progress-step {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #e6e6e6;
        transition: all 0.3s ease;
      }

      .progress-step.active {
        background-color: #338dcc;
        transform: scale(1.2);
      }

      .progress-step.completed {
        background-color: #28a745;
      }

      /* Cancel Button Styling */
      .cancel-button {
        padding: 8px 16px;
        background-color: #dc3545;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 15px;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .cancel-button:hover {
        background-color: #c82333;
      }

      .cancel-button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
      }

      /* Error message styling */
      .error-message {
        color: #d32f2f;
        background-color: #ffebee;
        border: 1px solid #f8bbd9;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        text-align: center;
      }

      .retry-button {
        background-color: #338dcc;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
      }

      .retry-button:hover {
        background-color: #0c2130;
      }

      /* Frame slider styling */
      .frame-slider-container {
        margin-top: 10px;
        padding: 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
        display: none;
      }

      .frame-slider-container.active {
        display: block;
      }

      .frame-slider-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 5px 0;
      }

      .frame-nav-btn {
        background-color: #338dcc;
        color: white;
        border: none;
        border-radius: 4px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s ease;
        font-size: 12px;
      }

      .frame-nav-btn:hover {
        background-color: #0c2130;
      }

      .frame-nav-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }

      .frame-slider {
        flex: 1;
        margin: 0;
      }

      .frame-info {
        text-align: center;
        font-size: 12px;
        color: #666;
        margin-top: 5px;
      }

      .mode-switch-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
      }

      .mode-switch-btn {
        background-color: #338dcc;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        cursor: pointer;
        font-size: 11px;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .mode-switch-btn:hover {
        background-color: #0c2130;
      }

      .mode-switch-btn.active {
        background-color: #0c2130;
        font-weight: bold;
      }

      /* Original viewport containers for DICOM view */
      .viewport-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 1px solid #0c2130;
        padding: 10px 20px;
        margin: 10px;
        background-color: transparent;
        width: calc(100% - 40px);
        max-width: 900px;
        box-sizing: border-box;
        position: relative;
      }

      .viewport-container h2 {
        margin-bottom: 10px;
        font-size: 1.5rem;
        text-align: center;
      }

      .progress-container {
        width: 100%;
        background-color: #f1f1f1;
        border-radius: 5px;
        margin: 20px 0;
        position: relative;
        height: 20px;
      }

      .progress-bar {
        background: linear-gradient(90deg, #338dcc, #0c2130);
        height: 100%;
        width: 0;
        border-radius: 5px;
        transition: width 0.4s ease;
      }

      .progress-text {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-weight: bold;
        font-size: 14px;
        line-height: 20px;
      }

      .dicom-prompt {
        padding: 50px;
        border: 2px dashed #0c2130;
        text-align: center;
        color: #0c2130;
        font-size: 1.2rem;
        cursor: pointer;
      }

      .horizontal-line {
        width: 100%;
        height: 2px;
        background-color: #ccc;
        margin: 20px 0;
      }

      .viewport-image-original {
        display: none;
        max-width: 100%;
        height: auto;
        border: 1px solid #ccc;
        margin-top: 15px;
      }

      .slider-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-top: 5px;
        width: 100%;
      }

      .slider-section p,
      .slider-section label {
        display: block;
        text-align: center;
        margin-bottom: 5px;
      }

      input[type="range"] {
        width: 15%;
        display: block;
        margin-left: auto;
        margin-right: auto;
      }

      #bindSlidersContainer {
        margin-top: 20px;
        text-align: center;
        width: 100%;
      }

      footer {
        width: 100%;
        color: black;
        text-align: center;
        padding: 5px;
        font-size: 12px;
        position: fixed;
        bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(255, 255, 255, 0.9);
      }

      .performance-monitor {
        font-size: 11px;
        color: #666;
        margin-left: 20px;
      }

      /* Responsive Layout Adjustments */
      @media (max-width: 1200px) {
        .viewports-container:not(.stacked) {
          flex-direction: column;
        }

        .viewport-content {
          min-height: 250px;
          max-height: 400px;
        }
      }

      @media (max-width: 768px) {
        .viewport-container {
          width: 100%;
          padding: 10px;
        }

        .toolbar,
        .sidebar {
          display: none;
        }

        .main-content {
          margin-left: 0;
          margin-right: 0;
          width: 100%;
          padding: 10px;
        }

        .file-browser-layout {
          flex-direction: column;
        }

        .tree-panel {
          width: 100%;
          height: 300px;
        }

        .viewports-container {
          flex-direction: column;
        }

        .viewport-content {
          min-height: 200px;
          max-height: 300px;
        }
      }

      /* S3 Credentials Modal */
      .s3-credentials-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }

      .s3-credentials-form {
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
      }

      .s3-credentials-form h2 {
        color: #0c2130;
        margin-bottom: 20px;
        text-align: center;
        border-bottom: 2px solid #338dcc;
        padding-bottom: 10px;
      }

      .s3-form-group {
        margin-bottom: 20px;
      }

      .s3-form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #0c2130;
      }

      .s3-form-group input {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        box-sizing: border-box;
      }

      .s3-form-group input:focus,
      .s3-form-group select:focus {
        outline: none;
        border-color: #338dcc;
        box-shadow: 0 0 5px rgba(51, 141, 204, 0.3);
      }

      .s3-form-group select {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        box-sizing: border-box;
        background-color: white;
        cursor: pointer;
      }

      .s3-form-group small {
        display: block;
        margin-top: 5px;
        color: #666;
        font-size: 12px;
        line-height: 1.4;
      }

      .s3-form-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 25px;
      }

      .s3-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: background-color 0.3s ease;
      }

      .s3-btn-primary {
        background-color: #338dcc;
        color: white;
      }

      .s3-btn-primary:hover {
        background-color: #0c2130;
      }

      .s3-btn-secondary {
        background-color: #ccc;
        color: #333;
      }

      .s3-btn-secondary:hover {
        background-color: #bbb;
      }

      .s3-form-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 15px;
      }

      .s3-form-checkbox input[type="checkbox"] {
        width: auto;
      }

      .s3-error-message {
        background-color: #ffebee;
        color: #d32f2f;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
        border: 1px solid #f8bbd9;
      }

      .s3-success-message {
        background-color: #e8f5e8;
        color: #2e7d32;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
        border: 1px solid #c8e6c9;
      }

      .s3-loading {
        text-align: center;
        padding: 20px;
      }

      .s3-loading .loader {
        margin: 0 auto;
      }

      /* Eye Focus Menu */
      .eye-focus-menu {
        position: relative;
        display: inline-block;
      }

      .eye-focus-burger {
        padding: 8px 12px;
        background: linear-gradient(135deg, #338dcc, #0c2130);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 80px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .eye-focus-burger:hover {
        background: linear-gradient(135deg, #0c2130, #338dcc);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .eye-focus-burger i:last-child {
        transition: transform 0.3s ease;
      }

      .eye-focus-burger.active i:last-child {
        transform: rotate(180deg);
      }

      .eye-focus-dropdown-menu {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        margin-top: 4px;
        overflow: hidden;
        min-width: 160px;
      }

      .eye-focus-dropdown-menu.show {
        display: block;
        animation: dropdownFadeIn 0.2s ease-out;
      }

      @keyframes dropdownFadeIn {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .eye-focus-item {
        padding: 12px 16px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #333;
        border-bottom: 1px solid #f0f0f0;
      }

      .eye-focus-item:last-child {
        border-bottom: none;
      }

      .eye-focus-item:hover {
        background: linear-gradient(135deg, #f0f8ff, #e3f2fd);
        color: #338dcc;
      }

      .eye-focus-item i {
        color: #338dcc;
        width: 16px;
        text-align: center;
      }

      .reset-button {
        padding: 8px 16px;
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .reset-button:hover {
        background: linear-gradient(135deg, #c82333, #dc3545);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .reset-button i {
        font-size: 12px;
      }

      /* S3 Selection Styles */
      .s3-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .s3-status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 12px;
        background-color: #f5f5f5;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #ccc;
      }

      .status-dot.connected {
        background-color: #4caf50;
      }

      .status-dot.disconnected {
        background-color: #f44336;
      }

      .status-dot.checking {
        background-color: #ff9800;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }

      .status-text {
        font-weight: 500;
      }

      .status-text.connected {
        color: #4caf50;
      }

      .status-text.disconnected {
        color: #f44336;
      }

      .status-text.checking {
        color: #ff9800;
      }

      .status-refresh-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 2px;
        border-radius: 3px;
        color: #666;
        font-size: 10px;
        transition: all 0.2s;
      }

      .status-refresh-btn:hover {
        background-color: #e0e0e0;
        color: #333;
      }

      .status-refresh-btn:active {
        transform: scale(0.95);
      }

      .status-refresh-btn.spinning i {
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      .s3-selection-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .select-mode-btn, .cache-btn, .cancel-btn {
        padding: 6px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .select-mode-btn {
        background-color: #007bff;
        color: white;
      }

      .select-mode-btn:hover {
        background-color: #0056b3;
      }

      .cache-btn {
        background-color: #28a745;
        color: white;
      }

      .cache-btn:hover {
        background-color: #1e7e34;
      }

      .cancel-btn {
        background-color: #6c757d;
        color: white;
      }

      .cancel-btn:hover {
        background-color: #545b62;
      }

      .file-item-selectable, .folder-item-selectable {
        position: relative;
        cursor: pointer;
      }

      .file-item-selectable.selected, .folder-item-selectable.selected {
        background-color: #e3f2fd !important;
        border: 2px solid #2196f3 !important;
        border-radius: 4px;
      }

      .tree-item.selected {
        background-color: #e3f2fd !important;
        border: 2px solid #2196f3 !important;
        border-radius: 4px;
      }

      .selection-checkbox {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid #ddd;
        border-radius: 3px;
        display: none;
        cursor: pointer;
        z-index: 10;
        flex-shrink: 0;
      }

      .selection-checkbox.visible {
        display: block;
      }

      .selection-checkbox.checked {
        background-color: #2196f3;
        border-color: #2196f3;
      }

      .selection-checkbox.checked::after {
        content: '✓';
        color: white;
        font-size: 10px;
        position: absolute;
        top: -1px;
        left: 2px;
        line-height: 1;
        font-weight: bold;
      }

      .selection-checkbox.disabled {
        background-color: #f5f5f5;
        border-color: #ccc;
        cursor: not-allowed;
        opacity: 0.5;
      }

      .selection-checkbox.disabled::after {
        content: '⨯';
        color: #999;
        font-size: 12px;
        position: absolute;
        top: -1px;
        left: 1px;
        line-height: 1;
        font-weight: bold;
      }

      /* Cache Progress Popup Styles */
      .cache-progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
      }

      .cache-progress-modal {
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 500px;
        overflow: hidden;
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .cache-progress-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .cache-progress-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .cache-progress-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
      }

      .cache-progress-close:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .cache-progress-content {
        padding: 30px;
      }

      .cache-progress-bar {
        width: 100%;
        height: 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .cache-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .cache-progress-text {
        text-align: center;
        font-size: 16px;
        color: #495057;
        margin-bottom: 25px;
        font-weight: 500;
      }

      .cache-progress-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .stat-label {
        font-weight: 500;
        color: #6c757d;
        font-size: 14px;
      }

      .stat-value {
        font-weight: 600;
        color: #495057;
        font-size: 16px;
        min-width: 30px;
        text-align: right;
      }

      /* Current file progress styles */
      .current-file-section {
        margin: 20px 0;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e9ecef;
      }

      .current-file-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .current-file-header h4 {
        margin: 0;
        font-size: 14px;
        color: #495057;
        font-weight: 600;
      }

      .file-status {
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .file-status.preparing {
        background-color: #fff3cd;
        color: #856404;
      }

      .file-status.downloading {
        background-color: #d1ecf1;
        color: #0c5460;
      }

      .file-status.processing {
        background-color: #d4edda;
        color: #155724;
      }

      .file-status.complete {
        background-color: #d1e7dd;
        color: #0f5132;
      }

      .file-status.failed {
        background-color: #f8d7da;
        color: #721c24;
      }

      .file-status.skipped {
        background-color: #e2e3e5;
        color: #383d41;
      }

      .current-file-progress-bar {
        width: 100%;
        height: 6px;
        background-color: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 8px;
      }

      .current-file-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #28a745 0%, #20c997 100%);
        border-radius: 3px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .current-file-details {
        font-size: 12px;
        color: #6c757d;
        font-style: italic;
      }

      /* Folder selection styling */
      .folder-item {
        border-left: 3px solid transparent;
      }

      .folder-item.selected {
        border-left: 3px solid #ff9800;
        background-color: #fff3e0 !important;
      }

      .folder-item.file-item-selectable.selected {
        background-color: #e3f2fd !important;
        border: 2px solid #2196f3 !important;
        border-left: 3px solid #ff9800 !important;
      }

      .reset-button:hover {
        background-color: #c82333;
      }

      /* Eye Tree Container Styling */
      .eye-tree-container {
        margin-top: 15px;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        max-height: 300px;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .eye-tree-container.expanded {
        max-height: 500px;
      }

      .eye-tree-header {
        background: linear-gradient(135deg, #f1f3f4, #e8f0fe);
        padding: 10px 15px;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .eye-tree-header:hover {
        background: linear-gradient(135deg, #e8f0fe, #f1f3f4);
      }

      .eye-tree-header h5 {
        margin: 0;
        font-size: 14px;
        color: #0c2130;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tree-collapse-btn {
        background: none;
        border: none;
        color: #338dcc;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.3s ease;
      }

      .tree-collapse-btn:hover {
        background-color: rgba(51, 141, 204, 0.1);
        transform: scale(1.1);
      }

      .tree-collapse-btn i {
        transition: transform 0.3s ease;
      }

      .tree-collapse-btn.collapsed i {
        transform: rotate(-90deg);
      }

      .eye-tree-content {
        padding: 12px;
        max-height: 250px;
        overflow-y: auto;
        font-size: 13px;
      }

      .tree-placeholder {
        color: #6c757d;
        font-style: italic;
        text-align: center;
        padding: 20px;
      }

      .eye-tree-item {
        padding: 6px 10px;
        margin: 2px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .eye-tree-item:hover {
        background-color: #f8f9fa;
      }

      .eye-tree-item.selected {
        background-color: #e3f2fd;
        color: #0c2130;
        font-weight: 500;
      }

      .eye-tree-item i {
        color: #338dcc;
        width: 16px;
        text-align: center;
      }

      /* Hierarchical tree styles */
      .eye-tree-folder {
        margin: 2px 0;
      }

      .folder-header {
        background-color: #f1f3f4;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        font-weight: 500;
        margin-bottom: 2px;
      }

      .folder-header:hover {
        background-color: #e8f0fe;
      }

      .folder-arrow {
        transition: transform 0.2s ease;
        color: #666 !important;
      }

      .folder-icon {
        color: #338dcc !important;
      }

      .eye-tree-children {
        margin-left: 20px;
        border-left: 2px solid #e0e0e0;
        padding-left: 8px;
      }

      .file-item {
        background-color: #fafafa;
        border: 1px solid transparent;
        font-size: 13px;
      }

      .file-item:hover {
        background-color: #f0f8ff;
        border-color: #338dcc;
      }

      .file-item.selected {
        background-color: #338dcc;
        color: white;
        border-color: #0c2130;
      }

      .file-item.selected i {
        color: white !important;
      }

      .file-icon {
        color: #666 !important;
      }

      /* Original OCT frame specific styling */
      .file-item.original-oct-frame {
        border-left: 3px solid #ff9800;
        background-color: #fff3e0;
      }

      .file-item.original-oct-frame:hover {
        background-color: #ffe0b2;
        border-color: #ff9800;
      }

      .file-item.original-oct-frame.selected {
        background-color: #ff9800;
        color: white;
        border-color: #f57c00;
      }

      .file-item.original-oct-frame.selected:hover {
        background-color: #f57c00;
      }

      .file-item.original-oct-frame.selected i {
        color: white !important;
      }

      /* DICOM Viewports Container */
      .dicom-viewports-container {
        display: flex;
        flex-direction: column;
        width: 100%;
      }

      .dicom-viewports-container.side-by-side {
        flex-direction: row;
        gap: 20px;
      }

      .dicom-viewports-container.side-by-side .viewport-container {
        flex: 1;
        width: calc(50% - 10px);
      }

      .dicom-viewports-container.side-by-side .horizontal-line {
        display: none;
      }

      .dicom-viewports-container.stacked {
        flex-direction: column;
      }

      .dicom-viewports-container.stacked .viewport-container {
        width: calc(100% - 40px);
      }

      .dicom-viewports-container.stacked .horizontal-line {
        display: block;
      }
      .custom-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #ffffff;
        padding: 10px 20px;
        color: white;
      }

      .header-logo {
        height: 40px;
        width: auto;
        object-fit: contain;
      }

      /* This pulls the left logo a little to the right */
      .left-logo {
        margin-left: 90px;
      }

      /* This pulls the right logo a little to the left */
      .right-logo {
        margin-right: 125px;
      }

      .header-title {
        flex-grow: 1;
        text-align: center;
        font-size: 1.8rem;
        font-weight: 500;
        white-space: nowrap;
        color: #000000;
      }

      .tree-search {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
      }
      .context-menu {
        position: absolute;
        display: none;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        z-index: 9999;
        min-width: 160px;
        padding: 5px 0;
      }

      /* Cache Progress Popup Styles */
      .cache-progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
      }

      .cache-progress-modal {
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 500px;
        overflow: hidden;
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .cache-progress-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .cache-progress-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .cache-progress-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
      }

      .cache-progress-close:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .cache-progress-content {
        padding: 30px;
      }

      .cache-progress-bar {
        width: 100%;
        height: 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .cache-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .cache-progress-text {
        text-align: center;
        font-size: 16px;
        color: #495057;
        margin-bottom: 25px;
        font-weight: 500;
      }

      .cache-progress-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .stat-label {
        font-weight: 500;
        color: #6c757d;
        font-size: 14px;
      }

      .stat-value {
        font-weight: 600;
        color: #495057;
        font-size: 16px;
        min-width: 30px;
        text-align: right;
      }
      #combinedFilesContainer {
        width: 20%;
        height: 98%;
        
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <header class="custom-header">
      <img
        src="static/itsoli-logo-color-full-positive.jpg"
        alt="Left Logo"
        class="header-logo left-logo"
      />
      <span class="header-title">Retinal Image Viewer and File Processor</span>
      <img
        src="static/Kodiak_logo - high res.jpg"
        alt="Right Logo"
        class="header-logo right-logo"
      />
    </header>

    <!-- Left Sidebar Navigation -->
    <div class="sidebar">
      <h2><i class="fas fa-bars"></i></h2>
      <nav>
        <a href="#" id="fileNav" onclick="toggleFileFrame()">Browse</a>
        <a href="#">Edit</a>
        <a href="#">Help</a>
      </nav>
    </div>

    <!-- Right Toolbar -->

    <div class="main-content">
      <!-- DICOM View Section -->
      <div
        id="dicomView"
        style="
          display: none;
          width: 100%;
          flex-direction: column;
          justify-content: center;
          align-items: flex-start;
        "
      >
        <div id="bindSlidersContainer" style="display: none">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 10px;
            "
          >
            <div>
              <input type="checkbox" id="bindSliders" />
              <label for="bindSliders">Bind Sliders</label>
            </div>
            <button class="layout-toggle" onclick="toggleDicomViewportLayout()">
              <i class="fas fa-columns" id="dicomLayoutIcon"></i>
              <span id="dicomLayoutText">Switch to Stacked</span>
            </button>
          </div>
        </div>

        <div class="dicom-viewports-container" id="dicomViewportsContainer">
          <div class="viewport-container">
            <h2 id="viewportTitle1_s3">Viewport 1</h2>
            <div
              class="dicom-prompt"
              id="dicomPrompt1_s3"
              onclick="document.getElementById('dicomFile1_s3').click();"
            >
              Click to upload a DICOM file for Viewport 1
            </div>
            <input
              type="file"
              id="dicomFile1_s3"
              style="display: none"
              onchange="uploadDICOM(1)"
            />
            <img
              id="viewportImage1_s3"
              class="viewport-image-original"
              alt="DICOM Viewport 1"
              data-dicom-file-path=""
            />
            <div class="loader" id="loaderViewport1_s3"></div>
            <div
              class="slider-section"
              id="sliderSection1_s3"
              style="display: none"
            >
              <label for="frameSlider1_s3">Select Frame</label>
              <input
                type="range"
                id="frameSlider1_s3"
                min="0"
                max="100"
                value="0"
              />
              <p id="frameNumber1_s3">Current Frame: 1 of X</p>
            </div>
          </div>

          <div class="horizontal-line"></div>

          <div class="viewport-container">
            <h2 id="viewportTitle2_s3">Viewport 2</h2>
            <div
              class="dicom-prompt"
              id="dicomPrompt2_s3"
              onclick="document.getElementById('dicomFile2_s3').click();"
            >
              Click to upload a DICOM file for Viewport 2
            </div>
            <input
              type="file"
              id="dicomFile2_s3"
              style="display: none"
              onchange="uploadDICOM(2)"
            />
            <img
              id="viewportImage2_s3"
              class="viewport-image-original"
              alt="DICOM Viewport 2"
              data-dicom-file-path=""
            />
            <div class="loader" id="loaderViewport2_s3"></div>
            <div
              class="slider-section"
              id="sliderSection2_s3"
              style="display: none"
            >
              <label for="frameSlider2_s3">Select Frame</label>
              <input
                type="range"
                id="frameSlider2_s3"
                min="0"
                max="100"
                value="0"
              />
              <p id="frameNumber2_s3">Current Frame: 1 of X</p>
            </div>
          </div>
        </div>
      </div>

      <!-- S3 File Browser Section -->
      <div id="fileBrowserContainer" class="file-browser-container">
        <div class="file-browser-layout">
          <!-- Left Panel: S3 Tree Explorer -->
          <div class="tree-panel">
            <div class="s3-header">
              <h3><i class="fas fa-folder-tree"></i> S3 File Browser</h3>
              <div class="s3-status-indicator" id="s3StatusIndicator">
                <span class="status-dot" id="s3StatusDot"></span>
                <span class="status-text" id="s3StatusText">Checking...</span>
                <button class="status-refresh-btn" onclick="refreshS3Status()" title="Refresh connection">
                  <i class="fas fa-sync-alt"></i>
                </button>
              </div>
              <div class="s3-selection-controls">
                <button id="selectModeBtn" class="select-mode-btn" onclick="toggleSelectionMode()">
                  <i class="fas fa-check-square"></i> Select
                </button>
                <button id="saveToCache" class="cache-btn" style="display: none;" onclick="saveSelectedToCache()">
                  <i class="fas fa-save"></i> Save to Cache
                </button>
                <button id="cancelSelection" class="cancel-btn" style="display: none;" onclick="cancelSelectionMode()">
                  <i class="fas fa-times"></i> Cancel
                </button>
              </div>
            </div>

            <!-- Navigation -->
            <div class="tree-navigation">
              <button
                id="backButton"
                class="back-button"
                onclick="s3Browser.goBack()"
              >
                <i class="fas fa-arrow-left"></i>
                Back
              </button>
              <span id="currentPath" class="current-path">Root</span>
            </div>

            <!-- Search -->
            <input
              type="text"
              id="treeSearchInput"
              class="tree-search"
              placeholder="Search current folder..."
            />
            <select id="extensionFilter" class="tree-search">
              <option value="">All File Types</option>
              <option value=".dcm">.dcm</option>
              <option value=".dicom">.dicom</option>
              <option value=".e2e">.e2e</option>
              <option value=".fds">.fds</option>
              <option value=".fda">.fda</option>
            </select>

            <!-- Simple Refresh Button -->
            <div class="refresh-controls">
              <button class="refresh-btn" onclick="loadS3Tree()" title="Refresh S3 List">
                <i class="fas fa-sync-alt"></i> Refresh
              </button>
              <button class="refresh-btn" onclick="clearAllCaches()" title="Clear All Caches (Debug)">
                <i class="fas fa-trash"></i> Clear Cache
              </button>
            </div>

            <!-- Tree Container -->
            <div id="fileTreeContainer" class="file-tree-container">
              <div class="tree-loading">
                <div class="loader"></div>
                <span style="margin-left: 10px">Initializing...</span>
              </div>
            </div>
          </div>

          <!-- Right Panel: Dual Viewports -->
          <div class="viewport-panel">
            <h3>
              <span><i class="fas fa-images"></i> Image Viewports</span>
              <div style="display: flex; align-items: center; gap: 10px;">
                <button class="layout-toggle" onclick="toggleViewportLayout()">
                  <i class="fas fa-columns" id="layoutIcon"></i>
                  <span id="layoutText">Switch to Stacked</span>
                </button>
                <div class="eye-focus-menu">
                  <button class="eye-focus-burger" onclick="toggleEyeFocusMenu()">
                    <i class="fas fa-eye"></i>
                    <i class="fas fa-chevron-down"></i>
                  </button>
                  <div class="eye-focus-dropdown-menu" id="eyeFocusDropdownMenu">
                    <div class="eye-focus-item" onclick="focusOnEye('left')">
                      <i class="fas fa-eye"></i>
                       Hide Right viewport
                    </div>
                    <div class="eye-focus-item" onclick="focusOnEye('right')">
                      <i class="fas fa-eye"></i>
                      Hide Left viewport
                    </div>
                  </div>
                </div>
                <button class="reset-button" onclick="resetEyeFocus()">
                  <i class="fas fa-undo"></i>
                  Reset
                </button>
              </div>
            </h3>

            

            <div class="viewports-container" id="viewportsContainer">
              <!-- Viewport 1 -->
              <div class="viewport" id="viewport1">
                <h4>Viewport 1</h4>
                <div class="viewport-content" id="viewportContent1">
                  <div class="viewport-placeholder">
                    Right-click a DICOM file to load here
                  </div>
                  <img
                    id="viewportImage1"
                    class="viewport-image"
                    style="display: none"
                    alt="DICOM Image 1"
                  />
                  <!-- Enhanced Progress Overlay for Viewport 1 -->
                  <div class="progress-overlay" id="progressOverlay1">
                    <div class="progress-content">
                      <div class="progress-circle">
                        <svg class="progress-ring">
                          <circle
                            class="progress-ring-bg"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                          <circle
                            class="progress-ring-fill"
                            id="progressRing1"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                        </svg>
                        <div
                          class="progress-percentage"
                          id="progressPercentage1"
                        >
                          0%
                        </div>
                      </div>
                      <div class="progress-text" id="progressText1">
                        Initializing...
                      </div>
                      <div
                        class="progress-metadata"
                        id="progressMetadata1"
                      ></div>
                      <div class="progress-steps" id="progressSteps1">
                        <div class="progress-step" id="step1_1"></div>
                        <div class="progress-step" id="step2_1"></div>
                        <div class="progress-step" id="step3_1"></div>
                        <div class="progress-step" id="step4_1"></div>
                        <div class="progress-step" id="step5_1"></div>
                      </div>
                      <!-- Cancel Button for Viewport 1 -->
                      <button
                        class="cancel-button"
                        id="cancelButton1"
                        onclick="cancelOperation(1)"
                        style="display: none"
                      >
                        <i class="fas fa-times"></i>
                        Cancel Download
                      </button>
                    </div>
                  </div>
                  <div
                    id="error1"
                    class="error-message"
                    style="display: none"
                  ></div>
                </div>
                <div class="zoom-controls">
                  <button class="zoom-btn" onclick="zoomViewport(1, 0.8)">
                    -
                  </button>
                  <div class="zoom-level" id="zoomLevel1">100%</div>
                  <button class="zoom-btn" onclick="zoomViewport(1, 1.25)">
                    +
                  </button>
                  <button class="zoom-btn" onclick="resetZoom(1)">Reset</button>
                </div>
                <!-- Frame slider for Viewport 1 -->
                <div class="frame-slider-container" id="frameSliderContainer1">
                  <label for="frameSlider1">Frame:</label>
                  <div class="frame-slider-controls">
                    <button class="frame-nav-btn" id="framePrev1" onclick="navigateFrame(1, -1)" title="Previous Frame">
                      <i class="fas fa-chevron-left"></i>
                    </button>
                    <input
                      type="range"
                      id="frameSlider1"
                      class="frame-slider"
                      min="0"
                      max="0"
                      value="0"
                    />
                    <button class="frame-nav-btn" id="frameNext1" onclick="navigateFrame(1, 1)" title="Next Frame">
                      <i class="fas fa-chevron-right"></i>
                    </button>
                  </div>
                  <div class="frame-info" id="frameInfo1">Frame 1 of 1</div>
                  <div class="mode-switch-controls" id="modeSwitchControls1" style="display: none; margin-top: 10px;">
                    <button class="mode-switch-btn" onclick="switchToRegularMode(1)" title="Switch to Regular Mode">
                      <i class="fas fa-images"></i> Regular
                    </button>
                    <button class="mode-switch-btn" onclick="switchToOCTMode(1)" title="Switch to OCT Mode">
                      <i class="fas fa-eye"></i> OCT
                    </button>
                  </div>
                </div>

                <!-- Left Eye Tree Structure Container -->
                <div
                  id="leftEyeTreeContainer"
                  class="eye-tree-container"
                  style="display: none"
                >
                  <div class="eye-tree-header">
                    <h5><i class="fas fa-folder-tree"></i> Left Eye Files</h5>
                    <button
                      class="tree-collapse-btn"
                      onclick="toggleEyeTree('left')"
                    >
                      <i class="fas fa-chevron-down"></i>
                    </button>
                  </div>
                  <div class="eye-tree-content" id="leftEyeTreeContent">
                    <div class="tree-placeholder">No files loaded yet...</div>
                  </div>
                </div>
              </div>

              <!-- Viewport 2 -->
              <div class="viewport" id="viewport2">
                <h4>Viewport 2</h4>
                <div class="viewport-content" id="viewportContent2">
                  <div class="viewport-placeholder">
                    Right-click a DICOM file to load here
                  </div>
                  <img
                    id="viewportImage2"
                    class="viewport-image"
                    style="display: none"
                    alt="DICOM Image 2"
                  />
                  <!-- Enhanced Progress Overlay for Viewport 2 -->
                  <div class="progress-overlay" id="progressOverlay2">
                    <div class="progress-content">
                      <div class="progress-circle">
                        <svg class="progress-ring">
                          <circle
                            class="progress-ring-bg"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                          <circle
                            class="progress-ring-fill"
                            id="progressRing2"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                        </svg>
                        <div
                          class="progress-percentage"
                          id="progressPercentage2"
                        >
                          0%
                        </div>
                      </div>
                      <div class="progress-text" id="progressText2">
                        Initializing...
                      </div>
                      <div
                        class="progress-metadata"
                        id="progressMetadata2"
                      ></div>
                      <div class="progress-steps" id="progressSteps2">
                        <div class="progress-step" id="step1_2"></div>
                        <div class="progress-step" id="step2_2"></div>
                        <div class="progress-step" id="step3_2"></div>
                        <div class="progress-step" id="step4_2"></div>
                        <div class="progress-step" id="step5_2"></div>
                      </div>
                      <!-- Cancel Button for Viewport 2 -->
                      <button
                        class="cancel-button"
                        id="cancelButton2"
                        onclick="cancelOperation(2)"
                        style="display: none"
                      >
                        <i class="fas fa-times"></i>
                        Cancel Download
                      </button>
                    </div>
                  </div>
                  <div
                    id="error2"
                    class="error-message"
                    style="display: none"
                  ></div>
                </div>
                <div class="zoom-controls">
                  <button class="zoom-btn" onclick="zoomViewport(2, 0.8)">
                    -
                  </button>
                  <div class="zoom-level" id="zoomLevel2">100%</div>
                  <button class="zoom-btn" onclick="zoomViewport(2, 1.25)">
                    +
                  </button>
                  <button class="zoom-btn" onclick="resetZoom(2)">Reset</button>
                </div>
                <!-- Frame slider for Viewport 2 -->
                <div class="frame-slider-container" id="frameSliderContainer2">
                  <label for="frameSlider2">Frame:</label>
                  <div class="frame-slider-controls">
                    <button class="frame-nav-btn" id="framePrev2" onclick="navigateFrame(2, -1)" title="Previous Frame">
                      <i class="fas fa-chevron-left"></i>
                    </button>
                    <input
                      type="range"
                      id="frameSlider2"
                      class="frame-slider"
                      min="0"
                      max="0"
                      value="0"
                    />
                    <button class="frame-nav-btn" id="frameNext2" onclick="navigateFrame(2, 1)" title="Next Frame">
                      <i class="fas fa-chevron-right"></i>
                    </button>
                  </div>
                  <div class="frame-info" id="frameInfo2">Frame 1 of 1</div>
                  <div class="mode-switch-controls" id="modeSwitchControls2" style="display: none; margin-top: 10px;">
                    <button class="mode-switch-btn" onclick="switchToRegularMode(2)" title="Switch to Regular Mode">
                      <i class="fas fa-images"></i> Regular
                    </button>
                    <button class="mode-switch-btn" onclick="switchToOCTMode(2)" title="Switch to OCT Mode">
                      <i class="fas fa-eye"></i> OCT
                    </button>
                  </div>
                </div>

                <!-- Right Eye Tree Structure Container -->
                <div
                  id="rightEyeTreeContainer"
                  class="eye-tree-container"
                  style="display: none"
                >
                  <div class="eye-tree-header">
                    <h5><i class="fas fa-folder-tree"></i> Right Eye Files</h5>
                    <button
                      class="tree-collapse-btn"
                      onclick="toggleEyeTree('right')"
                    >
                      <i class="fas fa-chevron-down"></i>
                    </button>
                  </div>
                  <div class="eye-tree-content" id="rightEyeTreeContent">
                    <div class="tree-placeholder">No files loaded yet...</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
      <div class="context-menu-item" id="viewport1Option" onclick="loadIntoViewport(1)">
        <i class="fas fa-eye context-menu-icon"></i>
        View in Viewport 1
      </div>
      <div class="context-menu-item" id="viewport2Option" onclick="loadIntoViewport(2)">
        <i class="fas fa-eye context-menu-icon"></i>
        View in Viewport 2
      </div>
      <div
        class="context-menu-item"
        id="loadE2EOption"
        onclick="loadE2EFile()"
        style="display: none"
      >
        <i class="fas fa-eye-low-vision context-menu-icon"></i>
        Load E2E
      </div>
    </div>

    <footer>
      <span>© 2024 Kodiak Sciences Inc - All Rights Reserved.</span>
      <div class="performance-monitor" id="performanceMonitor">
        Performance: Ready
      </div>
    </footer>

          <!-- S3 Credentials Modal -->
    <div id="s3CredentialsModal" class="s3-credentials-modal">
      <div class="s3-credentials-form">
        <h2><i class="fas fa-cloud"></i> AWS S3 Configuration</h2>

        <div
          id="s3ErrorMessage"
          class="s3-error-message"
          style="display: none"
        ></div>
        <div
          id="s3SuccessMessage"
          class="s3-success-message"
          style="display: none"
        ></div>

        <div id="s3LoadingState" class="s3-loading" style="display: none">
          <div class="loader"></div>
          <p>Testing credentials...</p>
        </div>

        <div id="s3FormContent">
          <p style="color: #666; margin-bottom: 20px; text-align: center">
            Please enter your AWS S3 credentials to access the file browser.
          </p>

          <div class="s3-form-group">
            <label for="s3AccessKey">AWS Access Key ID:</label>
            <input
              type="text"
              id="s3AccessKey"
              placeholder="AKIA..."
              required
            />
            <small style="color: #666; font-size: 12px;">Your AWS access key ID (starts with AKIA)</small>
          </div>

          <div class="s3-form-group">
            <label for="s3SecretKey">AWS Secret Access Key:</label>
            <input
              type="password"
              id="s3SecretKey"
              placeholder="Enter secret key"
              required
            />
            <small style="color: #666; font-size: 12px;">Your AWS secret access key</small>
          </div>

          <div class="s3-form-group">
            <label for="s3Region">AWS Region:</label>
            <select id="s3Region" required>
              <option value="us-east-1">US East (N. Virginia) - us-east-1</option>
              <option value="us-east-2">US East (Ohio) - us-east-2</option>
              <option value="us-west-1">US West (N. California) - us-west-1</option>
              <option value="us-west-2">US West (Oregon) - us-west-2</option>
              <option value="eu-west-1">Europe (Ireland) - eu-west-1</option>
              <option value="eu-central-1">Europe (Frankfurt) - eu-central-1</option>
              <option value="ap-southeast-1">Asia Pacific (Singapore) - ap-southeast-1</option>
              <option value="ap-southeast-2">Asia Pacific (Sydney) - ap-southeast-2</option>
              <option value="ap-northeast-1">Asia Pacific (Tokyo) - ap-northeast-1</option>
              <option value="sa-east-1">South America (São Paulo) - sa-east-1</option>
            </select>
            <small style="color: #666; font-size: 12px;">The region where your S3 bucket is located</small>
          </div>

          <div class="s3-form-group">
            <label for="s3Bucket">S3 Bucket Name:</label>
            <input
              type="text"
              id="s3Bucket"
              placeholder="my-dicom-bucket"
              required
            />
            <small style="color: #666; font-size: 12px;">The name of your S3 bucket containing DICOM files</small>
          </div>

          <div class="s3-form-checkbox">
            <input type="checkbox" id="s3SaveToEnv" checked />
            <label for="s3SaveToEnv"
              >Save credentials to .env file (recommended)</label
            >
            <small style="color: #666; font-size: 12px; display: block; margin-top: 5px;">This will save your credentials locally so you don't need to enter them again</small>
          </div>

          <div class="s3-form-buttons">
            <button
              type="button"
              class="s3-btn s3-btn-secondary"
              onclick="closeS3Modal()"
            >
              Cancel
            </button>
            <button
              type="button"
              class="s3-btn s3-btn-primary"
              onclick="submitS3Credentials()"
            >
              Connect
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let fileCRCs = {};
      let selectedFilePath = null;
      let selectedTreeItem = null;
      let viewportZoom = { 1: 1, 2: 1 };
      let viewportPan = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 } };
      let isDragging = { 1: false, 2: false };
      let lastMousePos = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 } };
      let viewportData = { 1: null, 2: null };
      let s3TreeData = null;
      let currentFrames = { 1: 0, 2: 0 };
      let totalFrames = { 1: 1, 2: 1 };
      let s3StatusChecked = false;
      let s3ConfiguredStatus = null;
      let isStackedLayout = false;

      // E2E specific variables
      let isE2EMode = false;
      let currentE2EFile = null;
      let focusedEye = null;

      // Global variables for layout states
      let isDicomStackedLayout = true; // Default to stacked for DICOM view

      // Performance monitoring
      let performanceTimers = { 1: null, 2: null };

      // Active downloads tracking for cancellation
      let activeDownloads = new Map();
      let abortControllers = new Map();

      // Define custom sort order for tree structure
      const SORT_ORDER = [
        "SCR",
        "Day 1",
        "Day 2",
        "Day 3",
        "Day 4",
        "Day 5",
        "Day 6",
        "Day 7",
        "Week 1",
        "Week 2",
        "Week 3",
        "Week 4",
        "Week 5",
        "Week 6",
        "Week 7",
        "Week 8",
        "Week 9",
        "Week 10",
        "Week 11",
        "Week 12",
      ];
      // Debounce function to prevent rapid successive calls
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Enhanced function to load DICOM with CRC-based caching and cancellation support
      const loadIntoViewportWithPath = debounce(async function(viewportNumber, filePath) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`,
        );
        const errorDiv = document.getElementById(`error${viewportNumber}`);
        const frameSliderContainer = document.getElementById(
          `frameSliderContainer${viewportNumber}`,
        );

        // Create abort controller for cancellation
        const abortController = new AbortController();
        const operationId = `load_${viewportNumber}_${Date.now()}`;

        // Store operation for cancellation
        activeDownloads.set(operationId, {
          viewportNumber: viewportNumber,
          abortController: abortController,
          filePath: filePath,
        });

        // Validate file type before processing
        const fileType = validateFileType(filePath);
        console.log(`[DEBUG] Validated file type: ${fileType} for ${filePath}`);
        
        // Handle file type transitions
        const isE2EFile = fileType === 'E2E';
        
        if (isE2EMode && !isE2EFile) {
            // Switching from E2E mode to regular DICOM - reset E2E mode
            resetE2EMode();
        } else if (!isE2EMode && isE2EFile) {
            // Switching from regular DICOM to E2E mode - clear both viewports
            clearViewport(1);
            clearViewport(2);
        } else if (!isE2EFile) {
            // Loading regular DICOM file - clear the specific viewport
            clearViewport(viewportNumber);
        }

        // Set abort controller in progress manager
        progressManagers[viewportNumber].setAbortController(abortController);

        // Initialize cacheSource variable at function scope
        let cacheSource = "unknown";

        // Start performance timer
        startPerformanceTimer(viewportNumber, "File Selection → Image Loaded");

        // Extract file info for metadata
        const fileName = filePath.split("/").pop();
        const fileExt = fileName.split(".").pop()?.toUpperCase() || "UNKNOWN";

        // Show enhanced progress with cancel support
        const progressOperationId = showProgress(
          viewportNumber,
          "Checking cache...",
          {
            File: fileName,
            Type: fileType,
            Extension: fileExt,
            Source: "S3",
            Cache: "Checking...",
          },
        );

        // Ensure progress is visible before proceeding
        await new Promise(resolve => setTimeout(resolve, 200));

        // Hide other elements
        if (placeholder) placeholder.style.display = "none";
        img.style.display = "none";
        errorDiv.style.display = "none";
        frameSliderContainer.classList.remove("active");

        try {
          console.log(`Starting DICOM load process for ${filePath}`);

          // Check if operation was cancelled
          if (abortController.signal.aborted) {
            throw new Error("Operation cancelled by user");
          }

          // Step 1: Check if file is already cached (either in memory or disk)
          nextProgressStep(viewportNumber, "Checking cache...", {
            Status: "Cache Check",
            Progress: "Step 1/5",
          });

          // Get file metadata for CRC calculation
          const fileMetadata = {
            path: filePath,
            size: s3Browser.selectedItem?.size || 0,
            lastModified: s3Browser.selectedItem?.last_modified || "",
            frame: 0,
          };

          // Try to load from CRC cache first
          try {
            const cachedResult = await loadImageWithCRC(filePath, fileMetadata);

            // Check if cancelled after cache check
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            if (
              cachedResult.source === "cache" ||
              cachedResult.source === "cache_backend_crc"
            ) {
              // Image loaded from cache - display immediately
              nextProgressStep(viewportNumber, "Loaded from cache!", {
                Status: "Cache Hit",
                Cache: cachedResult.source.toUpperCase(),
                CRC: cachedResult.cacheKey.substring(0, 8),
                Progress: "Step 5/5",
              });

              img.onload = () => {
                console.log(
                  `Cached image loaded successfully for viewport ${viewportNumber}`,
                );
                img.style.display = "block";
                centerImage(viewportNumber);
                setupImageInteractions(viewportNumber);

                // Set up single frame (cached images are typically single frame)
                totalFrames[viewportNumber] = 1;
                currentFrames[viewportNumber] = 0;
                setupFrameSlider(viewportNumber);

                hideProgress(viewportNumber);
                endPerformanceTimer(
                  viewportNumber,
                  "File Selection → Image Loaded (Cache)",
                );

                // Clean up operation tracking
                activeDownloads.delete(operationId);
              };

              img.src = cachedResult.imageData;
              return;
            }
          } catch (cacheError) {
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }
            console.warn(`Cache check failed: ${cacheError.message}`);
          }

          // Step 2: Check if file needs to be cached first
          let crc = fileCRCs[filePath];
          if (!crc) {
            nextProgressStep(viewportNumber, "Caching file...", {
              Status: "Caching",
              Progress: "Step 2/5",
            });

            try {
              crc = await ensureFileCached(filePath);
            } catch (err) {
              showNotification(err.message, "error");
              hideProgress(viewportNumber);
              return;
            }
          }

          // Step 3: Download and process DICOM from S3 (should use cache if available)
          nextProgressStep(viewportNumber, "Processing request...", {
            Status: "S3 Download",
            Progress: "Step 3/5",
          });

          try {
            const downloadResponse = await fetch(
              `/api/download_dicom_from_s3?path=${encodeURIComponent(filePath)}`,
              {
                signal: abortController.signal,
              },
            );

            if (!downloadResponse.ok) {
              const errorText = await downloadResponse.text();
              console.error("Download response error:", errorText);
              throw new Error(
                `Download failed: ${downloadResponse.status} ${downloadResponse.statusText}`,
              );
            }

            const dicomData = await downloadResponse.json();
            console.log("DICOM data received:", dicomData);
            console.log(`[DEBUG] dicomData.dicom_file_path: ${dicomData.dicom_file_path}`);
            console.log(`[DEBUG] dicomData.cache_source: ${dicomData.cache_source}`);

            // Check if cancelled after download
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            // Update cacheSource from response
            cacheSource = dicomData.cache_source || "fresh_download";
            let cacheMessage = "";
            switch (cacheSource) {
              case "memory":
                cacheMessage = "Loaded from memory cache";
                break;
              case "disk":
                cacheMessage = "Loaded from disk cache";
                break;
              case "fresh_download":
                cacheMessage = "Downloaded from S3";
                break;
              default:
                cacheMessage = "Processed";
            }

            // Store DICOM data for this viewport
            viewportData[viewportNumber] = dicomData;
            viewportData[viewportNumber].s3_key = filePath;

            // Step 4: Processing DICOM
            nextProgressStep(viewportNumber, cacheMessage, {
              Status: "Processing",
              Frames: dicomData.number_of_frames || 1,
              Cache: cacheSource.toUpperCase(),
              Progress: "Step 4/5",
            });

            // Step 5: Get frame information and load first frame
            nextProgressStep(viewportNumber, "Loading frame data...", {
              Status: "Frame Analysis",
              Cache: cacheSource.toUpperCase(),
              Progress: "Step 5/5",
            });

            const framesResponse = await fetch(
              `/api/view_frames/${dicomData.dicom_file_path}`,
              {
                signal: abortController.signal,
              },
            );

            if (!framesResponse.ok) {
              throw new Error(
                `Failed to get frame info: ${framesResponse.statusText}`,
              );
            }

            const framesData = await framesResponse.json();
            console.log("Frames data received:", framesData);

            // Check if cancelled after frame info
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            totalFrames[viewportNumber] = framesData.number_of_frames;
            currentFrames[viewportNumber] = 0;

            // Step 6: Auto image display logic
            const isOCT = isOCTDicom(viewportData[viewportNumber]);
            const fileType = detectFileType(filePath);
            console.log(`[DEBUG] File type detection: fileType=${fileType}, isOCT=${isOCT}, frames=${dicomData.number_of_frames}`);
            
            if (isOCT || fileType === 'FDA' || fileType === 'FDS') {
              // Handle OCT, FDA, and FDS files with flattening
              const processingType = fileType === 'FDA' ? 'FDA Processing' : 
                                   fileType === 'FDS' ? 'FDS Processing' : 'OCT Processing';
              
              nextProgressStep(viewportNumber, `Applying ${fileType} processing...`, {
                Status: processingType,
                Type: fileType,
                Cache: cacheSource.toUpperCase(),
                Progress: "Step 5/5",
              });

              if (fileType === 'E2E') {
                // E2E files have special handling
                console.log(`[DEBUG] Processing E2E file for viewport ${viewportNumber}`);
                // E2E files are handled differently - they load into the tree structure
                totalFrames[viewportNumber] = 1;
                currentFrames[viewportNumber] = 0;
              } else {
                // OCT, FDA, FDS files use flattening
                console.log(`[DEBUG] Processing ${fileType} file with flattening for viewport ${viewportNumber}`);
                await flattenImageDirectly(viewportNumber);
                
                // Override frame data to show only flattened version
                totalFrames[viewportNumber] = 1;
                currentFrames[viewportNumber] = 0;
              }
            } else {
              // Load the first frame with CRC caching for standard DICOM images
              console.log(`[DEBUG] Loading standard DICOM frame 0 for viewport ${viewportNumber}`);
              
              // Debug: Check DICOM file status before loading
              await checkDicomFileStatus(dicomData.dicom_file_path);
              
              await loadFrameWithCRC(viewportNumber, 0, abortController);

              nextProgressStep(viewportNumber, "Finalizing...", {
                Status: "Complete",
                Type: "Standard DICOM",
                Cache: cacheSource.toUpperCase(),
                Progress: "Step 5/5",
              });
            }
          } catch (error) {
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }
            console.error("Fetch error details:", error);
            
            // If it's a cache-related error, try clearing cache and retrying once
            if (error.message.includes("404") || error.message.includes("not found") || error.message.includes("empty") || 
                error.message.includes("not supported") || error.message.includes("failed")) {
              console.log("[RETRY] Attempting cache clear and retry due to error:", error.message);
              try {
                await clearCacheAndRetry(viewportNumber, filePath);
                return; // Success, exit early
              } catch (retryError) {
                console.error("[RETRY] Cache clear and retry failed:", retryError);
                throw retryError; // Re-throw the original error
              }
            }
            
            throw error;
          }

          // Setup frame slider
          setupFrameSlider(viewportNumber);

          // Populate basic tree data for this file in the appropriate eye tree
          const fileName = filePath.split("/").pop();
          const eyeForViewport = viewportNumber === 1 ? "left" : "right";
          const basicTreeData = {
            dicom: [fileName],
            oct: isOCT ? [fileName] : [],
          };
          populateEyeTree(eyeForViewport, basicTreeData);

          // Complete progress
          updateProgress(viewportNumber, 100, "Loading complete!", {
            Status: "Ready",
            Cache: cacheSource.toUpperCase(),
            Loaded: "Success",
          });

          // Hide progress after a brief delay
          setTimeout(() => {
            hideProgress(viewportNumber);
          }, 1000);

          // End performance timer
          endPerformanceTimer(viewportNumber, "File Selection → Image Loaded");

          console.log(
            `Successfully loaded DICOM into viewport ${viewportNumber} from ${cacheSource}`,
          );
        } catch (error) {
          console.error("Error loading DICOM:", error);

          if (error.message.includes("cancelled")) {
            progressManagers[viewportNumber].updateProgress(
              0,
              "Cancelled by user",
            );
            setTimeout(() => {
              hideProgress(viewportNumber);
              if (placeholder) placeholder.style.display = "block";
            }, 1000);
          } else {
            progressManagers[viewportNumber].setError(
              `Error: ${error.message}`,
            );

            setTimeout(() => {
              hideProgress(viewportNumber);
              errorDiv.textContent = `Error: ${error.message}`;
              errorDiv.style.display = "block";
              if (placeholder) placeholder.style.display = "block";
            }, 2000);
          }

          // End performance timer on error
          endPerformanceTimer(
            viewportNumber,
            "File Selection → Image Loaded (ERROR)",
          );
        } finally {
          // Clean up operation tracking
          activeDownloads.delete(operationId);
        }
      }, 300); // 300ms debounce delay

      // Tree structure sorting functions
      function extractSortKey(itemName) {
        if (!itemName) return "";

        const itemUpper = itemName.toUpperCase();

        // Check for SCR
        if (itemUpper.includes("SCR")) {
          return "SCR";
        }

        // Check for Day patterns
        const dayMatch = itemUpper.match(/DAY\s*(\d+)/);
        if (dayMatch) {
          const dayNum = parseInt(dayMatch[1]);
          return `Day ${dayNum}`;
        }

        // Check for Week patterns
        const weekMatch = itemUpper.match(/WEEK\s*(\d+)/);
        if (weekMatch) {
          const weekNum = parseInt(weekMatch[1]);
          return `Week ${weekMatch[1]}`;
        }

        return itemName;
      }

      function customSortKey(item) {
        const name = item && item.name ? item.name : String(item);
        const sortKey = extractSortKey(name);

        // Get position in sort order
        try {
          const position = SORT_ORDER.indexOf(sortKey);
          return position !== -1
            ? [0, position, sortKey]
            : [1, 0, sortKey.toLowerCase()];
        } catch (error) {
          return [1, 0, sortKey.toLowerCase()];
        }
      }

      function sortTreeStructure(items) {
        try {
          // Separate folders and files
          const folders = items.filter((item) => item.type === "folder");
          const files = items.filter((item) => item.type !== "folder");

          // Sort folders and files separately
          const foldersSorted = folders.sort((a, b) => {
            const aKey = customSortKey(a);
            const bKey = customSortKey(b);

            // Compare arrays element by element
            for (let i = 0; i < Math.max(aKey.length, bKey.length); i++) {
              if (aKey[i] === undefined) return -1;
              if (bKey[i] === undefined) return 1;
              if (aKey[i] !== bKey[i]) {
                return typeof aKey[i] === "string"
                  ? aKey[i].localeCompare(bKey[i])
                  : aKey[i] - bKey[i];
              }
            }
            return 0;
          });

          const filesSorted = files.sort((a, b) => {
            const aKey = customSortKey(a);
            const bKey = customSortKey(b);

            // Compare arrays element by element
            for (let i = 0; i < Math.max(aKey.length, bKey.length); i++) {
              if (aKey[i] === undefined) return -1;
              if (bKey[i] === undefined) return 1;
              if (aKey[i] !== bKey[i]) {
                return typeof aKey[i] === "string"
                  ? aKey[i].localeCompare(bKey[i])
                  : aKey[i] - bKey[i];
              }
            }
            return 0;
          });

          // Recursively sort subfolders
          foldersSorted.forEach((folder) => {
            if (folder.children && folder.children.length > 0) {
              folder.children = sortTreeStructure(folder.children);
            }
          });

          // Return folders first, then files
          return [...foldersSorted, ...filesSorted];
        } catch (error) {
          console.error("Error sorting tree structure:", error);
          return items;
        }
      }

      // CRC-based Image Cache System
      class CRCImageCache {
        constructor() {
          this.cache = new Map();
          this.maxCacheSize = 100; // Maximum number of cached images
          this.cacheStats = {
            hits: 0,
            misses: 0,
            evictions: 0,
          };
        }

        // Calculate CRC32 for a given string/buffer
        calculateCRC32(data) {
          const crcTable = new Uint32Array(256);
          for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) {
              c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
            }
            crcTable[i] = c;
          }

          let crc = 0 ^ -1;
          const bytes = new TextEncoder().encode(data);
          for (let i = 0; i < bytes.length; i++) {
            crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xff];
          }
          return ((crc ^ -1) >>> 0).toString(16).padStart(8, "0");
        }

        // Generate cache key from file path and metadata
        generateCacheKey(filePath, metadata = {}) {
          const keyData = JSON.stringify({
            path: filePath,
            size: metadata.size || 0,
            lastModified: metadata.lastModified || "",
            frame: metadata.frame || 0,
          });
          return this.calculateCRC32(keyData);
        }

        // Check if image exists in cache
        has(cacheKey) {
          return this.cache.has(cacheKey);
        }

        // Get image from cache
        get(cacheKey) {
          if (this.cache.has(cacheKey)) {
            const item = this.cache.get(cacheKey);
            // Update access time for LRU
            item.lastAccessed = Date.now();
            this.cacheStats.hits++;
            console.log(`[CACHE HIT] Key: ${cacheKey}`);
            return item;
          }
          this.cacheStats.misses++;
          console.log(`[CACHE MISS] Key: ${cacheKey}`);
          return null;
        }

        // Store image in cache
        set(cacheKey, imageData, metadata = {}) {
          // Evict oldest items if cache is full
          if (this.cache.size >= this.maxCacheSize) {
            this.evictOldest();
          }

          const cacheItem = {
            imageData: imageData,
            metadata: metadata,
            cachedAt: Date.now(),
            lastAccessed: Date.now(),
            cacheKey: cacheKey,
          };

          this.cache.set(cacheKey, cacheItem);
          console.log(`[CACHE SET] Key: ${cacheKey}, Size: ${this.cache.size}`);
        }

        // Evict oldest cache entry
        evictOldest() {
          let oldestKey = null;
          let oldestTime = Date.now();

          for (const [key, item] of this.cache.entries()) {
            if (item.lastAccessed < oldestTime) {
              oldestTime = item.lastAccessed;
              oldestKey = key;
            }
          }

          if (oldestKey) {
            this.cache.delete(oldestKey);
            this.cacheStats.evictions++;
            console.log(`[CACHE EVICT] Key: ${oldestKey}`);
          }
        }

        // Get cache statistics
        getStats() {
          return {
            ...this.cacheStats,
            size: this.cache.size,
            maxSize: this.maxCacheSize,
            hitRate:
              this.cacheStats.hits /
                (this.cacheStats.hits + this.cacheStats.misses) || 0,
          };
        }

        // Clear cache
        clear() {
          this.cache.clear();
          this.cacheStats = { hits: 0, misses: 0, evictions: 0 };
          console.log("[CACHE CLEAR] Cache cleared");
        }
      }

      // Initialize global cache instance
      const imageCache = new CRCImageCache();

      // Enhanced image loading with CRC-based caching and OCT flattening priority
      async function loadImageWithCRC(filePath, metadata = {}) {
        try {
          // For OCT images, check for flattened version first
          if (metadata.isOCT || filePath.toLowerCase().includes("oct")) {
            const flattenMetadata = {
              path: filePath,
              flattened: true,
              frame: metadata.frame || 0,
            };

            const flattenCacheKey = imageCache.generateCacheKey(
              filePath + "_flattened",
              flattenMetadata,
            );
            const cachedFlattened = imageCache.get(flattenCacheKey);

            if (cachedFlattened) {
              console.log(
                `[OCT CACHE] Using cached flattened image for ${filePath}`,
              );
              return {
                imageData: cachedFlattened.imageData,
                source: "cache_flattened",
                cacheKey: flattenCacheKey,
                metadata: cachedFlattened.metadata,
              };
            }
          }

          // Step 1: Generate CRC-based cache key for original image
          const cacheKey = imageCache.generateCacheKey(filePath, metadata);
          console.log(`[CRC CACHE] Generated key: ${cacheKey} for ${filePath}`);

          // Step 2: Check local cache for original image (only for non-OCT)
          if (!metadata.isOCT && !filePath.toLowerCase().includes("oct")) {
            const cachedItem = imageCache.get(cacheKey);
            if (cachedItem) {
              console.log(`[CRC CACHE] Using cached image for ${filePath}`);
              return {
                imageData: cachedItem.imageData,
                source: "cache",
                cacheKey: cacheKey,
                metadata: cachedItem.metadata,
              };
            }
          }

          // Continue with rest of the function...
          // (Keep the existing backend CRC check and download logic)
          // Step 3: Check if backend has CRC info
          let backendCRC = null;
          try {
            const crcResponse = await fetch(
              `/api/get-file-crc?path=${encodeURIComponent(filePath)}`,
            );
            if (crcResponse.ok) {
              const crcData = await crcResponse.json();
              backendCRC = crcData.crc;

              // If backend CRC differs from our calculated CRC, use backend CRC
              if (backendCRC && backendCRC !== cacheKey) {
                const backendCachedItem = imageCache.get(backendCRC);
                if (backendCachedItem) {
                  console.log(
                    `[CRC CACHE] Using backend CRC cached image: ${backendCRC}`,
                  );
                  return {
                    imageData: backendCachedItem.imageData,
                    source: "cache_backend_crc",
                    cacheKey: backendCRC,
                    metadata: backendCachedItem.metadata,
                  };
                }
              }
            }
          } catch (error) {
            console.warn(
              `[CRC CACHE] Could not get backend CRC: ${error.message}`,
            );
          }

          // Step 4: Download image with CRC query parameter for HTTP caching
          const finalCacheKey = backendCRC || cacheKey;
          
          // Use the correct dicom_file_path - prioritize metadata.dicomFilePath over filePath
          const dicomFilePath = metadata.dicomFilePath || filePath;
          console.log(`[CRC CACHE] Using dicom_file_path: ${dicomFilePath} for file: ${filePath}`);
          
          const imageUrl = `/api/view_dicom_png?frame=${metadata.frame || 0}&dicom_file_path=${encodeURIComponent(dicomFilePath)}&v=${finalCacheKey}`;

          console.log(
            `[CRC CACHE] Downloading image with CRC: ${finalCacheKey}`,
          );
          console.log(`[CRC CACHE] Image URL: ${imageUrl}`);
          
          const response = await fetch(imageUrl, {
            headers: {
              "Cache-Control": "public, max-age=31536000, immutable",
            },
          });

          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            console.error(`[CRC CACHE] HTTP Error ${response.status}: ${response.statusText}`);
            console.error(`[CRC CACHE] Error details: ${errorText}`);
            throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
          }

          const imageBlob = await response.blob();
          console.log(`[CRC CACHE] Downloaded image blob: ${imageBlob.size} bytes, type: ${imageBlob.type}`);
          
          if (imageBlob.size === 0) {
            throw new Error("Downloaded image is empty (0 bytes)");
          }
          
          const imageUrl_cached = URL.createObjectURL(imageBlob);

          // Step 5: Store in cache
          const cacheMetadata = {
            ...metadata,
            downloadedAt: Date.now(),
            contentType: response.headers.get("content-type"),
            size: imageBlob.size,
          };

          imageCache.set(finalCacheKey, imageUrl_cached, cacheMetadata);

          return {
            imageData: imageUrl_cached,
            source: "download",
            cacheKey: finalCacheKey,
            metadata: cacheMetadata,
          };
        } catch (error) {
          console.error(`[CRC CACHE] Error loading image: ${error.message}`);
          throw error;
        }
      }

      // Auto image display logic - determine if DICOM is OCT
      // Enhanced OCT detection
      function isOCTDicom(dicomData) {
        if (!dicomData) return false;

        // Check filename patterns
        if (dicomData.s3_key) {
          const filename = dicomData.s3_key.toLowerCase();
          if (filename.includes("oct") || filename.includes("optical")) {
            return true;
          }
        }

        // Check if it's multi-frame (common for OCT)
        if (dicomData.number_of_frames && dicomData.number_of_frames > 1) {
          return true;
        }

        return false;
      }

      // Enhanced file type detection for better debugging
      function detectFileType(filePath) {
        const filename = filePath.toLowerCase();
        if (filename.endsWith('.dcm') || filename.endsWith('.dicom')) {
          return 'DICOM';
        } else if (filename.endsWith('.e2e')) {
          return 'E2E';
        } else if (filename.endsWith('.fda')) {
          return 'FDA';
        } else if (filename.endsWith('.fds')) {
          return 'FDS';
        } else {
          return 'UNKNOWN';
        }
      }

      // Function to validate file type support
      function validateFileType(filePath) {
        const fileType = detectFileType(filePath);
        const supportedTypes = ['DICOM', 'E2E', 'FDA', 'FDS'];
        
        if (!supportedTypes.includes(fileType)) {
          throw new Error(`Unsupported file type: ${fileType}. Supported types: ${supportedTypes.join(', ')}`);
        }
        
        return fileType;
      }
      function isOCT(dicomData) {
        return isOCTDicom(dicomData);
      }

      // Performance monitoring functions
      function startPerformanceTimer(viewportNumber, operation) {
        performanceTimers[viewportNumber] = {
          start: performance.now(),
          operation: operation,
        };
        updatePerformanceDisplay(`${operation} started...`);
      }

      function endPerformanceTimer(viewportNumber, operation) {
        if (performanceTimers[viewportNumber]) {
          const elapsed =
            performance.now() - performanceTimers[viewportNumber].start;
          const elapsedSeconds = (elapsed / 1000).toFixed(2);
          updatePerformanceDisplay(
            `${operation} completed in ${elapsedSeconds}s`,
          );

          // Log to console for debugging
          console.log(
            `[PERFORMANCE] Viewport ${viewportNumber} - ${operation}: ${elapsedSeconds}s`,
          );

          // Warn if over 7 seconds
          if (elapsed > 7000) {
            console.warn(
              `[PERFORMANCE WARNING] Operation took ${elapsedSeconds}s (target: <7s)`,
            );
          }

          performanceTimers[viewportNumber] = null;
        }
      }

      function updatePerformanceDisplay(message) {
        const monitor = document.getElementById("performanceMonitor");
        if (monitor) {
          monitor.textContent = `Performance: ${message}`;
        }
      }

      // DICOM Layout toggle functionality
      function toggleDicomViewportLayout() {
        const container = document.getElementById("dicomViewportsContainer");
        const icon = document.getElementById("dicomLayoutIcon");
        const text = document.getElementById("dicomLayoutText");

        isDicomStackedLayout = !isDicomStackedLayout;

        if (isDicomStackedLayout) {
          container.classList.remove("side-by-side");
          container.classList.add("stacked");
          icon.className = "fas fa-columns";
          text.textContent = "Switch to Side-by-Side";
        } else {
          container.classList.remove("stacked");
          container.classList.add("side-by-side");
          icon.className = "fas fa-grip-lines";
          text.textContent = "Switch to Stacked";
        }

        console.log(
          `DICOM viewport layout changed to: ${isDicomStackedLayout ? "stacked" : "side-by-side"}`,
        );
      }

      // Update the existing S3 layout toggle to be more specific
      function toggleViewportLayout() {
        // Don't allow layout toggle in focus mode
        if (focusedEye) {
          console.log("Layout toggle disabled in focus mode");
          return;
        }

        const container = document.getElementById("viewportsContainer");
        const icon = document.getElementById("layoutIcon");
        const text = document.getElementById("layoutText");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");

        isStackedLayout = !isStackedLayout;

        // Remove any previous wrappers
        function removeRowWrappers() {
          const leftRow = document.getElementById("leftViewportRow");
          const rightRow = document.getElementById("rightViewportRow");
          if (leftRow) {
            if (viewport1 && leftRow.contains(viewport1)) container.appendChild(viewport1);
            if (leftTreeContainer && leftRow.contains(leftTreeContainer)) viewport1.appendChild(leftTreeContainer);
            leftRow.remove();
          }
          if (rightRow) {
            if (viewport2 && rightRow.contains(viewport2)) container.appendChild(viewport2);
            if (rightTreeContainer && rightRow.contains(rightTreeContainer)) viewport2.appendChild(rightTreeContainer);
            rightRow.remove();
          }
        }

        if (isStackedLayout) {
          container.classList.add("stacked");
          container.style.flexDirection = "column";
          container.style.gap = "8px";
          icon.className = "fas fa-grip-lines";
          text.textContent = "Switch to Side-by-Side";

          // E2E mode: each viewport + its tree in a row (80/20)
          if (isE2EMode) {
            removeRowWrappers();
            // LEFT
            const leftRow = document.createElement("div");
            leftRow.id = "leftViewportRow";
            leftRow.style.display = "flex";
            leftRow.style.flexDirection = "row";
            leftRow.style.width = "95%";
            leftRow.style.height = "540px";
            leftRow.style.gap = "8px";
            leftRow.style.alignItems = "stretch";
            // Set viewport1 styles
            if (viewport1) {
              viewport1.style.width = "80%";
              viewport1.style.flex = "0 0 80%";
              leftRow.appendChild(viewport1);
            }
            if (leftTreeContainer) {
              leftTreeContainer.style.display = "block";
              leftTreeContainer.style.width = "20%";
              leftTreeContainer.style.height = "620px";
              leftTreeContainer.style.maxHeight = "90%";
              leftTreeContainer.style.flex = "0 0 20%";
              leftTreeContainer.style.marginBottom = "0";
              leftTreeContainer.style.marginTop = "10px";
              leftTreeContainer.style.border = "1px solid #e9ecef";
              leftRow.appendChild(leftTreeContainer);
            }
            container.appendChild(leftRow);
            // RIGHT
            const rightRow = document.createElement("div");
            rightRow.id = "rightViewportRow";
            rightRow.style.display = "flex";
            rightRow.style.flexDirection = "row";
            rightRow.style.width = "95%";
            rightRow.style.height = "540px";
            rightRow.style.gap = "8px";
            rightRow.style.alignItems = "stretch";
            if (viewport2) {
              viewport2.style.width = "80%";
              viewport2.style.flex = "0 0 80%";
              rightRow.appendChild(viewport2);
            }
            if (rightTreeContainer) {
              rightTreeContainer.style.display = "block";
              rightTreeContainer.style.width = "20%";
              rightTreeContainer.style.height = "590px";
              rightTreeContainer.style.flex = "0 0 20%";
              rightTreeContainer.style.marginBottom = "0";
              rightTreeContainer.style.maxHeight = "90%";
              rightTreeContainer.style.marginTop = "10px";
              rightTreeContainer.style.border = "1px solid #e9ecef";
              rightRow.appendChild(rightTreeContainer);
            }
            container.appendChild(rightRow);
          } else {
            // For non-E2E mode, use original stacked behavior
            removeRowWrappers();
            if (viewport1) {
              viewport1.style.width = "";
              viewport1.style.flex = "1";
            }
            if (viewport2) {
              viewport2.style.width = "";
              viewport2.style.flex = "1";
            }
            if (leftTreeContainer) leftTreeContainer.style.display = "none";
            if (rightTreeContainer) rightTreeContainer.style.display = "none";
          }
        } else {
          container.classList.remove("stacked");
          container.style.flexDirection = "row";
          icon.className = "fas fa-columns";
          text.textContent = "Switch to Stacked";

          // Clean up E2E stacked wrappers if present
          removeRowWrappers();

          // Reset viewport styles
          if (viewport1) {
            viewport1.style.width = "";
            viewport1.style.flex = "1";
          }
          if (viewport2) {
            viewport2.style.width = "";
            viewport2.style.flex = "1";
          }

          // Show eye trees in side-by-side layout if E2E
          if (leftTreeContainer && isE2EMode) {
            leftTreeContainer.style.display = "block";
            leftTreeContainer.style.width = "";
            leftTreeContainer.style.flex = "";
            leftTreeContainer.style.border = "2px solid #e9ecef";
            leftTreeContainer.style.marginBottom = "";
            leftTreeContainer.style.maxHeight = "300px";
            if (viewport1 && !viewport1.contains(leftTreeContainer)) {
              viewport1.appendChild(leftTreeContainer);
            }
          }
          if (rightTreeContainer && isE2EMode) {
            rightTreeContainer.style.display = "block";
            rightTreeContainer.style.width = "";
            rightTreeContainer.style.flex = "";
            rightTreeContainer.style.border = "2px solid #e9ecef";
            rightTreeContainer.style.maxHeight = "300px";
            if (viewport2 && !viewport2.contains(rightTreeContainer)) {
              viewport2.appendChild(rightTreeContainer);
            }
          }
        }

        console.log(
          `S3 viewport layout changed to: ${isStackedLayout ? "stacked" : "side-by-side"}`,
        );
      }

      // Enhanced Progress Management with Cancel Support
      class ProgressManager {
        constructor(viewportNumber) {
          this.viewportNumber = viewportNumber;
          this.currentStep = 0;
          this.totalSteps = 5;
          this.percentage = 0;
          this.metadata = {};
          this.abortController = null;
          this.operationId = null;
        }

        show(message = "Loading...", metadata = {}, operationId = null) {
          try {
            const overlay = document.getElementById(
              `progressOverlay${this.viewportNumber}`,
            );
            const text = document.getElementById(
              `progressText${this.viewportNumber}`,
            );
            const cancelButton = document.getElementById(
              `cancelButton${this.viewportNumber}`,
            );

            if (!overlay) {
              console.error(`Progress overlay not found for viewport ${this.viewportNumber}`);
              return;
            }

            if (!text) {
              console.error(`Progress text element not found for viewport ${this.viewportNumber}`);
              return;
            }

            // Force visibility with multiple approaches
            text.textContent = message;
            overlay.style.display = "flex";
            overlay.style.visibility = "visible";
            overlay.style.opacity = "1";
            overlay.classList.add("active");
            
            // Ensure the overlay is on top
            overlay.style.zIndex = "1000";
            
            this.updateMetadata(metadata);
            this.updateProgress(0);
            this.currentStep = 0;
            this.updateSteps();

            // Show cancel button if operation can be cancelled
            if (operationId && cancelButton) {
              this.operationId = operationId;
              cancelButton.style.display = "flex";
            } else if (cancelButton) {
              cancelButton.style.display = "none";
            }

            console.log(`Progress shown for viewport ${this.viewportNumber}: ${message}`);
            console.log(`Overlay display: ${overlay.style.display}, visibility: ${overlay.style.visibility}, opacity: ${overlay.style.opacity}`);
          } catch (error) {
            console.error(`Error showing progress for viewport ${this.viewportNumber}:`, error);
          }
        }

        hide() {
          try {
            const overlay = document.getElementById(
              `progressOverlay${this.viewportNumber}`,
            );
            const cancelButton = document.getElementById(
              `cancelButton${this.viewportNumber}`,
            );

            if (overlay) {
              overlay.classList.remove("active");
              // Add a small delay before hiding to ensure smooth transition
              setTimeout(() => {
                if (overlay && !overlay.classList.contains("active")) {
                  overlay.style.display = "none";
                }
              }, 300);
            }

            if (cancelButton) {
              cancelButton.style.display = "none";
            }

            this.operationId = null;
            this.abortController = null;
            console.log(`Progress hidden for viewport ${this.viewportNumber}`);
          } catch (error) {
            console.error(`Error hiding progress for viewport ${this.viewportNumber}:`, error);
          }
        }

        updateProgress(percentage, message = null) {
          try {
            this.percentage = Math.max(0, Math.min(100, percentage));

            const ring = document.getElementById(
              `progressRing${this.viewportNumber}`,
            );
            const percentageEl = document.getElementById(
              `progressPercentage${this.viewportNumber}`,
            );
            const text = document.getElementById(
              `progressText${this.viewportNumber}`,
            );

            if (ring) {
              const circumference = 226; // 2 * π * 36
              const offset =
                circumference - (this.percentage / 100) * circumference;
              ring.style.strokeDashoffset = offset;
            }

            if (percentageEl) {
              percentageEl.textContent = `${Math.round(this.percentage)}%`;
            }

            if (message && text) {
              text.textContent = message;
            }

            console.log(`Progress updated for viewport ${this.viewportNumber}: ${this.percentage}% - ${message || ''}`);
          } catch (error) {
            console.error(`Error updating progress for viewport ${this.viewportNumber}:`, error);
          }
        }

        nextStep(message, metadata = {}) {
          this.currentStep = Math.min(this.currentStep + 1, this.totalSteps);
          const stepPercentage = (this.currentStep / this.totalSteps) * 100;
          this.updateProgress(stepPercentage, message);
          this.updateMetadata(metadata);
          this.updateSteps();
        }

        updateMetadata(metadata) {
          this.metadata = { ...this.metadata, ...metadata };
          const container = document.getElementById(
            `progressMetadata${this.viewportNumber}`,
          );

          if (container) {
            container.innerHTML = "";

            Object.entries(this.metadata).forEach(([key, value], index) => {
              if (value) {
                const tag = document.createElement("div");
                tag.className = "metadata-tag";
                tag.textContent = `${key}: ${value}`;
                tag.style.animationDelay = `${index * 0.1}s`;
                container.appendChild(tag);
              }
            });
          }
        }

        updateSteps() {
          for (let i = 1; i <= this.totalSteps; i++) {
            const step = document.getElementById(
              `step${i}_${this.viewportNumber}`,
            );
            if (step) {
              step.classList.remove("active", "completed");
              if (i < this.currentStep) {
                step.classList.add("completed");
              } else if (i === this.currentStep) {
                step.classList.add("active");
              }
            }
          }
        }

        setError(message) {
          this.updateProgress(0, message);
          const ring = document.getElementById(
            `progressRing${this.viewportNumber}`,
          );
          if (ring) {
            ring.style.stroke = "#dc3545";
          }
        }

        setAbortController(controller) {
          this.abortController = controller;
        }

        cancel() {
          if (this.abortController) {
            this.abortController.abort();
            this.updateProgress(0, "Cancelling...");

            setTimeout(() => {
              this.hide();
            }, 1000);
          }
        }
      }

      // Create progress managers for both viewports
      const progressManagers = {
        1: new ProgressManager(1),
        2: new ProgressManager(2),
      };

      // Test function to verify progress system is working
      function testProgressSystem(viewportNumber = 1) {
        console.log(`Testing progress system for viewport ${viewportNumber}`);
        
        if (!progressManagers[viewportNumber]) {
          console.error(`Progress manager not found for viewport ${viewportNumber}`);
          return;
        }

        // Test showing progress
        progressManagers[viewportNumber].show("Testing progress system...", {
          "Test": "Progress",
          "Viewport": viewportNumber
        });

        // Simulate progress updates
        let progress = 0;
        const interval = setInterval(() => {
          progress += 10;
          progressManagers[viewportNumber].updateProgress(progress, `Testing... ${progress}%`);
          
          if (progress >= 100) {
            clearInterval(interval);
            setTimeout(() => {
              progressManagers[viewportNumber].hide();
              console.log("Progress system test completed");
            }, 1000);
          }
        }, 200);
      }

      // Make test function globally available
      window.testProgressSystem = testProgressSystem;

      // Debug function to check progress system elements
      function debugProgressSystem() {
        console.log("=== Progress System Debug ===");
        
        for (let viewport = 1; viewport <= 2; viewport++) {
          console.log(`\nViewport ${viewport}:`);
          
          const elements = {
            overlay: document.getElementById(`progressOverlay${viewport}`),
            text: document.getElementById(`progressText${viewport}`),
            percentage: document.getElementById(`progressPercentage${viewport}`),
            ring: document.getElementById(`progressRing${viewport}`),
            cancelButton: document.getElementById(`cancelButton${viewport}`),
            metadata: document.getElementById(`progressMetadata${viewport}`),
            steps: document.getElementById(`progressSteps${viewport}`)
          };
          
          Object.entries(elements).forEach(([name, element]) => {
            console.log(`  ${name}: ${element ? '✓ Found' : '✗ Missing'}`);
          });
          
          console.log(`  Progress Manager: ${progressManagers[viewport] ? '✓ Created' : '✗ Missing'}`);
        }
        
        console.log("=== End Debug ===");
      }

      // Make debug function globally available
      window.debugProgressSystem = debugProgressSystem;



      // Cancel operation function
      function cancelOperation(viewportNumber) {
        console.log(`Cancelling operation for viewport ${viewportNumber}`);

        if (progressManagers[viewportNumber]) {
          progressManagers[viewportNumber].cancel();
        }

        // Also cancel any active downloads
        for (const [operationId, downloadInfo] of activeDownloads.entries()) {
          if (downloadInfo.viewportNumber === viewportNumber) {
            if (downloadInfo.abortController) {
              downloadInfo.abortController.abort();
            }
            activeDownloads.delete(operationId);
            console.log(`Cancelled download operation: ${operationId}`);
          }
        }
      }

      // Update the existing progress functions
      function showProgress(
        viewportNumber,
        message = "Loading...",
        metadata = {},
      ) {
        console.log(`showProgress called for viewport ${viewportNumber}: ${message}`);
        console.log(`Progress manager exists: ${!!progressManagers[viewportNumber]}`);
        
        if (!progressManagers[viewportNumber]) {
          console.error(`Progress manager not found for viewport ${viewportNumber}`);
          return null;
        }
        
        const operationId = `operation_${viewportNumber}_${Date.now()}`;
        progressManagers[viewportNumber].show(message, metadata, operationId);
        
        // Verify the progress is actually shown
        setTimeout(() => {
          const overlay = document.getElementById(`progressOverlay${viewportNumber}`);
          if (overlay) {
            console.log(`Progress overlay state after show: display=${overlay.style.display}, classList=${overlay.classList.toString()}`);
          }
        }, 100);
        
        return operationId;
      }

      function hideProgress(viewportNumber) {
        progressManagers[viewportNumber].hide();
      }

      function updateProgress(
        viewportNumber,
        percentage,
        message = null,
        metadata = {},
      ) {
        progressManagers[viewportNumber].updateProgress(percentage, message);
        // Only include allowed metadata keys
        const allowedKeys = ["File", "Type", "Eye"];
        const filteredMetadata = {};
        for (const key of allowedKeys) {
            if (metadata[key]) filteredMetadata[key] = metadata[key];
        }
        if (Object.keys(filteredMetadata).length > 0) {
            progressManagers[viewportNumber].updateMetadata(filteredMetadata);
        }
      }

      function nextProgressStep(viewportNumber, message, metadata = {}) {
        const allowedKeys = ["File", "Type", "Eye"];
        const filteredMetadata = {};
        for (const key of allowedKeys) {
            if (metadata[key]) filteredMetadata[key] = metadata[key];
        }
        progressManagers[viewportNumber].nextStep(message, filteredMetadata);
      }

      // Toggle between DICOM view and File Browser
      async function toggleFileFrame() {
        const dicomView = document.getElementById("dicomView");
        const fileBrowser = document.getElementById("fileBrowserContainer");

        if (
          fileBrowser.style.display === "none" ||
          fileBrowser.style.display === ""
        ) {
          const s3Ready = await checkS3Status();
          if (!s3Ready) {
            return;
          }

          dicomView.style.display = "none";
          fileBrowser.style.display = "block";
          if (!s3TreeData) {
            loadS3Tree();
          }
        } else {
          fileBrowser.style.display = "none";
          dicomView.style.display = "flex";
        }
      }

      // Enhanced Tree Browser with Drill-down Navigation and Sorting
      class S3TreeBrowser {
        constructor() {
          this.currentPath = [];
          this.currentData = null;
          this.rootData = null;
          this.selectedItem = null;
          this.isLoading = false;
        }

        async initialize() {
          await this.loadRootLevel();
        }

        async loadRootLevel() {
          try {
            this.showLoading();
            console.log("Loading S3 root tree with fastest method...");

            // Always use the fastest method
            const response = await fetch("/api/s3-fast-list?use_parallel=true&auto_prefixes=true&max_workers=10");

            if (response.status === 503) {
              const data = await response.json();
              if (data.needs_credentials) {
                showS3CredentialsModal();
                return;
              }
            }

            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`,
              );
            }

            const data = await response.json();
            console.log("S3 list data received:", data);

            // Handle the new response format
            let files = [];
            if (data.files && Array.isArray(data.files)) {
              files = data.files;
            } else if (Array.isArray(data)) {
              // Fallback for old format
              files = data;
            } else {
              throw new Error("Invalid response format: expected files array");
            }

            // Update performance info display
            updatePerformanceInfo(data);

            // Log performance metrics
            if (data.duration_seconds) {
              console.log(`S3 listing completed in ${data.duration_seconds.toFixed(2)}s`);
              console.log(`Speed: ${data.files_per_second?.toFixed(1) || 'N/A'} files/second`);
              console.log(`Method: ${data.method || 'unknown'}`);
            }

            // Build the tree from flat list and apply sorting
            this.rootData = this.buildTreeFromFlatList(files);
            this.currentData = this.rootData;
            this.currentPath = [];
            this.renderCurrentLevel();
            this.hideLoading();

            // Optional: hide the progress display
            document
              .getElementById("treeProgressBarContainer")
              ?.style?.setProperty("display", "none", "important");
          } catch (error) {
            console.error("Error loading S3 list:", error);
            this.showError(`Failed to load S3 tree: ${error.message}`);
          }
        }

        buildTreeFromFlatList(files) {
          const root = [];

          files.forEach((file) => {
            const parts = file.key.split("/");
            let current = root;

            parts.forEach((part, index) => {
              let node = current.find((n) => n.name === part);
              if (!node) {
                node = {
                  name: part,
                  type: index === parts.length - 1 ? "file" : "folder",
                  ...(index === parts.length - 1
                    ? {
                        size: file.size,
                        last_modified: file.last_modified,
                        path: file.key,
                      }
                    : { children: [] }),
                };
                current.push(node);
              }
              if (node.type === "folder") {
                current = node.children;
              }
            });
          });

          // Apply custom sorting to the entire tree
          return sortTreeStructure(root);
        }

        showLoading() {
          const container = document.getElementById("fileTreeContainer");
          container.innerHTML = `
      <div class="tree-loading">
        <div class="loader"></div>
        <span style="margin-left: 10px;">Loading...</span>
      </div>
    `;
          this.isLoading = true;
        }

        hideLoading() {
          this.isLoading = false;
        }

        showError(message) {
          const container = document.getElementById("fileTreeContainer");
          container.innerHTML = `
      <div class="tree-error">
        <p>${message}</p>
        <button class="retry-button" onclick="s3Browser.loadRootLevel()">Retry</button>
      </div>
    `;
          this.hideLoading();
        }

        renderCurrentLevel() {
          this.updateNavigation();
          this.renderItems();
        }

        renderSearchResults(results) {
          const container = document.getElementById("fileTreeContainer");

          if (!results.length) {
            container.innerHTML =
              '<div class="tree-empty">No matching files or folders found.</div>';
            return;
          }

          // Helper to format bytes to KB/MB/GB
          function formatFileSize(bytes) {
            if (bytes === 0 || bytes == null) return "";
            const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            const size = bytes / Math.pow(1024, i);
            return `${size.toFixed(1)} ${sizes[i]}`;
          }

          const ul = document.createElement("ul");
          ul.className = "file-tree";

          results.forEach((result) => {
            const li = document.createElement("li");
            li.className = "tree-item";
            li.dataset.fullPath = result.path;
            li.dataset.name = result.name;
            li.dataset.type = result.type;

            const iconClass =
              result.type === "folder" ? "fa-folder" : "fa-file";
            const iconColor =
              result.type === "folder" ? "folder-icon" : "file-icon";
            const sizeText =
              result.type === "file" ? formatFileSize(result.size) : "";

            li.innerHTML = `
      <div class="tree-item-content">
        <div class="tree-icon ${iconColor}">
          <i class="fas ${iconClass}"></i>
        </div>
        <div class="tree-item-name">${result.fullPath}</div>
        <div class="tree-item-info">${sizeText}</div>
      </div>
    `;

            // Right-click to show context menu and set selected file
            li.addEventListener("contextmenu", function (e) {
              selectedTreeItem = li;

              // Call the corrected function with the event and file path
              showContextMenu(e, result.path);

              // Highlight selected item
              document
                .querySelectorAll(".tree-item.selected")
                .forEach((el) => el.classList.remove("selected"));
              li.classList.add("selected");
            });

            ul.appendChild(li);
          });

          container.innerHTML = "";
          container.appendChild(ul);
        }

        updateNavigation() {
          const backButton = document.getElementById("backButton");
          const currentPathSpan = document.getElementById("currentPath");

          if (this.currentPath.length > 0) {
            backButton.classList.add("visible");
            currentPathSpan.textContent = this.currentPath.join(" / ");
          } else {
            backButton.classList.remove("visible");
            currentPathSpan.textContent = "Root";
          }
        }

        renderItems() {
          const container = document.getElementById("fileTreeContainer");

          if (!this.currentData || this.currentData.length === 0) {
            container.innerHTML =
              '<div class="tree-empty">No files or folders found</div>';
            return;
          }

          // Apply sorting to current level before rendering
          const sortedData = sortTreeStructure([...this.currentData]);

          const treeList = document.createElement("ul");
          treeList.className = "file-tree";

          sortedData.forEach((item) => {
            const listItem = this.createTreeItem(item, this.currentPath);
            treeList.appendChild(listItem);
          });

          container.innerHTML = "";
          container.appendChild(treeList);

          // Re-apply selection mode if it was active
          if (isSelectionMode) {
            setTimeout(() => {
              addSelectionCheckboxes();
            }, 50);
          }
        }

        // ...inside S3TreeBrowser class...

        createTreeItem(item, parentPath = []) {
          const li = document.createElement("li");

          const treeItem = document.createElement("div");
          treeItem.className = "tree-item";

          // Build full path for this item
          const fullPath = [...parentPath, item.name].join("/");

          // Always set data-full-path for both files and folders
          treeItem.dataset.fullPath = fullPath;
          treeItem.dataset.name = item.name;
          treeItem.dataset.type = item.type;

          // Add appropriate class for ALL items to enable selection
          if (item.type === "file") {
            treeItem.classList.add("file-item");
            treeItem.dataset.filePath = item.path || fullPath;
          } else if (item.type === "folder") {
            treeItem.classList.add("folder-item");
          }

          // === Click behavior (select or expand) ===
          treeItem.onclick = (e) => {
            if (isSelectionMode) {
              handleFileSelection(e);
            } else {
              this.handleItemClick(item, treeItem);
            }
          };

          // === Right-click context menu for FILES only ===
          if (item.type === "file" && item.path) {
            treeItem.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              selectedFilePath = item.path;
              this.selectedItem = item;

              // Clear previous selection and select this item
              document.querySelectorAll(".tree-item.selected").forEach((el) => {
                el.classList.remove("selected");
              });
              treeItem.classList.add("selected");

              showContextMenu(e, item.path);
            });
          }

          // === Content container ===
          const content = document.createElement("div");
          content.className = "tree-item-content";

          // === Expand arrow (only folders) ===
          const arrow = document.createElement("div");
          arrow.className = "expand-arrow collapsed";
          arrow.textContent = item.type === "folder" ? ">" : "";
          if (item.type !== "folder") {
            arrow.style.width = "16px"; // spacer for file rows
          }
          content.appendChild(arrow);

          // === Icon ===
          const icon = document.createElement("span");
          icon.className = "tree-icon";
          icon.innerHTML =
            item.type === "folder"
              ? '<i class="fas fa-folder folder-icon"></i>'
              : '<i class="fas fa-file-medical file-icon"></i>';
          content.appendChild(icon);

          // === Name ===
          const name = document.createElement("span");
          name.className = "tree-item-name";
          name.textContent = item.name || "Unnamed";
          content.appendChild(name);

          // === File size (for files only) ===
          if (item.type === "file" && item.size) {
            const info = document.createElement("span");
            info.className = "tree-item-info";
            info.textContent = this.formatFileSize(item.size);
            content.appendChild(info);
          }

          // === Selection checkbox (for ALL items - files and folders) ===
          const checkbox = document.createElement("div");
          checkbox.className = "selection-checkbox";
          content.appendChild(checkbox);

          // === Tooltip with full filename ===
          const tooltip = document.createElement("div");
          tooltip.className = "tree-item-tooltip";
          tooltip.textContent = item.name || "";

          // === Assemble final node ===
          treeItem.appendChild(content);
          treeItem.appendChild(tooltip);
          li.appendChild(treeItem);

          // If folder, recursively add children (not shown here, handled in renderItems)
          return li;
        }

        async handleItemClick(item, element) {
          if (this.isLoading) return;

          // If in selection mode, don't handle normal item clicking
          if (isSelectionMode) {
            return;
          }

          // Clear previous selection (only in normal mode)
          document.querySelectorAll(".tree-item.selected").forEach((el) => {
            el.classList.remove("selected");
          });

          // Select current item
          element.classList.add("selected");
          this.selectedItem = item;

          if (item.type === "folder") {
            await this.drillIntoFolder(item);
          } else {
            console.log("File selected:", item.path);
            selectedFilePath = item.path;
          }
        }

        async drillIntoFolder(folder) {
          try {
            // Show loading state
            this.showLoading();

            // Update path
            this.currentPath.push(folder.name);

            // Load folder contents (simulate API call or use cached children)
            let folderContents;
            if (folder.children && folder.children.length > 0) {
              folderContents = folder.children;
            } else {
              // In a real implementation, you might make an API call here
              // For now, we'll use the children if available
              folderContents = folder.children || [];
            }

            this.currentData = folderContents;
            this.renderCurrentLevel();
            this.hideLoading();

            console.log(`Drilled into folder: ${this.currentPath.join("/")}`);
          } catch (error) {
            console.error("Error drilling into folder:", error);
            this.showError(`Failed to load folder contents: ${error.message}`);
            // Revert path on error
            this.currentPath.pop();
          }
        }

        goBack() {
          if (this.currentPath.length === 0) return;

          this.currentPath.pop();

          if (this.currentPath.length === 0) {
            // Back to root
            this.currentData = this.rootData;
          } else {
            // Navigate to parent folder
            this.currentData = this.findFolderByPath(this.currentPath);
          }

          this.renderCurrentLevel();
          console.log(
            `Navigated back to: ${this.currentPath.join("/") || "root"}`,
          );
        }

        findFolderByPath(path) {
          let current = this.rootData;

          for (const segment of path) {
            const folder = current.find(
              (item) => item.name === segment && item.type === "folder",
            );
            if (folder && folder.children) {
              current = folder.children;
            } else {
              console.warn("Could not find path:", path);
              return this.rootData;
            }
          }

          return current;
        }

        handleFileRightClick(e, item, element) {
          e.preventDefault();
          e.stopPropagation();

          console.log("Right-click detected on file:", item.path);
          selectedFilePath = item.path;
          this.selectedItem = item;

          // Clear previous selection and select this item
          document.querySelectorAll(".tree-item.selected").forEach((el) => {
            el.classList.remove("selected");
          });
          element.classList.add("selected");

          showContextMenu(e, item);
        }

        formatFileSize(bytes) {
          if (bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i]
          );
        }

        // Search functionality
        search(query) {
          if (!query.trim()) {
            this.renderCurrentLevel();
            return;
          }

          const filteredItems = this.currentData.filter((item) =>
            item.name.toLowerCase().includes(query.toLowerCase()),
          );

          const container = document.getElementById("fileTreeContainer");

          if (filteredItems.length === 0) {
            container.innerHTML =
              '<div class="tree-empty">No matching files found</div>';
            return;
          }

          // Apply sorting to filtered results
          const sortedFilteredItems = sortTreeStructure([...filteredItems]);

          const treeList = document.createElement("ul");
          treeList.className = "file-tree";

          sortedFilteredItems.forEach((item) => {
            const listItem = this.createTreeItem(item);
            treeList.appendChild(listItem);
          });

          container.innerHTML = "";
          container.appendChild(treeList);
        }
      }

      // Global tree search
      function searchS3Tree(query, tree, path = []) {
        const results = [];

        tree.forEach((node) => {
          const fullPath = [...path, node.name];
          if (node.name.toLowerCase().includes(query)) {
            results.push({ ...node, fullPath: fullPath.join("/") });
          }

          if (node.type === "folder" && node.children?.length > 0) {
            results.push(...searchS3Tree(query, node.children, fullPath));
          }
        });

        return results;
      }

      // Initialize the browser
      let s3Browser = new S3TreeBrowser();

      // Selection mode variables
      let isSelectionMode = false;
      let selectedFiles = new Set();
      let cachedFiles = new Map();

      // Load cached files from localStorage
      try {
        const stored = localStorage.getItem('s3CachedFiles');
        if (stored) {
          cachedFiles = new Map(JSON.parse(stored));
        }
      } catch (e) {
        console.error('Error loading cached files:', e);
      }

      function toggleSelectionMode() {
        isSelectionMode = !isSelectionMode;
        selectedFiles.clear();
        
        const selectBtn = document.getElementById('selectModeBtn');
        const saveBtn = document.getElementById('saveToCache');
        const cancelBtn = document.getElementById('cancelSelection');
        
        if (isSelectionMode) {
          selectBtn.innerHTML = '<i class="fas fa-check-square"></i> Selecting...';
          selectBtn.style.backgroundColor = '#ffc107';
          selectBtn.style.color = '#000';
          saveBtn.style.display = 'none';
          cancelBtn.style.display = 'flex';
          
          // Add selection capability to all items
          addSelectionCheckboxes();
          console.log('Selection mode enabled');
        } else {
          cancelSelectionMode();
        }
      }

      function cancelSelectionMode() {
        isSelectionMode = false;
        selectedFiles.clear();
        
        const selectBtn = document.getElementById('selectModeBtn');
        const saveBtn = document.getElementById('saveToCache');
        const cancelBtn = document.getElementById('cancelSelection');
        
        selectBtn.innerHTML = '<i class="fas fa-check-square"></i> Select';
        selectBtn.style.backgroundColor = '#007bff';
        selectBtn.style.color = 'white';
        saveBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        
        // Remove selection styles and checkboxes
        removeSelectionCheckboxes();
        console.log('Selection mode cancelled');
      }

      function addSelectionCheckboxes() {
        // Add selection capability to ALL tree items (files AND folders)
        const allItems = document.querySelectorAll('.tree-item');
        allItems.forEach(item => {
          item.classList.add('file-item-selectable');

          // Show existing checkbox or create one
          let checkbox = item.querySelector('.selection-checkbox');
          if (!checkbox) {
            checkbox = document.createElement('div');
            checkbox.className = 'selection-checkbox';
            const content = item.querySelector('.tree-item-content');
            if (content) {
              content.appendChild(checkbox);
            }
          }
          checkbox.classList.add('visible');

          // Check if this is an E2E file and disable it
          const itemPath = item.dataset.fullPath;
          if (itemPath && itemPath.toLowerCase().endsWith('.e2e')) {
            checkbox.classList.add('disabled');
            checkbox.title = 'E2E files are cached when loaded, not pre-cached';
            checkbox.style.opacity = '0.5';
            checkbox.style.cursor = 'not-allowed';
          } else {
            checkbox.classList.remove('disabled');
            checkbox.title = '';
            checkbox.style.opacity = '1';
            checkbox.style.cursor = 'pointer';
          }

          // Remove any previous handler to avoid duplicates
          checkbox.onclick = null;
          checkbox.addEventListener('click', handleFileSelection);

          // Prevent the row itself from handling selection in selection mode
          // (let it only handle navigation/expand)
          // Remove any previous click handler for selection mode
          if (item._selectionHandlerAdded) {
            item.removeEventListener('click', handleFileSelection);
            item._selectionHandlerAdded = false;
          }
        });
      }

      function removeSelectionCheckboxes() {
        const allItems = document.querySelectorAll('.file-item-selectable');
        allItems.forEach(item => {
          item.classList.remove('file-item-selectable', 'selected');
          const checkbox = item.querySelector('.selection-checkbox');
          if (checkbox) {
            checkbox.classList.remove('visible', 'checked');
          }
          // Remove only the selection handler
          if (item._selectionHandlerAdded) {
            item.removeEventListener('click', handleFileSelection);
            item._selectionHandlerAdded = false;
          }
        });
      }
      //file handelling-- for s3 bucket 

      function handleFileSelection(event) {
        if (!isSelectionMode) return;

        event.stopPropagation();
        event.preventDefault();

        // The checkbox is the event target, get its parent .tree-item
        const checkbox = event.currentTarget;
        
        // Prevent selection of disabled E2E files
        if (checkbox.classList.contains('disabled')) {
          return;
        }
        
        const treeItem = checkbox.closest('.tree-item');
        const itemPath = treeItem.dataset.fullPath;

        if (!itemPath) {
          console.warn('No full path found for item');
          return;
        }

        if (selectedFiles.has(itemPath)) {
          selectedFiles.delete(itemPath);
          treeItem.classList.remove('selected');
          checkbox.classList.remove('checked');
        } else {
          selectedFiles.add(itemPath);
          treeItem.classList.add('selected');
          checkbox.classList.add('checked');
        }

        // Update save button state
        const saveBtn = document.getElementById('saveToCache');
        if (saveBtn) {
          saveBtn.style.display = selectedFiles.size > 0 ? 'flex' : 'none';
          saveBtn.innerHTML = `<i class="fas fa-save"></i> Save to Cache (${selectedFiles.size})`;
        }

        console.log(`Selected items: ${selectedFiles.size}`, [...selectedFiles]);
      }

      // Save selected files to cache and store CRCs with real-time progress
      async function saveSelectedToCache() {
        if (selectedFiles.size === 0) {
          showNotification('Please select files to cache', 'warning');
          return;
        }

        const filePaths = Array.from(selectedFiles);
        const saveBtn = document.getElementById('saveToCache');

        // Show progress popup with streaming support
        showCacheProgressPopup(filePaths.length, true);

        try {
          // Send the file list to start processing with streaming
          const response = await fetch('/api/save-to-cache-stream', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
              files: filePaths
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          // Handle streaming response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  handleCacheProgressUpdate(data);
                } catch (e) {
                  console.error('Error parsing progress data:', e);
                }
              }
            }
          }

          console.log('Caching operation completed');

          // After caching, user must explicitly select a file to view in a viewport.

        } catch (e) {
          hideCacheProgressPopup();
          showNotification('Error saving to cache: ' + e.message, 'error');
        }
      }

      // Handle real-time progress updates from SSE
      function handleCacheProgressUpdate(data) {
        console.log('Progress update:', data);
        
        switch (data.type) {
          case 'progress':
            updateOverallProgress(data.percentage, data.completed, data.total);
            break;
          case 'file_start':
            updateCurrentFile(data.file, data.index, data.total);
            break;
          case 'download_start':
            updateDownloadStatus(data.file, data.message);
            break;
          case 'download_progress':
            updateDownloadProgress(data.file, data.progress, data.downloaded, data.total);
            break;
          case 'download_complete':
            updateDownloadComplete(data.file, data.message);
            break;
          case 'processing_start':
            updateProcessingStatus(data.file, data.message);
            break;
          case 'crc_calculated':
            updateCRCStatus(data.file, data.crc);
            break;
          case 'processing':
            updateProcessingStatus(data.file, data.message);
            break;
          case 'file_complete':
            updateFileComplete(data.file, data.status, data.crc);
            if (data.crc) {
              fileCRCs[data.file] = data.crc;
            }
            break;
          case 'file_error':
            updateFileError(data.file, data.error);
            // Show backend error message in a notification for the user
            showNotification(`Error caching file: ${data.file}\n${data.error}`, 'error');
            break;
          case 'skipped':
            updateFileSkipped(data.file, data.message);
            break;
          case 'complete':
            handleCachingComplete(data.total, data.completed);
            break;
        }
      }

      // Progress popup functions with enhanced real-time updates
      function showCacheProgressPopup(totalFiles, streaming = false) {
        // Remove existing popup if any
        const existingPopup = document.getElementById('cacheProgressPopup');
        if (existingPopup) {
          existingPopup.remove();
        }

        const popup = document.createElement('div');
        popup.id = 'cacheProgressPopup';
        popup.innerHTML = `
          <div class="cache-progress-overlay">
            <div class="cache-progress-modal">
              <div class="cache-progress-header">
                <h3><i class="fas fa-cloud-download-alt"></i> Caching Files</h3>
                <button class="cache-progress-close" onclick="hideCacheProgressPopup()">×</button>
              </div>
              <div class="cache-progress-content">
                <div class="cache-progress-bar">
                  <div class="cache-progress-fill" id="cacheProgressFill"></div>
                </div>
                <div class="cache-progress-text" id="cacheProgressText">Preparing to cache ${totalFiles} files...</div>
                
                <!-- Current file progress -->
                <div class="current-file-section" id="currentFileSection" style="display: none;">
                  <div class="current-file-header">
                    <h4 id="currentFileName">Current File</h4>
                    <span id="currentFileStatus" class="file-status">Preparing...</span>
                  </div>
                  <div class="current-file-progress-bar">
                    <div class="current-file-progress-fill" id="currentFileProgressFill"></div>
                  </div>
                  <div class="current-file-details" id="currentFileDetails"></div>
                </div>
                
                <div class="cache-progress-stats" id="cacheProgressStats">
                  <div class="stat-item">
                    <span class="stat-label">Total:</span>
                    <span class="stat-value">${totalFiles}</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Cached:</span>
                    <span class="stat-value" id="cachedCount">0</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Skipped:</span>
                    <span class="stat-value" id="skippedCount">0</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Failed:</span>
                    <span class="stat-value" id="failedCount">0</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(popup);
      }

      function updateOverallProgress(percentage, completed, total) {
        const progressFill = document.getElementById('cacheProgressFill');
        const progressText = document.getElementById('cacheProgressText');
        
        if (progressFill) {
          progressFill.style.width = `${percentage}%`;
        }
        
        if (progressText) {
          progressText.textContent = `Overall Progress: ${Math.round(percentage)}% (${completed}/${total})`;
        }
      }

      function updateCurrentFile(file, index, total) {
        const currentFileSection = document.getElementById('currentFileSection');
        const currentFileName = document.getElementById('currentFileName');
        const currentFileStatus = document.getElementById('currentFileStatus');
        
        if (currentFileSection) {
          currentFileSection.style.display = 'block';
        }
        
        if (currentFileName) {
          const fileName = file.split('/').pop();
          currentFileName.textContent = `File ${index}/${total}: ${fileName}`;
        }
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Starting...';
          currentFileStatus.className = 'file-status preparing';
        }
      }

      function updateDownloadStatus(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Downloading...';
          currentFileStatus.className = 'file-status downloading';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
      }

      function updateDownloadProgress(file, progress, downloaded, total) {
        const currentFileProgressFill = document.getElementById('currentFileProgressFill');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileProgressFill) {
          currentFileProgressFill.style.width = `${progress}%`;
        }
        
        if (currentFileDetails) {
          const downloadedMB = (downloaded / (1024 * 1024)).toFixed(2);
          const totalMB = (total / (1024 * 1024)).toFixed(2);
          currentFileDetails.textContent = `Downloading: ${downloadedMB}MB / ${totalMB}MB (${Math.round(progress)}%)`;
        }
      }

      function updateDownloadComplete(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Processing...';
          currentFileStatus.className = 'file-status processing';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
      }

      function updateProcessingStatus(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Processing...';
          currentFileStatus.className = 'file-status processing';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
      }

      function updateCRCStatus(file, crc) {
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileDetails) {
          currentFileDetails.textContent = `CRC calculated: ${crc}`;
        }
      }

      function updateFileComplete(file, status, crc) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        const cachedCount = document.getElementById('cachedCount');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Complete';
          currentFileStatus.className = 'file-status complete';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = `Successfully cached (CRC: ${crc})`;
        }
        
        if (cachedCount) {
          const current = parseInt(cachedCount.textContent) || 0;
          cachedCount.textContent = current + 1;
        }
      }

      function updateFileError(file, error) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        const failedCount = document.getElementById('failedCount');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Failed';
          currentFileStatus.className = 'file-status failed';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = `Error: ${error}`;
        }
        
        if (failedCount) {
          const current = parseInt(failedCount.textContent) || 0;
          failedCount.textContent = current + 1;
        }
      }

      function updateFileSkipped(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        const skippedCount = document.getElementById('skippedCount');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Skipped';
          currentFileStatus.className = 'file-status skipped';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
        
        if (skippedCount) {
          const current = parseInt(skippedCount.textContent) || 0;
          skippedCount.textContent = current + 1;
        }
      }

      function handleCachingComplete(total, completed) {
        const progressText = document.getElementById('cacheProgressText');
        const currentFileSection = document.getElementById('currentFileSection');
        
        if (progressText) {
          progressText.textContent = 'Caching complete!';
        }
        
        if (currentFileSection) {
          currentFileSection.style.display = 'none';
        }
        
        // Update save button
          const saveBtn = document.getElementById('saveToCache');
        if (saveBtn) {
          saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved!';
          saveBtn.style.backgroundColor = '#28a745';
          setTimeout(() => {
            saveBtn.innerHTML = `<i class="fas fa-save"></i> Save to Cache`;
            saveBtn.style.backgroundColor = '#28a745';
          }, 2000);
        }

        // Clear selection
          selectedFiles.clear();
          removeSelectionCheckboxes();
          addSelectionCheckboxes();
        if (saveBtn) {
          saveBtn.style.display = 'none';
        }
        
        // Auto-hide popup after completion and navigate to viewport
        setTimeout(() => {
          hideCacheProgressPopup();
          
          // Navigate to viewport mode and load the first cached file
          navigateToViewportAndLoadFirstFile();
        }, 3000);
      }
      
      // Function to navigate to viewport and load the first cached file
      async function navigateToViewportAndLoadFirstFile() {
        try {
          // Get the first cached file from the fileCRCs object
          const cachedFiles = Object.keys(fileCRCs);
          if (cachedFiles.length === 0) {
            showNotification('No cached files found to display', 'warning');
            return;
          }
          
          const firstCachedFile = cachedFiles[0];
          console.log(`Navigating to viewport and loading first cached file: ${firstCachedFile}`);
          
          // Show viewport mode
          showViewportMode();
          
          // Load the first cached file into viewport 1
          selectedFilePath = firstCachedFile;
          await loadIntoViewport(1);
          
          showNotification(`Loaded ${firstCachedFile.split('/').pop()} into viewport`, 'success');
          
        } catch (error) {
          console.error('Error navigating to viewport:', error);
          showNotification(`Error loading cached file: ${error.message}`, 'error');
        }
      }
      
      // Function to show viewport mode
      function showViewportMode() {
        // Hide file browser
        const fileBrowserContainer = document.querySelector('.file-browser-container');
        if (fileBrowserContainer) {
          fileBrowserContainer.style.display = 'none';
        }
        
        // Show viewports container
        const viewportsContainer = document.getElementById('viewportsContainer');
        if (viewportsContainer) {
          viewportsContainer.style.display = 'flex';
          viewportsContainer.style.flexDirection = 'row';
          viewportsContainer.style.gap = '20px';
        }
        
        // Show both viewports
        const viewport1 = document.getElementById('viewport1');
        const viewport2 = document.getElementById('viewport2');
        
        if (viewport1) {
          viewport1.style.display = 'flex';
          viewport1.style.border = '2px solid #ccc';
          viewport1.style.width = '';
          viewport1.style.flex = '1';
        }
        
        if (viewport2) {
          viewport2.style.display = 'flex';
          viewport2.style.border = '2px solid #ccc';
          viewport2.style.width = '';
          viewport2.style.flex = '1';
        }
        
        console.log('Switched to viewport mode');
      }

      function hideCacheProgressPopup() {
        const popup = document.getElementById('cacheProgressPopup');
        if (popup) {
          popup.remove();
        }
      }

      // Notification system to replace alerts
      function showNotification(message, type = 'info', duration = 5000) {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.notification');
        existingNotifications.forEach(notification => notification.remove());

        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
          <div class="notification-content">
            <span class="notification-message">${message}</span>
            <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
          </div>
        `;

        // Add styles if not already present
        if (!document.getElementById('notification-styles')) {
          const style = document.createElement('style');
          style.id = 'notification-styles';
          style.textContent = `
            .notification {
              position: fixed;
              top: 20px;
              right: 20px;
              z-index: 10000;
              max-width: 400px;
              border-radius: 8px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
              animation: slideIn 0.3s ease-out;
            }
            .notification-info {
              background: #e3f2fd;
              border: 1px solid #2196f3;
              color: #1976d2;
            }
            .notification-warning {
              background: #fff3e0;
              border: 1px solid #ff9800;
              color: #f57c00;
            }
            .notification-error {
              background: #ffebee;
              border: 1px solid #f44336;
              color: #d32f2f;
            }
            .notification-success {
              background: #e8f5e8;
              border: 1px solid #4caf50;
              color: #388e3c;
            }
            .notification-content {
              padding: 12px 16px;
              display: flex;
              align-items: center;
              justify-content: space-between;
            }
            .notification-message {
              flex: 1;
              margin-right: 8px;
            }
            .notification-close {
              background: none;
              border: none;
              font-size: 18px;
              cursor: pointer;
              color: inherit;
              opacity: 0.7;
            }
            .notification-close:hover {
              opacity: 1;
            }
            @keyframes slideIn {
              from { transform: translateX(100%); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
            }
          `;
          document.head.appendChild(style);
        }

        document.body.appendChild(notification);

        // Auto-remove after duration
        setTimeout(() => {
          if (notification.parentElement) {
            notification.remove();
          }
        }, duration);
      }

      function reviewCachedFiles() {
        const cached = [...cachedFiles.entries()];
        console.log('Cached items:', cached);
        
        // Display cached items in a more user-friendly way
        const cacheDisplay = cached.map(([path, data]) => ({
          path: path,
          type: data.type,
          cachedAt: new Date(data.cachedAt).toLocaleString()
        }));
        
        console.table(cacheDisplay);
        return cached;
      }

      // Show selection controls when S3 browser is loaded
      document.addEventListener('DOMContentLoaded', () => {
        const controls = document.querySelector('.s3-selection-controls');
        if (controls) {
          controls.style.display = 'flex';
          document.getElementById('selectModeBtn').style.display = 'block';
        }
      });

      // Update search event listener
      function runTreeSearch() {
        const query = document
          .getElementById("treeSearchInput")
          .value.toLowerCase()
          .trim();
        const extension = document.getElementById("extensionFilter").value;

        if (!query && !extension) {
          s3Browser.renderCurrentLevel(); // Show default tree
          return;
        }

        let results = searchS3Tree(query, s3Browser.rootData || []);

        if (extension) {
          results = results.filter(
            (item) =>
              item.type === "file" &&
              item.name.toLowerCase().endsWith(extension),
          );
        }

        s3Browser.renderSearchResults(results);
      }

      document
        .getElementById("treeSearchInput")
        .addEventListener("input", runTreeSearch);
      document
        .getElementById("extensionFilter")
        .addEventListener("change", runTreeSearch);

      // Replace the existing loadS3Tree function with:
      async function loadS3Tree() {
        s3Browser.showLoading();
        try {
          // Always use the fastest method
          const response = await fetch("/api/s3-fast-list?use_parallel=true&auto_prefixes=true&max_workers=10");
          const data = await response.json();

          // Handle the new response format
          let files = [];
          if (data.files && Array.isArray(data.files)) {
            files = data.files;
          } else if (Array.isArray(data)) {
            // Fallback for old format
            files = data;
          } else {
            throw new Error("Invalid S3 response format");
          }

          // Log performance metrics
          if (data.duration_seconds) {
            console.log(`S3 listing completed in ${data.duration_seconds.toFixed(2)}s`);
            console.log(`Speed: ${data.files_per_second?.toFixed(1) || 'N/A'} files/second`);
            console.log(`Method: ${data.method || 'unknown'}`);
          }

          // Convert flat list to tree with sorting
          const treeData = s3Browser.buildTreeFromFlatList(files);
          s3Browser.rootData = treeData;
          s3Browser.currentData = treeData;
          s3Browser.currentPath = [];
          s3Browser.renderCurrentLevel();
          s3Browser.hideLoading();
        } catch (err) {
          console.error("Failed to load S3 list:", err);
          s3Browser.showError("Failed to load S3 file list. " + err.message);
        }
      }



      // Initialize on page load
      document.addEventListener("DOMContentLoaded", () => {
        // Initialize zoom displays
        updateZoomDisplay(1);
        updateZoomDisplay(2);

        // Initialize DICOM viewport layout (default to stacked)
        const dicomContainer = document.getElementById(
          "dicomViewportsContainer",
        );
        if (dicomContainer) {
          dicomContainer.classList.add("stacked");
        }

        // Initialize S3 viewport layout (default to side-by-side)
        const s3Container = document.getElementById("viewportsContainer");
        if (s3Container) {
          s3Container.classList.remove("stacked");
        }

        // Initialize S3 status indicator
        updateS3StatusIndicator('checking', 'Initializing...');
        
        // Check S3 status after a short delay
        setTimeout(() => {
          checkS3Status();
        }, 500);

        console.log("Application initialized with layout controls and sorting");
      });

      // Original functions for DICOM upload (keeping for compatibility)
      const crcTable = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
          c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
        }
        crcTable[i] = c;
      }

      // Calculate CRC32 from string (for frontend use)
      function calculateCRC32FromString(str) {
        let crc = 0 ^ -1;
        const bytes = new TextEncoder().encode(str);
        for (let i = 0; i < bytes.length; i++) {
          crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xff];
        }
        return ((crc ^ -1) >>> 0).toString(16).padStart(8, "0");
      }

      async function calculateFileCRC32(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            const buffer = e.target.result;
            const array = new Uint8Array(buffer);
            let crc = 0 ^ -1;
            for (let i = 0; i < array.length; i++) {
              crc = (crc >>> 8) ^ crcTable[(crc ^ array[i]) & 0xff];
            }
            const crcValue = ((crc ^ -1) >>> 0).toString(16).padStart(8, "0");
            resolve(crcValue);
          };
          reader.onerror = reject;
          reader.readAsArrayBuffer(file);
        });
      }

      async function uploadDICOM(viewportNumber) {
        const fileInput = document.getElementById(
          "dicomFile" + viewportNumber + "_s3",
        );
        if (fileInput.files.length === 0) return;

        const file = fileInput.files[0];
        console.log(
          "Uploading DICOM file:",
          file.name,
          "to viewport:",
          viewportNumber,
        );
      }

      // Toolbar functionality
      document
        .getElementById("e2eToDicomConverter")
        .addEventListener("click", async function () {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".e2e";
          fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            console.log("Converting E2E file:", file.name);
          };
          fileInput.click();
        });

      document
        .getElementById("dicomMetadataExtractorTool")
        .addEventListener("click", async function () {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".dcm";
          fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            console.log("Extracting metadata from:", file.name);
          };
          fileInput.click();
        });

      // S3 Credentials Management
      async function checkS3Status() {
        // Update status indicator to checking
        updateS3StatusIndicator('checking', 'Checking connection...');

        if (s3StatusChecked && s3ConfiguredStatus !== null) {
          if (
            !s3ConfiguredStatus.configured &&
            s3ConfiguredStatus.needs_credentials
          ) {
            updateS3StatusIndicator('disconnected', 'Not configured');
            showS3CredentialsModal();
            return false;
          }
          updateS3StatusIndicator('connected', 'Connected');
          return true;
        }

        try {
          const response = await fetch("/api/s3-status");
          const status = await response.json();

          s3StatusChecked = true;
          s3ConfiguredStatus = status;

          if (!status.configured && status.needs_credentials) {
            updateS3StatusIndicator('disconnected', 'Not configured');
            showS3CredentialsModal();
            return false;
          }
          
          updateS3StatusIndicator('connected', `Connected to ${status.bucket}`);
          return true;
        } catch (error) {
          console.error("Error checking S3 status:", error);
          s3StatusChecked = true;
          s3ConfiguredStatus = { configured: false, needs_credentials: true };
          updateS3StatusIndicator('disconnected', 'Connection error');
          showS3CredentialsModal();
          return false;
        }
      }

      function updateS3StatusIndicator(status, text) {
        const statusDot = document.getElementById('s3StatusDot');
        const statusText = document.getElementById('s3StatusText');
        
        if (statusDot && statusText) {
          // Remove all status classes
          statusDot.className = 'status-dot';
          statusText.className = 'status-text';
          
          // Add appropriate classes
          statusDot.classList.add(status);
          statusText.classList.add(status);
          statusText.textContent = text;
        }
      }

      async function refreshS3Status() {
        const refreshBtn = document.querySelector('.status-refresh-btn');
        if (refreshBtn) {
          refreshBtn.classList.add('spinning');
        }
        
        // Reset status cache to force a fresh check
        s3StatusChecked = false;
        s3ConfiguredStatus = null;
        
        try {
          await checkS3Status();
        } finally {
          if (refreshBtn) {
            refreshBtn.classList.remove('spinning');
          }
        }
      }

      function showS3CredentialsModal() {
        document.getElementById("s3CredentialsModal").style.display = "flex";
        document.getElementById("s3ErrorMessage").style.display = "none";
        document.getElementById("s3SuccessMessage").style.display = "none";
      }

      function closeS3Modal() {
        document.getElementById("s3CredentialsModal").style.display = "none";
      }

      async function submitS3Credentials() {
        const accessKey = document.getElementById("s3AccessKey").value.trim();
        const secretKey = document.getElementById("s3SecretKey").value.trim();
        const region = document.getElementById("s3Region").value;
        const bucket = document.getElementById("s3Bucket").value.trim();
        const saveToEnv = document.getElementById("s3SaveToEnv").checked;

        // Enhanced validation
        if (!accessKey || !secretKey || !region || !bucket) {
          showS3Error("Please fill in all fields.");
          return;
        }

        // Validate access key format
        if (!accessKey.startsWith('AKIA') && accessKey.length !== 20) {
          showS3Error("Invalid Access Key ID format. Should start with 'AKIA' and be 20 characters long.");
          return;
        }

        // Validate secret key length
        if (secretKey.length < 40) {
          showS3Error("Invalid Secret Access Key. Should be at least 40 characters long.");
          return;
        }

        // Validate bucket name
        if (bucket.length < 3 || bucket.length > 63) {
          showS3Error("Invalid bucket name. Must be between 3 and 63 characters long.");
          return;
        }

        // Show loading state
        document.getElementById("s3FormContent").style.display = "none";
        document.getElementById("s3LoadingState").style.display = "block";
        document.getElementById("s3ErrorMessage").style.display = "none";
        document.getElementById("s3SuccessMessage").style.display = "none";

        try {
          console.log("Submitting S3 credentials...");
          const response = await fetch("/api/set-s3-credentials", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              accessKey: accessKey,
              secretKey: secretKey,
              region: region,
              bucket: bucket,
              saveToEnv: saveToEnv,
            }),
          });

          const result = await response.json();
          console.log("S3 credentials response:", result);

          if (response.ok) {
            const successMessage = result.message + 
              (result.saved_to_env ? " Credentials saved to .env file." : " Credentials set for this session only.");
            
            showS3Success(successMessage);

            // Reset status cache
            s3StatusChecked = false;
            s3ConfiguredStatus = null;
            s3TreeData = null;

            // Update status indicator
            updateS3StatusIndicator('connected', `Connected to ${bucket}`);

            // Close modal and reload tree after delay
            setTimeout(() => {
              closeS3Modal();
              loadS3Tree();
            }, 2000);
          } else {
            // Handle different types of errors
            let errorMessage = "Failed to set credentials";
            if (result.detail) {
              errorMessage = result.detail;
            } else if (result.error) {
              errorMessage = result.error;
            }
            
            // Provide more helpful error messages
            if (errorMessage.includes("Invalid credentials")) {
              errorMessage = "Invalid AWS credentials. Please check your Access Key ID and Secret Access Key.";
            } else if (errorMessage.includes("bucket")) {
              errorMessage = "Bucket not found or not accessible. Please check the bucket name and your permissions.";
            } else if (errorMessage.includes("region")) {
              errorMessage = "Invalid region. Please select the correct AWS region for your bucket.";
            }
            
            throw new Error(errorMessage);
          }
        } catch (error) {
          console.error("Error setting S3 credentials:", error);
          
          // Handle network errors
          if (error.name === 'TypeError' && error.message.includes('fetch')) {
            showS3Error("Network error. Please check your connection and try again.");
          } else {
            showS3Error("Error: " + error.message);
          }
        } finally {
          document.getElementById("s3LoadingState").style.display = "none";
          document.getElementById("s3FormContent").style.display = "block";
        }
      }

      function showS3Error(message) {
        const errorDiv = document.getElementById("s3ErrorMessage");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        document.getElementById("s3SuccessMessage").style.display = "none";
      }

      function showS3Success(message) {
        const successDiv = document.getElementById("s3SuccessMessage");
        successDiv.textContent = message;
        successDiv.style.display = "block";
        document.getElementById("s3ErrorMessage").style.display = "none";
      }

      // Add responsive resize handler
      window.addEventListener("resize", () => {
        // Recalculate constraints for both viewports
        for (let viewportNumber of [1, 2]) {
          if (viewportData[viewportNumber]) {
            updateImageTransform(viewportNumber);
          }
        }
      });

      // Show context menu
      function showContextMenu(event, filePath) {
        // Prevent the default browser context menu
        event.preventDefault();

        // Set the selected file path for menu actions
        selectedFilePath = filePath;

        const contextMenu = document.getElementById("contextMenu");
        const loadE2EOption = document.getElementById("loadE2EOption");
        const viewport1Option = document.getElementById("viewport1Option");
        const viewport2Option = document.getElementById("viewport2Option");
        if (!contextMenu) return;

        // Show/hide options based on file extension
        const isE2EFile = filePath && filePath.toLowerCase().endsWith(".e2e");
        
        if (loadE2EOption) {
          loadE2EOption.style.display = isE2EFile ? "block" : "none";
        }
        
        if (viewport1Option) {
          viewport1Option.style.display = isE2EFile ? "none" : "block";
        }
        
        if (viewport2Option) {
          viewport2Option.style.display = isE2EFile ? "none" : "block";
        }

        // Make the menu visible to measure its dimensions
        contextMenu.style.display = "block";
        const menuWidth = contextMenu.offsetWidth;
        const menuHeight = contextMenu.offsetHeight;

        const pageWidth = window.innerWidth;
        const pageHeight = window.innerHeight;

        // Get cursor position from the event object
        let x = event.pageX;
        let y = event.pageY;

        // Adjust position if the menu would go off-screen
        if (x + menuWidth > pageWidth) {
          x = pageWidth - menuWidth - 10; // Add a small margin
        }
        if (y + menuHeight > pageHeight) {
          y = pageHeight - menuHeight - 10; // Add a small margin
        }

        // Apply the calculated position
        contextMenu.style.left = `${x}px`;
        contextMenu.style.top = `${y}px`;
      }

      document
        .getElementById("fileTreeContainer")
        .addEventListener("contextmenu", (e) => {
          // Find the nearest .tree-item element
          const treeItem = e.target.closest(".tree-item");

          // Ensure it's a file item with a path
          if (!treeItem || !treeItem.dataset.filePath) {
            return;
          }

          // Get the file path from the data attribute
          const filePath = treeItem.dataset.filePath;

          // Call our standardized function to show the menu
          showContextMenu(e, filePath);

          // Optional: Highlight the selected item
          document
            .querySelectorAll(".tree-item.selected")
            .forEach((el) => el.classList.remove("selected"));
          if (treeItem.parentElement.matches("li.tree-item")) {
            // check if it's the li or the div inside it
            treeItem.parentElement.classList.add("selected");
          } else {
            treeItem.classList.add("selected");
          }
        });

      // Hide context menu on click outside
      document.addEventListener("click", (e) => {
        const menu = document.getElementById("contextMenu");
        if (!menu) return;
        if (!menu.contains(e.target)) {
          menu.style.display = "none";
        }
      });

      // Load DICOM image into viewport from context menu
        async function loadIntoViewport(viewportNumber) {
            if (!selectedFilePath) {
                        console.error("No file path selected");
        showNotification("Please select a DICOM file first.", "warning");
        return;
            }

            // Clear the viewport before loading new file
            clearViewport(viewportNumber);

            // Show progress bar right away
            showProgress(
                viewportNumber,
                "Preparing to load...",
                { File: selectedFilePath.split("/").pop() }
            );

            document.getElementById("contextMenu").style.display = "none";

            try {
                await loadIntoViewportWithPath(viewportNumber, selectedFilePath);
            } catch (error) {
                console.error("Error in loadIntoViewport:", error);
                showNotification(`Error loading file: ${error.message}`, "error");
                hideProgress(viewportNumber);
            }
     }
      //ensurefilechached 

      async function ensureFileCached(filePath) {
        let crc = fileCRCs[filePath];
        if (!crc) {
          // First check if the file is already cached in the backend
          try {
            const checkResponse = await fetch(`/api/download_dicom_from_s3?path=${encodeURIComponent(filePath)}`);
            if (checkResponse.ok) {
              const checkData = await checkResponse.json();
              if (checkData.cache_source === "memory" || checkData.cache_source === "disk") {
                // File is already cached, get the CRC from the response
                console.log(`File ${filePath} is already cached (${checkData.cache_source})`);
                // Generate a CRC for this file path to store locally
                const pathCRC = calculateCRC32FromString(filePath);
                fileCRCs[filePath] = pathCRC;
                return pathCRC;
              }
            }
          } catch (error) {
            console.warn(`Could not check if file is cached: ${error.message}`);
          }

          // Not cached, so cache it now
          const response = await fetch('/api/save-to-cache', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: [filePath] }),
          });
          const data = await response.json();
          const result = data.results && data.results.find(r => r.file === filePath && r.status === "cached");
          if (result && result.crc) {
            fileCRCs[filePath] = result.crc;
            crc = result.crc;
          } else {
            throw new Error("Failed to cache file for viewing.");
          }
        }
        return crc;
      }

      

      // Enhanced frame loading with CRC caching and cancellation support
      async function loadFrameWithCRC(
        viewportNumber,
        frameNumber,
        abortController = null,
      ) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const data = viewportData[viewportNumber];

        if (!data) {
          console.error("No DICOM data available for viewport", viewportNumber);
          return;
        }

        try {
          console.log(
            `Loading frame ${frameNumber} for viewport ${viewportNumber} with CRC caching`,
          );

          // Check if operation was cancelled
          if (abortController && abortController.signal.aborted) {
            throw new Error("Operation cancelled by user");
          }

          // Create metadata for this specific frame
          const frameMetadata = {
            path: data.s3_key,
            dicomFilePath: data.dicom_file_path,
            frame: frameNumber,
            size: data.size || 0,
            lastModified: data.last_modified || "",
          };
          
          // Debug: Log the dicom_file_path being used
          console.log(`[DEBUG] loadFrameWithCRC - viewport ${viewportNumber}, frame ${frameNumber}`);
          console.log(`[DEBUG] data.dicom_file_path: ${data.dicom_file_path}`);
          console.log(`[DEBUG] data.s3_key: ${data.s3_key}`);
          console.log(`[DEBUG] frameMetadata.dicomFilePath: ${frameMetadata.dicomFilePath}`);

          // Try CRC cache first
          try {
            const cachedResult = await loadImageWithCRC(
              data.s3_key,
              frameMetadata,
            );

            // Check if cancelled after cache check
            if (abortController && abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            img.onload = () => {
              console.log(
                `Frame ${frameNumber} loaded successfully with CRC caching (${cachedResult.source})`,
              );
              img.style.display = "block";
              img.style.maxWidth = "100%";
              img.style.maxHeight = "100%";
              img.style.width = "auto";
              img.style.height = "auto";

              resetZoom(viewportNumber);
              setupImageInteractions(viewportNumber);
              updateFrameInfo(viewportNumber, frameNumber);
            };

            img.onerror = (error) => {
              console.error(
                `Failed to load cached image for frame ${frameNumber}`,
                error
              );
              throw new Error(`Failed to load cached image: ${error.message || 'Unknown error'}`);
            };

            img.src = cachedResult.imageData;
            currentFrames[viewportNumber] = frameNumber;

            console.log(
              `Frame ${frameNumber} loaded from ${cachedResult.source} with CRC: ${cachedResult.cacheKey.substring(0, 8)}`,
            );
            return;
          } catch (cacheError) {
            if (abortController && abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }
            console.warn(
              `CRC cache failed for frame ${frameNumber}: ${cacheError.message}`,
            );
            // Fall back to original method
          }

          // Fallback to original PNG endpoint
          console.log(`[DEBUG] Fallback method - using data.dicom_file_path: ${data.dicom_file_path}`);
          const fetchOptions = abortController
            ? { signal: abortController.signal }
            : {};
          const pngResponse = await fetch(
            `/api/view_dicom_png?frame=${frameNumber}&dicom_file_path=${encodeURIComponent(data.dicom_file_path)}&v=${Date.now()}`,
            fetchOptions,
          );

          if (!pngResponse.ok) {
            throw new Error(`Failed to get PNG: ${pngResponse.statusText}`);
          }

          const pngBlob = await pngResponse.blob();
          const pngUrl = URL.createObjectURL(pngBlob);

          // Check if cancelled after download
          if (abortController && abortController.signal.aborted) {
            throw new Error("Operation cancelled by user");
          }

          // Cache this frame for future use
          try {
            imageCache.set(
              imageCache.generateCacheKey(data.s3_key, frameMetadata),
              pngUrl,
              frameMetadata,
            );
          } catch (cacheSetError) {
            console.warn(
              `Failed to cache frame ${frameNumber}: ${cacheSetError.message}`,
            );
          }

          // Display the image with proper constraints
          img.onload = () => {
            console.log(
              `Image loaded successfully for viewport ${viewportNumber} (fallback method)`,
            );
            img.style.display = "block";
            img.style.maxWidth = "100%";
            img.style.maxHeight = "100%";
            img.style.width = "auto";
            img.style.height = "auto";

            centerImage(viewportNumber);
            setupImageInteractions(viewportNumber);
            updateFrameInfo(viewportNumber, frameNumber);
          };

          img.onerror = (error) => {
            console.error(`Failed to load image for frame ${frameNumber}`, error);
            throw new Error(`Failed to load image: ${error.message || 'Unknown error'}`);
          };

          img.src = pngUrl;
          currentFrames[viewportNumber] = frameNumber;
        } catch (error) {
          console.error("Error loading frame:", error);
          throw error;
        }
      }

      // Load specific frame (updated to use CRC caching)
      async function loadFrame(viewportNumber, frameNumber) {
        return await loadFrameWithCRC(viewportNumber, frameNumber);
      }

      // Debug function to check DICOM file status
      async function checkDicomFileStatus(dicomFilePath) {
        try {
          console.log(`[DEBUG] Checking DICOM file status: ${dicomFilePath}`);
          
          // Check if file is ready
          const readyResponse = await fetch(`/api/check_dicom_ready?dicom_file_path=${encodeURIComponent(dicomFilePath)}`);
          const readyData = await readyResponse.json();
          console.log(`[DEBUG] DICOM ready status:`, readyData);
          
          // Check file info
          const infoResponse = await fetch(`/api/file_info/${encodeURIComponent(dicomFilePath)}`);
          if (infoResponse.ok) {
            const infoData = await infoResponse.json();
            console.log(`[DEBUG] DICOM file info:`, infoData);
          } else {
            console.log(`[DEBUG] Could not get file info: ${infoResponse.status}`);
          }
          
          return readyData;
        } catch (error) {
          console.error(`[DEBUG] Error checking DICOM status:`, error);
          return { ready: false, error: error.message };
        }
      }

      // Function to clear cache and retry loading
      async function clearCacheAndRetry(viewportNumber, filePath) {
        try {
          const fileType = detectFileType(filePath);
          console.log(`[CACHE CLEAR] Clearing cache and retrying for ${filePath} (${fileType})`);
          
          // Clear the image cache
          imageCache.clear();
          
          // Clear file CRCs
          delete fileCRCs[filePath];
          
          // Clear viewport data
          viewportData[viewportNumber] = {};
          
          // For E2E files, also clear the tree data
          if (fileType === 'E2E') {
            console.log(`[CACHE CLEAR] Clearing E2E tree data`);
            // Clear any E2E-specific data
            const leftEyeTree = document.getElementById('leftEyeTree');
            const rightEyeTree = document.getElementById('rightEyeTree');
            if (leftEyeTree) leftEyeTree.innerHTML = '';
            if (rightEyeTree) rightEyeTree.innerHTML = '';
          }
          
          // Retry loading
          await loadIntoViewportWithPath(viewportNumber, filePath);
        } catch (error) {
          console.error(`[CACHE CLEAR] Error during retry:`, error);
          throw error;
        }
      }

      // Function to clear all caches (manual debug function)
      async function clearAllCaches() {
        try {
          console.log(`[CACHE CLEAR] Clearing all caches`);
          
          // Clear the image cache
          imageCache.clear();
          
          // Clear all file CRCs
          Object.keys(fileCRCs).forEach(key => delete fileCRCs[key]);
          
          // Clear all viewport data
          viewportData[1] = {};
          viewportData[2] = {};
          
          // Clear viewport displays
          clearViewport(1);
          clearViewport(2);
          
          // Clear backend cache
          try {
            const response = await fetch('/api/clear-cache', { method: 'POST' });
            if (response.ok) {
              const result = await response.json();
              console.log(`[CACHE CLEAR] Backend cache cleared:`, result);
            } else {
              console.warn(`[CACHE CLEAR] Failed to clear backend cache: ${response.status}`);
            }
          } catch (backendError) {
            console.warn(`[CACHE CLEAR] Backend cache clear failed:`, backendError);
          }
          
          // Show notification
          showNotification("All caches cleared successfully", "success");
          
          console.log(`[CACHE CLEAR] All caches cleared`);
        } catch (error) {
          console.error(`[CACHE CLEAR] Error clearing caches:`, error);
          showNotification("Error clearing caches", "error");
        }
      }

      // Setup frame slider - handle both regular frames and OCT frames
      function setupFrameSlider(viewportNumber) {
        console.log(`Setting up frame slider for viewport ${viewportNumber}`);

        const frameSlider = document.getElementById(
          `frameSlider${viewportNumber}`,
        );
        const frameSliderContainer = document.getElementById(
          `frameSliderContainer${viewportNumber}`,
        );
        const data = viewportData[viewportNumber];

        if (!frameSlider || !frameSliderContainer) {
          console.error(
            "Frame slider elements not found for viewport",
            viewportNumber,
          );
          return;
        }

        // Hide frame slider for flattened OCT images
        if (data && data.isFlattened) {
          frameSliderContainer.classList.remove("active");
          console.log(
            `Frame slider hidden for flattened OCT image in viewport ${viewportNumber}`,
          );
          return;
        }

        // Determine frame count based on mode
        let numFrames;
        let isOctMode = false;
        
        if (data && data.isOctMode && data.octFrameCount > 0) {
          // OCT mode - use original OCT frame count
          numFrames = data.octFrameCount;
          isOctMode = true;
          console.log(`OCT mode detected for viewport ${viewportNumber}, ${numFrames} OCT frames`);
        } else if (data && data.octFrameCount > 0 && isE2EMode) {
          // E2E mode with OCT frames available - use original OCT frame count
          numFrames = data.octFrameCount;
          isOctMode = true;
          console.log(`E2E OCT mode detected for viewport ${viewportNumber}, ${numFrames} original OCT frames`);
        } else {
          // Regular mode - use total frames
          numFrames = totalFrames[viewportNumber];
          console.log(`Regular mode for viewport ${viewportNumber}, ${numFrames} frames`);
        }

        frameSlider.min = 0;
        frameSlider.max = Math.max(0, numFrames - 1);
        
        // Preserve current frame value if it's within the new range, otherwise reset to 0
        const currentValue = parseInt(frameSlider.value) || 0;
        if (currentValue >= 0 && currentValue <= numFrames - 1) {
          frameSlider.value = currentValue;
        } else {
          frameSlider.value = 0;
        }

        frameSlider.onchange = null;
        frameSlider.oninput = null;

        if (numFrames <= 1) {
          frameSlider.disabled = true;
          console.log(
            `Single-frame detected for viewport ${viewportNumber}, slider disabled`,
          );
        } else {
          frameSlider.disabled = false;
          frameSlider.oninput = async (e) => {
            const frameNumber = parseInt(e.target.value);
            console.log(
              `Frame slider changed to ${frameNumber} for viewport ${viewportNumber} (${isOctMode ? 'OCT' : 'regular'} mode)`,
            );
            try {
              if (isOctMode && data && data.dicom_file_path) {
                // OCT mode - load original OCT frame
                const eye = viewportNumber === 1 ? 'left' : 'right';
                await loadOriginalOCTFrame(viewportNumber, frameNumber, data.dicom_file_path, eye);
              } else {
                // Regular mode - load regular frame
                await loadFrame(viewportNumber, frameNumber);
              }
            } catch (error) {
              console.error("Error loading frame from slider:", error);
            }
          };
        }

        frameSliderContainer.classList.add("active");
        updateFrameInfo(viewportNumber, parseInt(frameSlider.value) || 0);

        // Update navigation button states
        updateNavigationButtons(viewportNumber, parseInt(frameSlider.value) || 0, numFrames);

        // Show mode switch controls for E2E files with OCT frames
        const modeSwitchControls = document.getElementById(`modeSwitchControls${viewportNumber}`);
        if (modeSwitchControls && data && data.octFrameCount > 0 && isE2EMode) {
          modeSwitchControls.style.display = "flex";
          
          // Update button states based on current mode
          const regularBtn = modeSwitchControls.querySelector('button[onclick*="switchToRegularMode"]');
          const octBtn = modeSwitchControls.querySelector('button[onclick*="switchToOCTMode"]');
          
          if (regularBtn && octBtn) {
            if (data.isOctMode) {
              regularBtn.classList.remove('active');
              octBtn.classList.add('active');
            } else {
              regularBtn.classList.add('active');
              octBtn.classList.remove('active');
            }
          }
        } else if (modeSwitchControls) {
          modeSwitchControls.style.display = "none";
        }

        console.log(
          `Frame slider setup complete for viewport ${viewportNumber}, ${numFrames} frame(s) (${isOctMode ? 'OCT' : 'regular'} mode)`,
        );
        console.log(`Viewport ${viewportNumber} data:`, data);
        console.log(`Viewport ${viewportNumber} totalFrames:`, totalFrames[viewportNumber]);
      }

      // Update navigation button states
      function updateNavigationButtons(viewportNumber, currentFrame, totalFrames) {
        const prevBtn = document.getElementById(`framePrev${viewportNumber}`);
        const nextBtn = document.getElementById(`frameNext${viewportNumber}`);
        
        if (prevBtn && nextBtn) {
          // Enable/disable buttons based on frame count
          const hasMultipleFrames = totalFrames > 1;
          prevBtn.disabled = !hasMultipleFrames;
          nextBtn.disabled = !hasMultipleFrames;
          
          // Add visual feedback for single frame
          if (!hasMultipleFrames) {
            prevBtn.title = "Single frame - no navigation available";
            nextBtn.title = "Single frame - no navigation available";
          } else {
            prevBtn.title = "Previous Frame (←)";
            nextBtn.title = "Next Frame (→)";
          }
        }
      }

      // Add keyboard navigation support
      document.addEventListener('keydown', function(event) {
        // Only handle navigation if not typing in an input field
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
          return;
        }

        const activeViewport = getActiveViewport();
        if (!activeViewport) return;

        switch(event.key) {
          case 'ArrowLeft':
            event.preventDefault();
            navigateFrame(activeViewport, -1);
            break;
          case 'ArrowRight':
            event.preventDefault();
            navigateFrame(activeViewport, 1);
            break;
        }
      });

      // Get the currently active viewport (viewport with focus or last interacted)
      function getActiveViewport() {
        // Check if any viewport has an image loaded
        const viewport1 = document.getElementById('viewportImage1');
        const viewport2 = document.getElementById('viewportImage2');
        
        if (viewport1 && viewport1.style.display !== 'none' && viewportData[1]) {
          return 1;
        } else if (viewport2 && viewport2.style.display !== 'none' && viewportData[2]) {
          return 2;
        }
        
        return null;
      }

      // Navigate frame using + and - buttons
      async function navigateFrame(viewportNumber, direction) {
        const frameSlider = document.getElementById(`frameSlider${viewportNumber}`);
        const data = viewportData[viewportNumber];
        
        if (!frameSlider || !data) {
          console.error(`No frame slider or data found for viewport ${viewportNumber}`);
          return;
        }

        const currentFrame = parseInt(frameSlider.value);
        const maxFrame = parseInt(frameSlider.max);
        let newFrame = currentFrame + direction;

        console.log(`Navigating frame: current=${currentFrame}, direction=${direction}, new=${newFrame}, max=${maxFrame}`);

        // Handle wrap-around
        if (newFrame < 0) {
          newFrame = maxFrame;
        } else if (newFrame > maxFrame) {
          newFrame = 0;
        }

        console.log(`After wrap-around: newFrame=${newFrame}`);

        // Update slider value
        frameSlider.value = newFrame;

        // Update navigation button states
        updateNavigationButtons(viewportNumber, newFrame, maxFrame + 1);

        // Load the new frame
        try {
          if (data.isOctMode && data.octFrameCount > 0) {
            // OCT mode - load original OCT frame
            const eye = viewportNumber === 1 ? 'left' : 'right';
            console.log(`Loading OCT frame ${newFrame} for ${eye} eye`);
            await loadOriginalOCTFrame(viewportNumber, newFrame, data.dicom_file_path, eye);
          } else {
            // Regular mode - load regular frame
            console.log(`Loading regular frame ${newFrame}`);
            await loadFrame(viewportNumber, newFrame);
          }
        } catch (error) {
          console.error(`Error navigating frame: ${error}`);
        }
      }

      // Update frame info display
      function updateFrameInfo(viewportNumber, frameNumber) {
        const frameInfo = document.getElementById(`frameInfo${viewportNumber}`);
        if (frameInfo) {
          const data = viewportData[viewportNumber];
          let totalFramesCount;
          let modeText = '';
          
          if (data && data.isOctMode && data.octFrameCount > 0) {
            totalFramesCount = data.octFrameCount;
            modeText = ' (OCT)';
          } else {
            totalFramesCount = totalFrames[viewportNumber];
          }
          
          frameInfo.textContent = `Frame ${frameNumber + 1} of ${totalFramesCount}${modeText}`;
        }
      }

      // Enhanced flatten function that caches only the flattened result for OCT images
      async function flattenImageDirectly(viewportNumber) {
        const data = viewportData[viewportNumber];
        if (!data) {
          throw new Error("No DICOM data loaded in this viewport.");
        }

        const img = document.getElementById(`viewportImage${viewportNumber}`);

        try {
          // Generate cache key for flattened OCT image
          const flattenMetadata = {
            path: data.s3_key,
            flattened: true,
            frame: 0,
          };

          const flattenCacheKey = imageCache.generateCacheKey(
            data.s3_key + "_flattened",
            flattenMetadata,
          );

          // Check if flattened version is already cached
          const cachedFlattened = imageCache.get(flattenCacheKey);
          if (cachedFlattened) {
            console.log("Using cached flattened OCT image");
            img.onload = () => {
              console.log("Cached flattened OCT image loaded successfully");
              img.style.display = "block";
              resetZoom(viewportNumber);
              setupImageInteractions(viewportNumber);
            };
            img.src = cachedFlattened.imageData;
            return;
          }

          console.log("Flattening OCT image and caching result...");
          const flattenResponse = await fetch(
            `/api/flatten_dicom_image?dicom_file_path=${encodeURIComponent(data.dicom_file_path)}`,
          );

          if (!flattenResponse.ok) {
            const errorData = await flattenResponse.json().catch(() => ({}));
            throw new Error(
              errorData.error ||
                `OCT flattening failed: ${flattenResponse.statusText}`,
            );
          }

          const flattenedBlob = await flattenResponse.blob();
          const flattenedUrl = URL.createObjectURL(flattenedBlob);

          // Cache ONLY the flattened image for OCT
          const cacheMetadata = {
            path: data.s3_key,
            flattened: true,
            size: flattenedBlob.size,
            lastModified: Date.now(),
            contentType: "image/png",
          };

          imageCache.set(flattenCacheKey, flattenedUrl, cacheMetadata);
          console.log(
            `Flattened OCT image cached with CRC: ${flattenCacheKey.substring(0, 8)}`,
          );

          // Store flattened URL in viewport data
          viewportData[viewportNumber].flattenedUrl = flattenedUrl;
          viewportData[viewportNumber].isFlattened = true;

          img.onload = () => {
            console.log("Flattened OCT image loaded and cached successfully");
            img.style.display = "block";
            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
          };

          img.src = flattenedUrl;
        } catch (error) {
          console.error("Error flattening OCT image:", error);
          throw error;
        }
      }

      // Flatten and show flattened image (enhanced with caching)
      async function flattenImage(viewportNumber) {
        const data = viewportData[viewportNumber];
        if (!data) {
          alert("No DICOM data loaded in this viewport.");
          return;
        }

        const img = document.getElementById(`viewportImage${viewportNumber}`);

        try {
          // Check cache first
          if (data.flattenedUrl) {
            console.log("Using cached flattened image");
            img.src = data.flattenedUrl;
            return;
          }

          console.log("Flattening image...");
          const flattenResponse = await fetch(
            `/api/flatten_dicom_image?dicom_file_path=${encodeURIComponent(data.dicom_file_path)}`,
          );

          if (!flattenResponse.ok) {
            const errorData = await flattenResponse.json().catch(() => ({}));
            throw new Error(
              errorData.error ||
                `Flattening failed: ${flattenResponse.statusText}`,
            );
          }

          const flattenedBlob = await flattenResponse.blob();
          const flattenedUrl = URL.createObjectURL(flattenedBlob);

          // Cache flattened image URL
          viewportData[viewportNumber].flattenedUrl = flattenedUrl;

          // Also cache in CRC cache
          try {
            const flattenMetadata = {
              path: data.s3_key,
              flattened: true,
              size: flattenedBlob.size,
              lastModified: Date.now(),
            };

            const flattenCacheKey = imageCache.generateCacheKey(
              data.s3_key + "_flattened",
              flattenMetadata,
            );
            imageCache.set(flattenCacheKey, flattenedUrl, flattenMetadata);
            console.log(
              `Flattened image cached with CRC: ${flattenCacheKey.substring(0, 8)}`,
            );
          } catch (cacheError) {
            console.warn(
              `Failed to cache flattened image: ${cacheError.message}`,
            );
          }

          img.onload = () => {
            console.log("Flattened image loaded successfully");
          };

          img.src = flattenedUrl;
        } catch (error) {
          console.error("Error flattening image:", error);
          alert(`Error flattening image: ${error.message}`);
        }
      }

      // Setup image interactions (zoom, pan)
      function setupImageInteractions(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const container = document.getElementById(
          `viewportContent${viewportNumber}`,
        );

        if (!img || !container) return;

        container.onwheel = null;
        img.onmousedown = null;
        img.onmouseup = null;
        img.onmouseleave = null;
        img.onmousemove = null;

        container.onwheel = (e) => {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          zoomViewport(viewportNumber, zoomFactor);
        };

        img.onmousedown = (e) => {
          isDragging[viewportNumber] = true;
          lastMousePos[viewportNumber] = { x: e.clientX, y: e.clientY };
          img.style.cursor = 'grabbing';
          e.preventDefault();
        };
        img.onmouseup = () => {
          isDragging[viewportNumber] = false;
          img.style.cursor = 'grab';
        };
        img.onmouseleave = () => {
          isDragging[viewportNumber] = false;
          img.style.cursor = 'grab';
        };
        img.onmousemove = (e) => {
          if (isDragging[viewportNumber]) {
            const deltaX = e.clientX - lastMousePos[viewportNumber].x;
            const deltaY = e.clientY - lastMousePos[viewportNumber].y;
            lastMousePos[viewportNumber] = { x: e.clientX, y: e.clientY };
            viewportPan[viewportNumber].x += deltaX;
            viewportPan[viewportNumber].y += deltaY;
            updateImageTransform(viewportNumber);
          }
        };
        img.style.cursor = 'grab';
      }

      // Global mouse event handlers
      document.addEventListener("mousemove", (e) => {
        for (let viewportNumber of [1, 2]) {
          if (isDragging[viewportNumber]) {
            const deltaX = e.clientX - lastMousePos[viewportNumber].x;
            const deltaY = e.clientY - lastMousePos[viewportNumber].y;

            viewportPan[viewportNumber].x += deltaX;
            viewportPan[viewportNumber].y += deltaY;

            updateImageTransform(viewportNumber);

            lastMousePos[viewportNumber] = { x: e.clientX, y: e.clientY };
          }
        }
      });

      document.addEventListener("mouseup", () => {
        for (let viewportNumber of [1, 2]) {
          if (isDragging[viewportNumber]) {
            isDragging[viewportNumber] = false;
            const img = document.getElementById(
              `viewportImage${viewportNumber}`,
            );
            // if (img) img.style.cursor = "grab"; // Remove setting grab cursor
          }
        }
      });

      // Zoom viewport
      function zoomViewport(viewportNumber, factor) {
        const oldZoom = viewportZoom[viewportNumber];
        viewportZoom[viewportNumber] *= factor;
        viewportZoom[viewportNumber] = Math.max(
          0.1,
          Math.min(20, viewportZoom[viewportNumber]), // Increased max zoom from 5x (500%) to 20x (2000%)
        );

        // Adjust pan to maintain center point during zoom
        const zoomRatio = viewportZoom[viewportNumber] / oldZoom;
        viewportPan[viewportNumber].x *= zoomRatio;
        viewportPan[viewportNumber].y *= zoomRatio;

        updateImageTransform(viewportNumber);
        updateZoomDisplay(viewportNumber);
      }

      // Reset zoom and pan
      function resetZoom(viewportNumber) {
        viewportZoom[viewportNumber] = 1;
        viewportPan[viewportNumber] = { x: 0, y: 0 };
        updateImageTransform(viewportNumber);
        updateZoomDisplay(viewportNumber);
      }

      // Center image in viewport
      function centerImage(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const container = document.getElementById(`viewportContent${viewportNumber}`);
        
        if (!img || !container) return;
        
        // Reset pan to center the image
        viewportPan[viewportNumber] = { x: 0, y: 0 };
        updateImageTransform(viewportNumber);
      }

      // Update image transform with improved constraints
      function constrainPan(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const container = document.getElementById(
          `viewportContent${viewportNumber}`,
        );

        if (!img || !container) return;

        const zoom = viewportZoom[viewportNumber];
        
        // Get container dimensions
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        // Get original image dimensions
        const imgWidth = img.naturalWidth || img.width;
        const imgHeight = img.naturalHeight || img.height;
        
        // Calculate scaled image dimensions
        const scaledWidth = imgWidth * zoom;
        const scaledHeight = imgHeight * zoom;
        
        // Calculate maximum allowed pan values
        // When image is smaller than container, no pan is allowed
        // When image is larger than container, pan is limited to keep image within bounds
        const maxPanX = Math.max(0, (scaledWidth - containerWidth) / 2);
        const maxPanY = Math.max(0, (scaledHeight - containerHeight) / 2);
        
        // Constrain pan values to keep image within viewport
        viewportPan[viewportNumber].x = Math.max(
          -maxPanX,
          Math.min(maxPanX, viewportPan[viewportNumber].x),
        );
        viewportPan[viewportNumber].y = Math.max(
          -maxPanY,
          Math.min(maxPanY, viewportPan[viewportNumber].y),
        );
        
        // Additional constraint: if image is smaller than container, center it
        if (scaledWidth <= containerWidth) {
          viewportPan[viewportNumber].x = 0;
        }
        if (scaledHeight <= containerHeight) {
          viewportPan[viewportNumber].y = 0;
        }
      }

      function updateImageTransform(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const container = document.getElementById(`viewportContent${viewportNumber}`);
        if (!img || !container) return;

        // Apply constraints before updating transform
        constrainPan(viewportNumber);

        const zoom = viewportZoom[viewportNumber];
        const pan = viewportPan[viewportNumber];

        // Apply transform with proper centering
        img.style.transform = `scale(${zoom}) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`;
        
        // Ensure image stays within container bounds
        img.style.maxWidth = "100%";
        img.style.maxHeight = "100%";
        img.style.objectFit = "contain";
      }

      // Update zoom display
      function updateZoomDisplay(viewportNumber) {
        const zoomDisplay = document.getElementById(
          `zoomLevel${viewportNumber}`,
        );
        if (zoomDisplay) {
          zoomDisplay.textContent = `${Math.round(viewportZoom[viewportNumber] * 100)}%`;
        }
      }

      function updateS3TreeProgress(percent) {
        const container = document.getElementById("fileTreeContainer");
        container.innerHTML = `
    <div class="tree-loading">
      <div class="loader"></div>
      <span style="margin-left: 10px;">Loading... ${percent}%</span>
    </div>
  `;
      }

      // Add cache status function
      async function getCacheStatus() {
        try {
          const response = await fetch("/api/cache-status");
          const status = await response.json();
          console.log("Cache Status:", status);

          // Also log CRC cache stats
          const crcStats = imageCache.getStats();
          console.log("CRC Cache Stats:", crcStats);

          return { ...status, crcCache: crcStats };
        } catch (error) {
          console.error("Error getting cache status:", error);
          return null;
        }
      }

      // Add function to display cache statistics
      function displayCacheStats() {
        const stats = imageCache.getStats();
        const message = `CRC Cache: ${stats.size}/${stats.maxSize} items, ${(stats.hitRate * 100).toFixed(1)}% hit rate`;
        updatePerformanceDisplay(message);
      }

      // Periodically update cache stats display
      setInterval(displayCacheStats, 10000); // Every 10 seconds

      // E2E File Loading Function
      async function loadE2EFile() {
        if (
                !selectedFilePath ||
                !selectedFilePath.toLowerCase().endsWith(".e2e")
            ) {
                alert("Please select a valid E2E file");
                return;
            }

            // Clear both viewports before loading E2E file
            clearViewport(1);
            clearViewport(2);

            // Show progress bars for both viewports right away
            showProgress(1, "Preparing to load E2E...", {
                File: selectedFilePath.split("/").pop(),
                Type: "E2E",
                Eye: "Left",
            });
            showProgress(2, "Preparing to load E2E...", {
                File: selectedFilePath.split("/").pop(),
                Type: "E2E",
                Eye: "Right",
            });

            document.getElementById("contextMenu").style.display = "none";
        // Reset E2E mode if already in it
        try {
          // Switch to E2E mode
          isE2EMode = true;
          currentE2EFile = selectedFilePath;

          // Update viewport titles
          updateViewportTitles();

          // Show E2E controls
          showE2EControls();

          // Download and process the E2E file
          const operationId1 = showProgress(1, "Processing E2E file...", {
            File: selectedFilePath.split("/").pop(),
            Type: "E2E",
            Eye: "Left",
          });

          const operationId2 = showProgress(2, "Processing E2E file...", {
            File: selectedFilePath.split("/").pop(),
            Type: "E2E",
            Eye: "Right",
          });

          const response = await fetch(
            `/api/download_dicom_from_s3?path=${encodeURIComponent(selectedFilePath)}`,
          );

          if (!response.ok) {
            throw new Error(
              `Failed to download E2E file: ${response.statusText}`,
            );
          }

          const e2eData = await response.json();
          console.log("E2E data received:", e2eData);
          console.log("Left eye data:", e2eData.left_eye_data);
          console.log("Right eye data:", e2eData.right_eye_data);

          // Store E2E data for both viewports
          viewportData[1] = {
            ...e2eData,
            eye: "left",
            s3_key: selectedFilePath,
          };
          viewportData[2] = {
            ...e2eData,
            eye: "right",
            s3_key: selectedFilePath,
          };

          // Get tree data and populate eye trees
          await populateE2ETreeData(e2eData.dicom_file_path);

          // Check if we have any frames before trying to load
          const leftFrames = (e2eData.left_eye_data?.dicom?.length || 0) + (e2eData.left_eye_data?.oct?.length || 0);
          const rightFrames = (e2eData.right_eye_data?.dicom?.length || 0) + (e2eData.right_eye_data?.oct?.length || 0);
          
          console.log(`Left frames: ${leftFrames}, Right frames: ${rightFrames}`);

          // Only load images if we have frames
          if (leftFrames > 0) {
          await loadE2EEyeImage(1, 0, e2eData.dicom_file_path, "left");
          } else {
            console.warn("No left eye frames available");
            updateProgress(1, 100, "No left eye data available");
          }
          
          if (rightFrames > 0) {
          await loadE2EEyeImage(2, 0, e2eData.dicom_file_path, "right");
          } else {
            console.warn("No right eye frames available");
            updateProgress(2, 100, "No right eye data available");
          }

          // Setup frame sliders for both eyes - use actual eye data counts
          // For E2E files, we need to store both regular frame count and original OCT frame count
          totalFrames[1] =
            (e2eData.left_eye_data?.dicom?.length || 0) +
              (e2eData.left_eye_data?.oct?.length || 0) || 1;
          totalFrames[2] =
            (e2eData.right_eye_data?.dicom?.length || 0) +
              (e2eData.right_eye_data?.oct?.length || 0) || 1;
          
          // Store original OCT frame counts for each eye
          if (viewportData[1]) {
            viewportData[1].left_eye_data = e2eData.left_eye_data;
            viewportData[1].octFrameCount = e2eData.left_eye_data?.original_oct?.length || 0;
            console.log(`Viewport 1 OCT frame count: ${viewportData[1].octFrameCount}`);
            console.log(`Viewport 1 left eye data:`, e2eData.left_eye_data);
          }
          if (viewportData[2]) {
            viewportData[2].right_eye_data = e2eData.right_eye_data;
            viewportData[2].octFrameCount = e2eData.right_eye_data?.original_oct?.length || 0;
            console.log(`Viewport 2 OCT frame count: ${viewportData[2].octFrameCount}`);
            console.log(`Viewport 2 right eye data:`, e2eData.right_eye_data);
          }
          setupFrameSlider(1);
          setupFrameSlider(2);

          hideProgress(1);
          hideProgress(2);

          console.log("E2E file loaded successfully");
        } catch (error) {
          console.error("Error loading E2E file:", error);
          hideProgress(1);
          hideProgress(2);
          alert(`Error loading E2E file: ${error.message}`);
          resetE2EMode();
        }
      }

      // Load specific eye image from E2E file
      async function loadE2EEyeImage(
        viewportNumber,
        frameNumber,
        dicomFilePath,
        eye,
      ) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`,
        );

        try {
          console.log(`Loading ${eye} eye frame ${frameNumber} from ${dicomFilePath}`);
          
          updateProgress(
            viewportNumber,
            50,
            `Loading ${eye} eye frame ${frameNumber + 1}...`,
          );

          // Use the existing E2E eye endpoint
          const url = `/api/view_e2e_eye?frame=${frameNumber}&dicom_file_path=${encodeURIComponent(dicomFilePath)}&eye=${eye}`;
          console.log(`Fetching: ${url}`);
          
          const response = await fetch(url);

          if (!response.ok) {
            const errorText = await response.text();
            console.error(`E2E eye endpoint error: ${response.status} ${response.statusText}`);
            console.error(`Error details: ${errorText}`);
            throw new Error(
              `Failed to get ${eye} eye image: ${response.statusText}`,
            );
          }

          const imageBlob = await response.blob();
          const imageUrl = URL.createObjectURL(imageBlob);

          img.onload = () => {
            console.log(`${eye} eye image loaded for frame ${frameNumber}`);
            img.style.display = "block";
            if (placeholder) placeholder.style.display = "none";
            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
            updateFrameInfo(viewportNumber, frameNumber);
            updateProgress(
              viewportNumber,
              100,
              `${eye} eye loaded successfully`,
            );
          };

          img.onerror = () => {
            throw new Error(`Failed to load ${eye} eye image`);
          };

          img.src = imageUrl;
          currentFrames[viewportNumber] = frameNumber;
          
          // Reset OCT mode when loading regular E2E frames
          if (viewportData[viewportNumber]) {
            viewportData[viewportNumber].isOctMode = false;
            viewportData[viewportNumber].octFrameCount = 0;
            // Don't call setupFrameSlider here as it resets the slider value
          }
        } catch (error) {
          console.error(`Error loading ${eye} eye image:`, error);
          throw error;
        }
      }

      // Switch to OCT mode for a viewport
      async function switchToOCTMode(viewportNumber) {
        const data = viewportData[viewportNumber];
        if (data && data.octFrameCount > 0) {
          data.isOctMode = true;
          setupFrameSlider(viewportNumber);
          console.log(`Switched viewport ${viewportNumber} to OCT mode with ${data.octFrameCount} frames`);
          
          // Load the first OCT frame
          const eye = viewportNumber === 1 ? 'left' : 'right';
          try {
            await loadOriginalOCTFrame(viewportNumber, 0, data.dicom_file_path, eye);
          } catch (error) {
            console.error(`Error loading first OCT frame: ${error}`);
          }
        }
      }

      // Switch to regular mode for a viewport
      async function switchToRegularMode(viewportNumber) {
        const data = viewportData[viewportNumber];
        if (data) {
          data.isOctMode = false;
          setupFrameSlider(viewportNumber);
          console.log(`Switched viewport ${viewportNumber} to regular mode`);
          
          // Load the first regular frame
          try {
            await loadE2EEyeImage(viewportNumber, 0, data.dicom_file_path, viewportNumber === 1 ? 'left' : 'right');
          } catch (error) {
            console.error(`Error loading first regular frame: ${error}`);
          }
        }
      }

      // Load original OCT frame (NEW function)
      async function loadOriginalOCTFrame(
        viewportNumber,
        frameIndex,
        dicomFilePath,
        eye,
      ) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`,
        );

        try {
          console.log(`Loading original OCT frame ${frameIndex} for ${eye} eye from ${dicomFilePath}`);
          console.log(`Current viewport data:`, viewportData[viewportNumber]);
          
          updateProgress(
            viewportNumber,
            50,
            `Loading original OCT frame ${frameIndex + 1}...`,
          );

          // Use the new original OCT frame endpoint
          const url = `/api/view_e2e_oct_frame?dicom_file_path=${encodeURIComponent(dicomFilePath)}&eye=${eye}&frame_idx=${frameIndex}`;
          console.log(`Fetching: ${url}`);
          
          const response = await fetch(url);

          if (!response.ok) {
            const errorText = await response.text();
            console.error(`Original OCT frame endpoint error: ${response.status} ${response.statusText}`);
            console.error(`Error details: ${errorText}`);
            throw new Error(
              `Failed to get original OCT frame: ${response.statusText}`,
            );
          }

          const imageBlob = await response.blob();
          const imageUrl = URL.createObjectURL(imageBlob);

          img.onload = () => {
            console.log(`Original OCT frame ${frameIndex} loaded for ${eye} eye`);
            img.style.display = "block";
            if (placeholder) placeholder.style.display = "none";
            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
            updateFrameInfo(viewportNumber, frameIndex);
            updateProgress(
              viewportNumber,
              100,
              `Original OCT frame loaded successfully`,
            );
          };

          img.onerror = () => {
            throw new Error(`Failed to load original OCT frame`);
          };

          img.src = imageUrl;
          currentFrames[viewportNumber] = frameIndex;
          
          // Set OCT mode and update frame count
          if (viewportData[viewportNumber]) {
            viewportData[viewportNumber].isOctMode = true;
            // Get the total number of original OCT frames for this eye
            const eyeData = eye === "left" ? viewportData[viewportNumber].left_eye_data : viewportData[viewportNumber].right_eye_data;
            viewportData[viewportNumber].octFrameCount = eyeData?.original_oct?.length || 0;
            
            // Don't call setupFrameSlider here as it resets the slider value
            // The slider should already be set up correctly
          }
        } catch (error) {
          console.error(`Error loading original OCT frame:`, error);
          throw error;
        }
      }

      // Update viewport titles for E2E mode
      function updateViewportTitles() {
        const title1 = document.querySelector("#viewport1 h4");
        const title2 = document.querySelector("#viewport2 h4");

        if (isE2EMode) {
          if (title1) title1.textContent = "Viewport 1 - Left Eye";
          if (title2) title2.textContent = "Viewport 2 - Right Eye";
        } else {
          if (title1) title1.textContent = "Viewport 1";
          if (title2) title2.textContent = "Viewport 2";
        }
      }

      // Show E2E controls
      function showE2EControls() {
        const controlsContainer = document.getElementById(
          "e2eControlsContainer",
        );
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );

        if (controlsContainer) {
          controlsContainer.style.display = "block";
        }

        // Show tree containers for both eyes
        if (leftTreeContainer) {
          leftTreeContainer.style.display = "block";
        }
        if (rightTreeContainer) {
          rightTreeContainer.style.display = "block";
        }
      }

      // Hide E2E controls
      function hideE2EControls() {
        const controlsContainer = document.getElementById(
          "e2eControlsContainer",
        );
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );

        if (controlsContainer) {
          controlsContainer.style.display = "none";
        }

        // Hide tree containers
        if (leftTreeContainer) {
          leftTreeContainer.style.display = "none";
        }
        if (rightTreeContainer) {
          rightTreeContainer.style.display = "none";
        }
      }

      // Focus on specific eye
      function focusOnEye(eye) {
        focusedEye = eye;

        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewportsContainer =
          document.getElementById("viewportsContainer");

        // Update button states with new styling
        const leftBtn = document.getElementById("focusLeftEye");
        const rightBtn = document.getElementById("focusRightEye");

        // Remove active class from all buttons
        document.querySelectorAll(".eye-focus-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Add active class to focused button
        if (eye === "left" && leftBtn) {
          leftBtn.classList.add("active");
        } else if (eye === "right" && rightBtn) {
          rightBtn.classList.add("active");
        }

        // Force viewports container to column layout for focus mode
        if (viewportsContainer) {
          viewportsContainer.classList.remove("stacked");
          viewportsContainer.style.display = "flex";
          viewportsContainer.style.flexDirection = "column";
          viewportsContainer.style.gap = "20px";
        }

        // Focus on left eye: show left viewport expanded with left tree below
        if (eye === "left") {
          if (viewport1) {
            viewport1.style.display = "flex";
            viewport1.style.border = "3px solid #28a745";
            viewport1.style.width = "100%";
            viewport1.style.flex = "1";
            viewport1.style.minHeight = "500px";
          }
          if (viewport2) {
            viewport2.style.display = "none";
          }

          // Show left eye tree container and position it below viewport1
          if (leftTreeContainer) {
            leftTreeContainer.style.display = "block";
            leftTreeContainer.style.width = "100%";
            leftTreeContainer.style.flex = "0 0 auto";
            leftTreeContainer.style.visibility = "visible";
            leftTreeContainer.style.opacity = "1";
            leftTreeContainer.style.border = "2px solid #28a745";
            leftTreeContainer.style.borderRadius = "8px";
            leftTreeContainer.style.backgroundColor = "white";
            leftTreeContainer.style.minHeight = "200px";
            leftTreeContainer.style.maxHeight = "300px";
            leftTreeContainer.style.overflowY = "auto";
            leftTreeContainer.style.marginTop = "10px";

            // Move the tree container to be a direct child of viewportsContainer
            if (leftTreeContainer.parentNode !== viewportsContainer) {
              viewportsContainer.appendChild(leftTreeContainer);
            }
          }
          if (rightTreeContainer) {
            rightTreeContainer.style.display = "none";
          }
        }
        // Focus on right eye: show right viewport expanded with right tree below
        else if (eye === "right") {
          if (viewport1) {
            viewport1.style.display = "none";
          }
          if (viewport2) {
            viewport2.style.display = "flex";
            viewport2.style.border = "3px solid #007bff";
            viewport2.style.width = "100%";
            viewport2.style.flex = "1";
            viewport2.style.minHeight = "500px";
          }

          // Show right eye tree container and position it below viewport2
          if (rightTreeContainer) {
            rightTreeContainer.style.display = "block";
            rightTreeContainer.style.width = "100%";
            rightTreeContainer.style.flex = "0 0 auto";
            rightTreeContainer.style.visibility = "visible";
            rightTreeContainer.style.opacity = "1";
            rightTreeContainer.style.border = "2px solid #007bff";
            rightTreeContainer.style.borderRadius = "8px";
            rightTreeContainer.style.backgroundColor = "white";
            rightTreeContainer.style.minHeight = "200px";
            rightTreeContainer.style.maxHeight = "300px";
            rightTreeContainer.style.overflowY = "auto";
            rightTreeContainer.style.marginTop = "10px";

            // Move the tree container to be a direct child of viewportsContainer
            if (rightTreeContainer.parentNode !== viewportsContainer) {
              viewportsContainer.appendChild(rightTreeContainer);
            }
          }
          if (leftTreeContainer) {
            leftTreeContainer.style.display = "none";
          }
        }

        console.log(
          `Focused on ${eye} eye - showing expanded viewport with tree below`,
        );
      }

      // Reset eye focus
      function resetEyeFocus() {
        focusedEye = null;

        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewportsContainer =
          document.getElementById("viewportsContainer");

        // Reset button states - remove active class from all buttons
        document.querySelectorAll(".eye-focus-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Reset viewports container to default state
        if (viewportsContainer) {
          viewportsContainer.style.display = "flex";
          if (isStackedLayout && isE2EMode) {
            // For E2E stacked layout, maintain the 80/20 split
            viewportsContainer.style.flexDirection = "row";
          } else {
          viewportsContainer.style.flexDirection = isStackedLayout
            ? "column"
            : "row";
          }
          viewportsContainer.style.gap = "20px";
        }

        // Show both viewports and reset borders and widths
        if (viewport1) {
          viewport1.style.display = "flex";
          viewport1.style.border = "2px solid #ccc";
          viewport1.style.width = "";
          viewport1.style.flex = "1";
          viewport1.style.minHeight = "";
        }
        if (viewport2) {
          viewport2.style.display = "flex";
          viewport2.style.border = "2px solid #ccc";
          viewport2.style.width = "";
          viewport2.style.flex = "1";
          viewport2.style.minHeight = "";
        }

        // Move eye trees back to their original parent containers (inside viewports) and reset styling
        if (leftTreeContainer) {
          // Move back to viewport1 if it's not already there
          if (leftTreeContainer.parentNode !== viewport1) {
            viewport1.appendChild(leftTreeContainer);
          }
          leftTreeContainer.style.display = isE2EMode ? "block" : "none";
          leftTreeContainer.style.width = "";
          leftTreeContainer.style.flex = "";
          leftTreeContainer.style.border = "2px solid #e9ecef";
          leftTreeContainer.style.backgroundColor = "white";
          leftTreeContainer.style.minHeight = "";
          leftTreeContainer.style.maxHeight = "300px";
          leftTreeContainer.style.visibility = "visible";
          leftTreeContainer.style.opacity = "1";
        }
        if (rightTreeContainer) {
          // Move back to viewport2 if it's not already there
          if (rightTreeContainer.parentNode !== viewport2) {
            viewport2.appendChild(rightTreeContainer);
          }
          rightTreeContainer.style.display = isE2EMode ? "block" : "none";
          rightTreeContainer.style.width = "";
          rightTreeContainer.style.flex = "";
          rightTreeContainer.style.border = "2px solid #e9ecef";
          rightTreeContainer.style.backgroundColor = "white";
          rightTreeContainer.style.minHeight = "";
          rightTreeContainer.style.maxHeight = "300px";
          rightTreeContainer.style.visibility = "visible";
          rightTreeContainer.style.opacity = "1";
        }

        console.log("Eye focus reset to normal layout");
      }

      // Reset E2E mode
      function clearViewport(viewportNumber) {
        // Clear the viewport image without showing progress (to avoid interference)
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`,
        );
        const error = document.getElementById(`error${viewportNumber}`);
        const frameSliderContainer = document.getElementById(
          `frameSliderContainer${viewportNumber}`,
        );

        // Hide image and show placeholder
        if (img) {
          img.style.display = "none";
          img.src = ""; // Clear the image source
        }
        if (placeholder) placeholder.style.display = "block";
        if (error) error.style.display = "none";
        if (frameSliderContainer) frameSliderContainer.classList.remove("active");

        // Reset viewport data
        if (viewportData[viewportNumber]) {
          viewportData[viewportNumber] = null;
        }

        // Reset frame counters
        currentFrames[viewportNumber] = 0;
        totalFrames[viewportNumber] = 1;

        // Reset zoom and pan
        viewportZoom[viewportNumber] = 1;
        viewportPan[viewportNumber] = { x: 0, y: 0 };

        console.log(`Viewport ${viewportNumber} cleared`);
      }

      function resetViewport(viewportNumber) {
        // Clear the viewport completely
        clearViewport(viewportNumber);
        
        // Reset E2E mode if this was the last viewport with data
        const otherViewport = viewportNumber === 1 ? 2 : 1;
        if (!viewportData[otherViewport] && isE2EMode) {
          resetE2EMode();
        }
        
        console.log(`Viewport ${viewportNumber} reset`);
      }

      function clearAllViewports() {
        // Clear both viewports
        clearViewport(1);
        clearViewport(2);
        
        // Reset E2E mode
        if (isE2EMode) {
          resetE2EMode();
        }
        
        console.log("All viewports cleared");
      }

      function resetE2EMode() {
        isE2EMode = false;
        currentE2EFile = null;
        focusedEye = null;

        hideE2EControls();
        updateViewportTitles();
        resetEyeFocus();

        // Clear both viewports
        clearViewport(1);
        clearViewport(2);

        console.log("E2E mode reset");
      }

      // Enhanced frame loading for E2E files
      async function loadFrame(viewportNumber, frameNumber) {
        if (isE2EMode && currentE2EFile) {
          const data = viewportData[viewportNumber];
          if (data && data.dicom_file_path) {
            const eye = data.eye || (viewportNumber === 1 ? "left" : "right");
            await loadE2EEyeImage(
              viewportNumber,
              frameNumber,
              data.dicom_file_path,
              eye,
            );
          }
        } else {
          // Call original frame loading function
          return await loadFrameWithCRC(viewportNumber, frameNumber);
        }
      }

      // Toggle eye tree container visibility
      function toggleEyeTree(eye) {
        const containerId =
          eye === "left" ? "leftEyeTreeContainer" : "rightEyeTreeContainer";
        const container = document.getElementById(containerId);
        const button = container.querySelector(".tree-collapse-btn");
        const content = container.querySelector(".eye-tree-content");

        if (content.style.display === "none") {
          content.style.display = "block";
          container.classList.add("expanded");
          button.classList.remove("collapsed");
        } else {
          content.style.display = "none";
          container.classList.remove("expanded");
          button.classList.add("collapsed");
        }
      }

      // Update eye tree with file data (placeholder for future implementation)
      function updateEyeTree(eye, treeData) {
        const contentId =
          eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        if (!content) return;

        if (!treeData || treeData.length === 0) {
          content.innerHTML =
            '<div class="tree-placeholder">No files available for this eye</div>';
          return;
        }

        // Build tree HTML (you can customize this later)
        let treeHTML = "";
        treeData.forEach((item, index) => {
          treeHTML += `
      <div class="eye-tree-item" onclick="selectEyeTreeItem('${eye}', ${index})">
        <i class="fas fa-file-medical"></i>
        <span>${item.name || `File ${index + 1}`}</span>
      </div>
    `;
        });

        content.innerHTML = treeHTML;
      }

      // Populate E2E tree data
      async function populateE2ETreeData(dicomFilePath) {
        try {
          const response = await fetch(
            `/api/get_e2e_tree_data?dicom_file_path=${encodeURIComponent(dicomFilePath)}`,
          );

          if (!response.ok) {
            throw new Error(`Failed to get tree data: ${response.statusText}`);
          }

          const treeData = await response.json();
          console.log("E2E tree data received:", treeData);

          // Populate left eye tree with hierarchical structure
          const leftEyeData = treeData.left_eye || {};
          populateEyeTree("left", leftEyeData);

          // Populate right eye tree with hierarchical structure
          const rightEyeData = treeData.right_eye || {};
          populateEyeTree("right", rightEyeData);

          console.log(`Populated hierarchical trees for both eyes`);
        } catch (error) {
          console.error("Error populating E2E tree data:", error);
        }
      }

      // Populate eye tree with hierarchical file data (eye -> type -> files)
      function populateEyeTree(eye, eyeData) {
        const contentId =
          eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        if (!content) return;

        // Check if we have any data
        const octFiles = eyeData.oct || [];
        const dicomFiles = eyeData.dicom || [];
        const originalOctFiles = eyeData.original_oct || [];

        if (octFiles.length === 0 && dicomFiles.length === 0 && originalOctFiles.length === 0) {
          content.innerHTML =
            '<div class="tree-placeholder">No files loaded for this eye yet</div>';
          return;
        }

        // Build hierarchical tree HTML
        let treeHTML = "";

        // Original OCT folder (NEW - contains all individual frames)
        if (originalOctFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'original_oct')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-original_oct-arrow"></i>
                <i class="fas fa-layer-group folder-icon"></i>
                <span>Original OCT Frames (${originalOctFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-original_oct-children">
          `;

          originalOctFiles.forEach((item, index) => {
            const frameNumber = (index + 1).toString().padStart(4, '0');
            treeHTML += `
              <div class="eye-tree-item file-item original-oct-frame" onclick="selectOriginalOCTFrame('${eye}', ${index}, '${item}', event)">
                <i class="fas fa-image file-icon"></i>
                <span>frame_${frameNumber}.png</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        // OCT folder (processed OCT images)
        if (octFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'oct')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-oct-arrow"></i>
                <i class="fas fa-eye folder-icon"></i>
                <span>Processed OCT (${octFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-oct-children">
          `;

          octFiles.forEach((item, index) => {
            const fileName =
              item.split("_").slice(-2).join("_") || `OCT File ${index + 1}`;
            treeHTML += `
              <div class="eye-tree-item file-item" onclick="selectEyeTreeFile('${eye}', 'oct', ${index}, '${item}', event)">
                <i class="fas fa-file-medical file-icon"></i>
                <span>${fileName}</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        // Fundus/DICOM folder
        if (dicomFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'dicom')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-dicom-arrow"></i>
                <i class="fas fa-camera folder-icon"></i>
                <span>Fundus/DICOM (${dicomFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-dicom-children">
          `;

          dicomFiles.forEach((item, index) => {
            const fileName =
              item.split("_").slice(-2).join("_") || `Fundus File ${index + 1}`;
            treeHTML += `
              <div class="eye-tree-item file-item" onclick="selectEyeTreeFile('${eye}', 'dicom', ${index}, '${item}', event)">
                <i class="fas fa-file-medical file-icon"></i>
                <span>${fileName}</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        content.innerHTML = treeHTML;
      }

      // Toggle eye tree folder (OCT, DICOM/Fundus, or Original OCT)
      function toggleEyeTreeFolder(eye, type) {
        const childrenId = `${eye}-${type}-children`;
        const arrowId = `${eye}-${type}-arrow`;

        const children = document.getElementById(childrenId);
        const arrow = document.getElementById(arrowId);

        if (children && arrow) {
          if (children.style.display === "none") {
            children.style.display = "block";
            arrow.style.transform = "rotate(0deg)";
          } else {
            children.style.display = "none";
            arrow.style.transform = "rotate(-90deg)";
          }
        }
      }

      // Select original OCT frame (NEW function)
      function selectOriginalOCTFrame(eye, frameIndex, fileName, event) {
        // Prevent event bubbling to parent folder
        if (event) {
          event.stopPropagation();
        }

        const contentId = eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        // Remove previous selection from all file items
        content.querySelectorAll(".file-item").forEach((item) => {
          item.classList.remove("selected");
        });

        // Find and select the clicked original OCT frame item
        const fileItems = content.querySelectorAll(".original-oct-frame");
        fileItems.forEach((item, itemIndex) => {
          if (itemIndex === frameIndex) {
            item.classList.add("selected");
          }
        });

        // Load the selected original OCT frame
        if (isE2EMode && currentE2EFile) {
          const viewportNumber = eye === "left" ? 1 : 2;
          const data = viewportData[viewportNumber];
          if (data && data.dicom_file_path) {
            loadOriginalOCTFrame(viewportNumber, frameIndex, data.dicom_file_path, eye);
          }
        }

        console.log(`Selected original OCT frame ${frameIndex} (${fileName}) in ${eye} eye tree`);
      }

      // Select file in hierarchical eye tree
      function selectEyeTreeFile(eye, type, index, fileName, event) {
        // Prevent event bubbling to parent folder
        if (event) {
          event.stopPropagation();
        }
        const contentId =
          eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        // Remove previous selection
        content.querySelectorAll(".file-item").forEach((item) => {
          item.classList.remove("selected");
        });

        // Find and select the clicked file item
        const fileItems = content.querySelectorAll(".file-item");
        let globalIndex = 0;

        // Calculate the global index based on type and position
        if (type === "dicom") {
          const octFiles =
            viewportData[eye === "left" ? 1 : 2]?.left_eye_data?.oct?.length ||
            viewportData[eye === "left" ? 1 : 2]?.right_eye_data?.oct?.length ||
            0;
          globalIndex = octFiles + index;
        } else {
          globalIndex = index;
        }

        // Select the appropriate file item
        fileItems.forEach((item, itemIndex) => {
          if (
            item.onclick &&
            item.onclick.toString().includes(`${type}', ${index}`)
          ) {
            item.classList.add("selected");
          }
        });

        // Load the selected image
        if (isE2EMode && currentE2EFile) {
          const viewportNumber = eye === "left" ? 1 : 2;
          const data = viewportData[viewportNumber];
          if (data && data.dicom_file_path) {
            loadE2EEyeImage(
              viewportNumber,
              globalIndex,
              data.dicom_file_path,
              eye,
            );
          }
        }
        // Tree remains open after file selection for better user experience

        console.log(
          `Selected ${type} file ${index} (${fileName}) in ${eye} eye tree`,
        );
      }

      // Legacy function for backward compatibility
      function selectEyeTreeItem(eye, index) {
        selectEyeTreeFile(eye, "oct", index, `file_${index}`);
      }

      // Eye Focus Menu Functions
      function toggleEyeFocusMenu() {
        const menu = document.getElementById('eyeFocusDropdownMenu');
        const burger = document.querySelector('.eye-focus-burger');
        
        if (menu.classList.contains('show')) {
          menu.classList.remove('show');
          burger.classList.remove('active');
        } else {
          menu.classList.add('show');
          burger.classList.add('active');
        }
      }

      // Close menu when clicking outside
      document.addEventListener('click', function(event) {
        const menu = document.getElementById('eyeFocusDropdownMenu');
        const burger = document.querySelector('.eye-focus-burger');
        const eyeFocusMenu = document.querySelector('.eye-focus-menu');
        
        if (!eyeFocusMenu.contains(event.target)) {
          menu.classList.remove('show');
          burger.classList.remove('active');
        }
      });

      // Enhanced resetEyeFocus to also close menu
      function resetEyeFocus() {
        focusedEye = null;

        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewportsContainer =
          document.getElementById("viewportsContainer");
        const menu = document.getElementById('eyeFocusDropdownMenu');
        const burger = document.querySelector('.eye-focus-burger');

        // Close menu
        if (menu) {
          menu.classList.remove('show');
        }
        if (burger) {
          burger.classList.remove('active');
        }

        // Reset button states - remove active class from all buttons
        document.querySelectorAll(".eye-focus-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Reset viewports container to default state
        if (viewportsContainer) {
          viewportsContainer.style.display = "flex";
          if (isStackedLayout && isE2EMode) {
            // For E2E stacked layout, maintain the 80/20 split
            viewportsContainer.style.flexDirection = "row";
          } else {
          viewportsContainer.style.flexDirection = isStackedLayout
            ? "column"
            : "row";
          }
          viewportsContainer.style.gap = "20px";
        }

        // Show both viewports and reset borders and widths
        if (viewport1) {
          viewport1.style.display = "flex";
          viewport1.style.border = "2px solid #ccc";
          viewport1.style.width = "";
          viewport1.style.flex = "1";
          viewport1.style.minHeight = "";
        }
        if (viewport2) {
          viewport2.style.display = "flex";
          viewport2.style.border = "2px solid #ccc";
          viewport2.style.width = "";
          viewport2.style.flex = "1";
          viewport2.style.minHeight = "";
        }

        // Move eye trees back to their original parent containers (inside viewports) and reset styling
        if (leftTreeContainer) {
          // Move back to viewport1 if it's not already there
          if (leftTreeContainer.parentNode !== viewport1) {
            viewport1.appendChild(leftTreeContainer);
          }
          leftTreeContainer.style.display = isE2EMode ? "block" : "none";
          leftTreeContainer.style.width = "";
          leftTreeContainer.style.flex = "";
          leftTreeContainer.style.border = "2px solid #e9ecef";
          leftTreeContainer.style.backgroundColor = "white";
          leftTreeContainer.style.minHeight = "";
          leftTreeContainer.style.maxHeight = "300px";
          leftTreeContainer.style.visibility = "visible";
          leftTreeContainer.style.opacity = "1";
        }
        if (rightTreeContainer) {
          // Move back to viewport2 if it's not already there
          if (rightTreeContainer.parentNode !== viewport2) {
            viewport2.appendChild(rightTreeContainer);
          }
          rightTreeContainer.style.display = isE2EMode ? "block" : "none";
          rightTreeContainer.style.width = "";
          rightTreeContainer.style.flex = "";
          rightTreeContainer.style.border = "2px solid #e9ecef";
          rightTreeContainer.style.backgroundColor = "white";
          rightTreeContainer.style.minHeight = "";
          rightTreeContainer.style.maxHeight = "300px";
          rightTreeContainer.style.visibility = "visible";
          rightTreeContainer.style.opacity = "1";
        }

        console.log("Eye focus reset to normal layout");
      }

      // Add keyboard shortcut for cancelling operations (ESC key)
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          // Cancel any active operations
          for (let viewportNumber of [1, 2]) {
            if (progressManagers[viewportNumber].operationId) {
              cancelOperation(viewportNumber);
              console.log(
                `Cancelled operation in viewport ${viewportNumber} via ESC key`,
              );
            }
          }

          // Also hide E2E controls if ESC is pressed
          if (isE2EMode) {
            hideE2EControls();
          }
        }
      });
    </script>
  </body>
</html>
