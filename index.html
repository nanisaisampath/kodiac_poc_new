<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kodiak Retinal Image Viewer v0.1.0</title>

    <!-- Add the Google Font link here -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />

    <style>
      body {
        font-family: "Roboto", Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        background: linear-gradient(180deg, #338dcc, #eaf3f9);
        min-height: 100vh;
      }

      header {
        width: 100%;
        background-color: #f5f5f5;
        color: white;
        padding: 15px;
        text-align: center;
        font-size: 2.5rem;
      }

      /* Sidebar Styling */
      .sidebar {
        position: fixed;
        top: 0;
        bottom: 0;
        width: 60px;
        background-color: #0c2130;
        overflow: hidden;
        transition: width 0.3s ease;
        z-index: 2;
      }

      .sidebar:hover {
        width: 100px;
      }

      .sidebar nav {
        margin-top: 20px;
      }

      .sidebar h2 {
        color: white;
        padding: 20px;
        font-size: 1.4rem;
        text-align: center;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1;
      }

      .sidebar nav a {
        padding: 10px 10px;
        display: block;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .sidebar:hover nav a {
        opacity: 1;
      }

      .sidebar nav a:hover {
        background-color: #338dcc;
      }

      /* Right Toolbar Styling */
      .toolbar {
        position: fixed;
        top: 0;
        bottom: 0;
        right: 0;
        width: 60px;
        background-color: #0c2130;
        overflow: hidden;
        transition: width 0.3s ease;
        z-index: 2;
      }

      .toolbar nav {
        margin-top: 20px;
      }

      .toolbar:hover {
        width: 100px;
      }

      .toolbar h2 {
        color: white;
        padding: 20px;
        font-size: 1.25rem;
        text-align: center;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 1;
      }

      .toolbar a {
        padding: 10px 10px;
        display: block;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .toolbar:hover a {
        opacity: 1;
      }

      .toolbar a:hover {
        background-color: #338dcc;
      }

      /* Main Content Adjustments */
      .main-content {
        margin-left: 60px;
        margin-right: 60px;
        display: flex;
        width: calc(100% - 120px);
        padding: 20px;
        overflow-y: auto;
        box-sizing: border-box;
        min-height: calc(100vh - 120px);
      }

      /* File Browser Layout */
      .file-browser-container {
        display: none;
        width: 100%;
        height: calc(100vh - 120px);
        overflow: hidden; /* Prevent page-level overflow */
      }

      .file-browser-layout {
        display: flex;
        height: 100%;
        gap: 20px;
        min-height: 0; /* Allow flex shrinking */
      }

      /* Enhanced Tree View with Drill-down */
      .tree-panel {
        width: 350px;
        background-color: white;
        border: 2px solid #0c2130;
        border-radius: 8px;
        padding: 15px;
        overflow-y: auto;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
      }

      .tree-panel h3 {
        margin-top: 0;
        color: #0c2130;
        border-bottom: 2px solid #338dcc;
        padding-bottom: 10px;
      }

      .tree-search {
        width: 100%;
        padding: 8px;
        margin-bottom: 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
      }

      /* Performance Controls Styling */
      .performance-controls {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 15px;
      }

      .performance-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .performance-header h4 {
        margin: 0;
        color: #495057;
        font-size: 14px;
      }

      .refresh-btn {
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.2s;
      }

      .refresh-btn:hover {
        background-color: #0056b3;
      }

      .listing-method {
        margin-bottom: 10px;
      }

      .listing-method label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #6c757d;
      }

      .custom-prefix-controls {
        border-top: 1px solid #dee2e6;
        padding-top: 10px;
        margin-top: 10px;
      }

      .custom-prefix-controls label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #6c757d;
      }

      .custom-prefix-input {
        margin-bottom: 10px;
      }

      .apply-prefixes-btn {
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background-color 0.2s;
      }

      .apply-prefixes-btn:hover {
        background-color: #1e7e34;
      }

      .performance-info {
        border-top: 1px solid #dee2e6;
        padding-top: 10px;
        margin-top: 10px;
      }

      .perf-metric {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 12px;
      }

      .perf-label {
        color: #6c757d;
        font-weight: 500;
      }

      .perf-value {
        color: #495057;
        font-weight: 600;
      }

      /* Navigation Header */
      .tree-navigation {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        padding: 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #e9ecef;
      }

      .back-button {
        background: none;
        border: none;
        color: #338dcc;
        cursor: pointer;
        font-size: 14px;
        padding: 4px 8px;
        border-radius: 3px;
        display: none;
        align-items: center;
        gap: 5px;
        transition: background-color 0.2s ease;
      }

      .back-button:hover {
        background-color: #e9ecef;
      }

      .back-button.visible {
        display: flex;
      }

      .current-path {
        font-size: 12px;
        color: #666;
        margin-left: auto;
        font-style: italic;
      }

      /* File Tree Container */
      .file-tree-container {
        flex: 1;
        overflow-y: auto;
      }

      .file-tree {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      /* Tree Items */
      .tree-item {
        display: flex;
        align-items: flex-start;
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.2s ease;
        user-select: none;
        margin-bottom: 2px;
        border: 1px solid transparent;
        position: relative;
        min-height: 36px;
      }

      .tree-item:hover {
        background-color: #f0f8ff;
        border-color: #e3f2fd;
      }

      .tree-item.selected {
        background-color: #338dcc;
        color: white;
      }

      .tree-item.loading {
        background-color: #fff3cd;
        border-color: #ffeaa7;
      }

      /* Tree Item Content */
      .tree-item-content {
        display: flex;
        align-items: flex-start;
        width: 100%;
        gap: 8px;
        min-height: 20px;
        position: relative;
        padding-right: 30px; /* Make room for checkbox */
      }

      .expand-arrow {
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: #666;
        cursor: pointer;
        transition: transform 0.2s ease;
        margin-top: 2px;
        flex-shrink: 0;
      }

      .expand-arrow.expanded {
        transform: rotate(0deg);
      }

      .expand-arrow.collapsed {
        transform: rotate(0deg);
      }

      .tree-icon {
        width: 18px;
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 1px;
        flex-shrink: 0;
      }

      .folder-icon {
        color: #ffd700;
      }

      .file-icon {
        color: #666;
      }

      .tree-item-name {
        flex: 1;
        font-size: 14px;
        white-space: normal;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
        min-width: 0;
        line-height: 1.3;
        padding: 2px 0;
      }

      .tree-item-info {
        font-size: 11px;
        color: #999;
        margin-left: auto;
      }

      /* Enhanced Tooltip for Full File Names */
      .tree-item-tooltip {
        position: absolute;
        background-color: #2c3e50;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 13px;
        white-space: nowrap;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.3s ease,
          visibility 0.3s ease;
        pointer-events: none;
        max-width: 400px;
        word-break: break-all;
        left: 100%;
        top: 50%;
        transform: translateY(-50%);
        margin-left: 10px;
      }

      .tree-item-tooltip::before {
        content: "";
        position: absolute;
        top: 50%;
        left: -6px;
        transform: translateY(-50%);
        border: 6px solid transparent;
        border-right-color: #2c3e50;
      }

      .tree-item:hover .tree-item-tooltip {
        opacity: 1;
        visibility: visible;
      }

      /* Adjust tooltip position if it would go off-screen */
      .tree-item-tooltip.tooltip-left {
        left: auto;
        right: 100%;
        margin-left: 0;
        margin-right: 10px;
      }

      .tree-item-tooltip.tooltip-left::before {
        left: auto;
        right: -6px;
        border-right-color: transparent;
        border-left-color: #2c3e50;
      }

      /* Loading and Error States */
      .tree-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        color: #666;
      }

      .tree-error {
        padding: 15px;
        background-color: #ffebee;
        border: 1px solid #f8bbd9;
        border-radius: 4px;
        color: #d32f2f;
        text-align: center;
      }

      .tree-empty {
        padding: 20px;
        text-align: center;
        color: #999;
        font-style: italic;
      }

      /* Viewport Panel */
      /* Enhanced Viewport Panel with proper constraints */
      .viewport-panel {
        flex: 1;
        background-color: white;
        border: 2px solid #0c2130;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        min-width: 0; /* Allow flex shrinking */
        min-height: 0; /* Allow flex shrinking */
      }

      .viewport-panel h3 {
        margin-top: 0;
        color: #0c2130;
        border-bottom: 2px solid #338dcc;
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Layout Toggle Button */
      .layout-toggle {
        background-color: #338dcc;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.3s ease;
      }

      .layout-toggle:hover {
        background-color: #0c2130;
      }

      /* Viewports Container with proper flex constraints */
      .viewports-container {
        display: flex;
        gap: 2px;
        flex: 1;
        min-height: 0; /* Critical for flex children */
        overflow: hidden; /* Prevent container overflow */
      }

      .viewports-container.stacked {
        flex-direction: column;
      }

      /* Individual Viewport with strict boundaries */
      .viewport {
        flex: 1;
        border: 2px solid #ccc;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        background-color: #f9f9f9;
        transition:
          border-color 0.3s ease,
          box-shadow 0.3s ease;
        position: relative;
        min-width: 0; /* Allow shrinking */
        min-height: 0; /* Allow shrinking */
        box-sizing: border-box;
        overflow: hidden; /* Prevent viewport overflow */
      }

      .viewport h4 {
        margin-top: 0;
        text-align: center;
        color: #0c2130;
        border-bottom: 1px solid #ddd;
        padding-bottom: 8px;
      }

      /* Viewport Content with strict size constraints */
      .viewport-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 300px;
        max-height: 600px; /* Prevent excessive height */
        background-color: white;
        border: 1px dashed #ccc;
        border-radius: 4px;
        position: relative;
        overflow: hidden; /* Critical: prevent content overflow */
        width: 100%;
        box-sizing: border-box;
      }

      /* Enhanced Image Constraints */
      .viewport-image {
        max-width: 100% !important;
        max-height: 100% !important;
        width: auto !important;
        height: auto !important;
        object-fit: contain; /* Maintain aspect ratio */
        cursor: grab;
        transition: transform 0.1s ease;
        transform-origin: center center;
        position: relative;
        display: block;
        box-sizing: border-box;
      }

      .viewport-image:active {
        cursor: grabbing;
      }

      .viewport-placeholder {
        color: #666;
        text-align: center;
        font-style: italic;
      }

      .zoom-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
      }

      .zoom-btn {
        padding: 5px 10px;
        background-color: #338dcc;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .zoom-btn:hover {
        background-color: #0c2130;
      }

      .zoom-level {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #666;
      }

      /* Context Menu */
      .context-menu {
        position: absolute;
        display: none;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        z-index: 9999;
        min-width: 160px;
        padding: 5px 0;
      }

      .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
      }

      .context-menu-item:hover {
        background-color: #f0f8ff;
      }

      .context-menu-icon {
        margin-right: 8px;
        width: 16px;
      }

      /* Loading Spinner */
      .loader {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #338dcc;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Enhanced Progress Overlay with Shadow Image Effect */
      .progress-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.95),
          rgba(240, 248, 255, 0.98)
        );
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
        backdrop-filter: blur(2px);
        border-radius: 4px;
      }

      .progress-overlay.active {
        display: flex;
      }

      .progress-overlay::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        height: 60%;
        background: linear-gradient(
          45deg,
          rgba(51, 141, 204, 0.1) 0%,
          rgba(51, 141, 204, 0.05) 25%,
          rgba(12, 33, 48, 0.1) 50%,
          rgba(51, 141, 204, 0.05) 75%,
          rgba(51, 141, 204, 0.1) 100%
        );
        border-radius: 8px;
        animation: shadowPulse 2s ease-in-out infinite;
        z-index: -1;
      }

      @keyframes shadowPulse {
        0%,
        100% {
          opacity: 0.3;
          transform: translate(-50%, -50%) scale(0.95);
        }
        50% {
          opacity: 0.6;
          transform: translate(-50%, -50%) scale(1.05);
        }
      }

      .progress-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        z-index: 2;
        text-align: center;
        max-width: 90%;
      }

      .progress-circle {
        position: relative;
        width: 80px;
        height: 80px;
      }

      .progress-ring {
        width: 80px;
        height: 80px;
        transform: rotate(-90deg);
      }

      .progress-ring-bg {
        fill: none;
        stroke: #e6e6e6;
        stroke-width: 6;
      }

      .progress-ring-fill {
        fill: none;
        stroke: #338dcc;
        stroke-width: 6;
        stroke-linecap: round;
        stroke-dasharray: 226;
        stroke-dashoffset: 226;
        transition: stroke-dashoffset 0.3s ease;
      }

      .progress-percentage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 16px;
        font-weight: bold;
        color: #0c2130;
      }

      .progress-text {
        color: #0c2130;
        font-weight: 500;
        font-size: 14px;
        margin: 0;
      }

      .progress-metadata {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        margin-top: 10px;
      }

      .metadata-tag {
        background: linear-gradient(135deg, #338dcc, #0c2130);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        animation: tagFadeIn 0.5s ease-out;
      }

      @keyframes tagFadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .progress-steps {
        display: flex;
        gap: 8px;
        margin-top: 15px;
      }

      .progress-step {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #e6e6e6;
        transition: all 0.3s ease;
      }

      .progress-step.active {
        background-color: #338dcc;
        transform: scale(1.2);
      }

      .progress-step.completed {
        background-color: #28a745;
      }

      /* Cancel Button Styling */
      .cancel-button {
        padding: 8px 16px;
        background-color: #dc3545;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 15px;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .cancel-button:hover {
        background-color: #c82333;
      }

      .cancel-button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
      }

      /* Error message styling */
      .error-message {
        color: #d32f2f;
        background-color: #ffebee;
        border: 1px solid #f8bbd9;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        text-align: center;
      }

      .retry-button {
        background-color: #338dcc;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
      }

      .retry-button:hover {
        background-color: #0c2130;
      }

      /* Frame slider styling */
      .frame-slider-container {
        margin-top: 10px;
        padding: 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
        display: none;
      }

      .frame-slider-container.active {
        display: block;
      }

      .frame-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 5px 0;
      }

      .frame-btn {
        background-color: #338dcc;
        color: white;
        border: none;
        border-radius: 4px;
        width: 32px;
        height: 32px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        transition: background-color 0.2s ease;
        flex-shrink: 0;
      }

      .frame-btn:hover {
        background-color: #0c2130;
      }

      .frame-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        opacity: 0.6;
      }

      .frame-slider {
        flex: 1;
        margin: 0;
      }

      .frame-info {
        text-align: center;
        font-size: 12px;
        color: #666;
        margin-top: 5px;
      }

      .frame-help {
        text-align: center;
        font-size: 10px;
        color: #999;
        margin-top: 3px;
        font-style: italic;
      }

      /* Original viewport containers for DICOM view */
      .viewport-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 1px solid #0c2130;
        padding: 10px 20px;
        margin: 10px;
        background-color: transparent;
        width: calc(100% - 40px);
        max-width: 900px;
        box-sizing: border-box;
        position: relative;
      }

      .viewport-container h2 {
        margin-bottom: 10px;
        font-size: 1.5rem;
        text-align: center;
      }

      .progress-container {
        width: 100%;
        background-color: #f1f1f1;
        border-radius: 5px;
        margin: 20px 0;
        position: relative;
        height: 20px;
      }

      .progress-bar {
        background: linear-gradient(90deg, #338dcc, #0c2130);
        height: 100%;
        width: 0;
        border-radius: 5px;
        transition: width 0.4s ease;
      }

      .progress-text {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-weight: bold;
        font-size: 14px;
        line-height: 20px;
      }

      .dicom-prompt {
        padding: 50px;
        border: 2px dashed #0c2130;
        text-align: center;
        color: #0c2130;
        font-size: 1.2rem;
        cursor: pointer;
      }

      .horizontal-line {
        width: 100%;
        height: 2px;
        background-color: #ccc;
        margin: 20px 0;
      }

      .viewport-image-original {
        display: none;
        max-width: 100%;
        height: auto;
        border: 1px solid #ccc;
        margin-top: 15px;
      }

      .slider-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-top: 5px;
        width: 100%;
      }

      .slider-section p,
      .slider-section label {
        display: block;
        text-align: center;
        margin-bottom: 5px;
      }

      input[type="range"] {
        width: 15%;
        display: block;
        margin-left: auto;
        margin-right: auto;
      }

      #bindSlidersContainer {
        margin-top: 20px;
        text-align: center;
        width: 100%;
      }

      footer {
        width: 100%;
        color: black;
        text-align: center;
        padding: 5px;
        font-size: 12px;
        position: fixed;
        bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: rgba(255, 255, 255, 0.9);
      }

      .performance-monitor {
        font-size: 11px;
        color: #666;
        margin-left: 20px;
      }

      /* Responsive Layout Adjustments */
      @media (max-width: 1200px) {
        .viewports-container:not(.stacked) {
          flex-direction: column;
        }

        .viewport-content {
          min-height: 250px;
          max-height: 400px;
        }
      }

      /* Mobile responsive adjustments for frame controls */
      @media (max-width: 768px) {
        .frame-controls {
          gap: 5px;
        }

        .frame-btn {
          width: 28px;
          height: 28px;
          font-size: 12px;
        }

        .frame-slider {
          min-width: 100px;
        }

        .frame-help {
          font-size: 9px;
        }
      }

      @media (max-width: 768px) {
        .viewport-container {
          width: 100%;
          padding: 10px;
        }

        .toolbar,
        .sidebar {
          display: none;
        }

        .main-content {
          margin-left: 0;
          margin-right: 0;
          width: 100%;
          padding: 10px;
        }

        .file-browser-layout {
          flex-direction: column;
        }

        .tree-panel {
          width: 100%;
          height: 300px;
        }

        .viewports-container {
          flex-direction: column;
        }

        .viewport-content {
          min-height: 200px;
          max-height: 300px;
        }
      }

      /* S3 Credentials Modal */
      .s3-credentials-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }

      .s3-credentials-form {
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
      }

      .s3-credentials-form h2 {
        color: #0c2130;
        margin-bottom: 20px;
        text-align: center;
        border-bottom: 2px solid #338dcc;
        padding-bottom: 10px;
      }

      .s3-form-group {
        margin-bottom: 20px;
      }

      .s3-form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #0c2130;
      }

      .s3-form-group input {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        box-sizing: border-box;
      }

      .s3-form-group input:focus {
        outline: none;
        border-color: #338dcc;
        box-shadow: 0 0 5px rgba(51, 141, 204, 0.3);
      }

      .s3-form-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 25px;
      }

      .s3-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: background-color 0.3s ease;
      }

      .s3-btn-primary {
        background-color: #338dcc;
        color: white;
      }

      .s3-btn-primary:hover {
        background-color: #0c2130;
      }

      .s3-btn-secondary {
        background-color: #ccc;
        color: #333;
      }

      .s3-btn-secondary:hover {
        background-color: #bbb;
      }

      .s3-form-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 15px;
      }

      .s3-form-checkbox input[type="checkbox"] {
        width: auto;
      }

      .s3-error-message {
        background-color: #ffebee;
        color: #d32f2f;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
        border: 1px solid #f8bbd9;
      }

      .s3-success-message {
        background-color: #e8f5e8;
        color: #2e7d32;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
        border: 1px solid #c8e6c9;
      }

      .s3-loading {
        text-align: center;
        padding: 20px;
      }

      .s3-loading .loader {
        margin: 0 auto;
      }

      /* Eye Focus Menu */
      .eye-focus-menu {
        position: relative;
        display: inline-block;
      }

      .eye-focus-burger {
        padding: 8px 12px;
        background: linear-gradient(135deg, #338dcc, #0c2130);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 80px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .eye-focus-burger:hover {
        background: linear-gradient(135deg, #0c2130, #338dcc);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .eye-focus-burger i:last-child {
        transition: transform 0.3s ease;
      }

      .eye-focus-burger.active i:last-child {
        transform: rotate(180deg);
      }

      .eye-focus-dropdown-menu {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        margin-top: 4px;
        overflow: hidden;
        min-width: 160px;
      }

      .eye-focus-dropdown-menu.show {
        display: block;
        animation: dropdownFadeIn 0.2s ease-out;
      }

      @keyframes dropdownFadeIn {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .eye-focus-item {
        padding: 12px 16px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #333;
        border-bottom: 1px solid #f0f0f0;
      }

      .eye-focus-item:last-child {
        border-bottom: none;
      }

      .eye-focus-item:hover {
        background: linear-gradient(135deg, #f0f8ff, #e3f2fd);
        color: #338dcc;
      }

      .eye-focus-item i {
        color: #338dcc;
        width: 16px;
        text-align: center;
      }

      .reset-button {
        padding: 8px 16px;
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .reset-button:hover {
        background: linear-gradient(135deg, #c82333, #dc3545);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .reset-button i {
        font-size: 12px;
      }

      /* S3 Selection Styles */
      .s3-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .s3-selection-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .select-mode-btn, .cache-btn, .cancel-btn {
        padding: 6px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .select-mode-btn {
        background-color: #007bff;
        color: white;
      }

      .select-mode-btn:hover {
        background-color: #0056b3;
      }

      .cache-btn {
        background-color: #28a745;
        color: white;
      }

      .cache-btn:hover {
        background-color: #1e7e34;
      }

      .cancel-btn {
        background-color: #6c757d;
        color: white;
      }

      .cancel-btn:hover {
        background-color: #545b62;
      }

      .file-item-selectable, .folder-item-selectable {
        position: relative;
        cursor: pointer;
      }

      .file-item-selectable.selected, .folder-item-selectable.selected {
        background-color: #e3f2fd !important;
        border: 2px solid #2196f3 !important;
        border-radius: 4px;
      }

      .tree-item.selected {
        background-color: #e3f2fd !important;
        border: 2px solid #2196f3 !important;
        border-radius: 4px;
      }

      .selection-checkbox {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid #ddd;
        border-radius: 3px;
        display: none;
        cursor: pointer;
        z-index: 10;
        flex-shrink: 0;
      }

      .selection-checkbox.visible {
        display: block;
      }

      .selection-checkbox.checked {
        background-color: #2196f3;
        border-color: #2196f3;
      }

      .selection-checkbox.checked::after {
        content: '✓';
        color: white;
        font-size: 10px;
        position: absolute;
        top: -1px;
        left: 2px;
        line-height: 1;
        font-weight: bold;
      }

      .selection-checkbox.disabled {
        background-color: #f5f5f5;
        border-color: #ccc;
        cursor: not-allowed;
        opacity: 0.5;
      }

      .selection-checkbox.disabled::after {
        content: '⨯';
        color: #999;
        font-size: 12px;
        position: absolute;
        top: -1px;
        left: 1px;
        line-height: 1;
        font-weight: bold;
      }

      /* Cache Progress Popup Styles */
      .cache-progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
      }

      .cache-progress-modal {
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 500px;
        overflow: hidden;
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .cache-progress-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .cache-progress-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .cache-progress-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
      }

      .cache-progress-close:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .cache-progress-content {
        padding: 30px;
      }

      .cache-progress-bar {
        width: 100%;
        height: 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .cache-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .cache-progress-text {
        text-align: center;
        font-size: 16px;
        color: #495057;
        margin-bottom: 25px;
        font-weight: 500;
      }

      .cache-progress-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .stat-label {
        font-weight: 500;
        color: #6c757d;
        font-size: 14px;
      }

      .stat-value {
        font-weight: 600;
        color: #495057;
        font-size: 16px;
        min-width: 30px;
        text-align: right;
      }

      /* Current file progress styles */
      .current-file-section {
        margin: 20px 0;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e9ecef;
      }

      .current-file-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .current-file-header h4 {
        margin: 0;
        font-size: 14px;
        color: #495057;
        font-weight: 600;
      }

      .file-status {
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .file-status.preparing {
        background-color: #fff3cd;
        color: #856404;
      }

      .file-status.downloading {
        background-color: #d1ecf1;
        color: #0c5460;
      }

      .file-status.processing {
        background-color: #d4edda;
        color: #155724;
      }

      .file-status.complete {
        background-color: #d1e7dd;
        color: #0f5132;
      }

      .file-status.failed {
        background-color: #f8d7da;
        color: #721c24;
      }

      .file-status.skipped {
        background-color: #e2e3e5;
        color: #383d41;
      }

      .current-file-progress-bar {
        width: 100%;
        height: 6px;
        background-color: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 8px;
      }

      .current-file-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #28a745 0%, #20c997 100%);
        border-radius: 3px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .current-file-details {
        font-size: 12px;
        color: #6c757d;
        font-style: italic;
      }

      /* Folder selection styling */
      .folder-item {
        border-left: 3px solid transparent;
      }

      .folder-item.selected {
        border-left: 3px solid #ff9800;
        background-color: #fff3e0 !important;
      }

      .folder-item.file-item-selectable.selected {
        background-color: #e3f2fd !important;
        border: 2px solid #2196f3 !important;
        border-left: 3px solid #ff9800 !important;
      }

      .reset-button:hover {
        background-color: #c82333;
      }

      /* Eye Tree Container Styling */
      .eye-tree-container {
        margin-top: 15px;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        max-height: 300px;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .eye-tree-container.expanded {
        max-height: 500px;
      }

      .eye-tree-header {
        background: linear-gradient(135deg, #f1f3f4, #e8f0fe);
        padding: 10px 15px;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .eye-tree-header:hover {
        background: linear-gradient(135deg, #e8f0fe, #f1f3f4);
      }

      .eye-tree-header h5 {
        margin: 0;
        font-size: 14px;
        color: #0c2130;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tree-collapse-btn {
        background: none;
        border: none;
        color: #338dcc;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.3s ease;
      }

      .tree-collapse-btn:hover {
        background-color: rgba(51, 141, 204, 0.1);
        transform: scale(1.1);
      }

      .tree-collapse-btn i {
        transition: transform 0.3s ease;
      }

      .tree-collapse-btn.collapsed i {
        transform: rotate(-90deg);
      }

      .eye-tree-content {
        padding: 12px;
        max-height: 250px;
        overflow-y: auto;
        font-size: 13px;
      }

      .tree-placeholder {
        color: #6c757d;
        font-style: italic;
        text-align: center;
        padding: 20px;
      }

      .eye-tree-item {
        padding: 6px 10px;
        margin: 2px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .eye-tree-item:hover {
        background-color: #f8f9fa;
      }

      .eye-tree-item.selected {
        background-color: #e3f2fd;
        color: #0c2130;
        font-weight: 500;
      }

      .eye-tree-item i {
        color: #338dcc;
        width: 16px;
        text-align: center;
      }

      /* Hierarchical tree styles */
      .eye-tree-folder {
        margin: 2px 0;
      }

      .folder-header {
        background-color: #f1f3f4;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        font-weight: 500;
        margin-bottom: 2px;
      }

      .folder-header:hover {
        background-color: #e8f0fe;
      }

      .folder-arrow {
        transition: transform 0.2s ease;
        color: #666 !important;
      }

      .folder-icon {
        color: #338dcc !important;
      }

      .eye-tree-children {
        margin-left: 20px;
        border-left: 2px solid #e0e0e0;
        padding-left: 8px;
      }

      .file-item {
        background-color: #fafafa;
        border: 1px solid transparent;
        font-size: 13px;
      }

      .file-item:hover {
        background-color: #f0f8ff;
        border-color: #338dcc;
      }

      .file-item.selected {
        background-color: #338dcc;
        color: white;
        border-color: #0c2130;
      }

      .file-item.selected i {
        color: white !important;
      }

      .file-icon {
        color: #666 !important;
      }

      /* DICOM Viewports Container */
      .dicom-viewports-container {
        display: flex;
        flex-direction: column;
        width: 100%;
      }

      .dicom-viewports-container.side-by-side {
        flex-direction: row;
        gap: 20px;
      }

      .dicom-viewports-container.side-by-side .viewport-container {
        flex: 1;
        width: calc(50% - 10px);
      }

      .dicom-viewports-container.side-by-side .horizontal-line {
        display: none;
      }

      .dicom-viewports-container.stacked {
        flex-direction: column;
      }

      .dicom-viewports-container.stacked .viewport-container {
        width: calc(100% - 40px);
      }

      .dicom-viewports-container.stacked .horizontal-line {
        display: block;
      }
      .custom-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #ffffff;
        padding: 10px 20px;
        color: white;
      }

      .header-logo {
        height: 40px;
        width: auto;
        object-fit: contain;
      }

      /* This pulls the left logo a little to the right */
      .left-logo {
        margin-left: 90px;
      }

      /* This pulls the right logo a little to the left */
      .right-logo {
        margin-right: 125px;
      }

      .header-title {
        flex-grow: 1;
        text-align: center;
        font-size: 1.8rem;
        font-weight: 500;
        white-space: nowrap;
        color: #000000;
      }

      .tree-search {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
      }
      .context-menu {
        position: absolute;
        display: none;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        z-index: 9999;
        min-width: 160px;
        padding: 5px 0;
      }

      /* Cache Progress Popup Styles */
      .cache-progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(2px);
      }

      .cache-progress-modal {
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 500px;
        overflow: hidden;
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .cache-progress-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .cache-progress-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .cache-progress-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
      }

      .cache-progress-close:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .cache-progress-content {
        padding: 30px;
      }

      .cache-progress-bar {
        width: 100%;
        height: 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .cache-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 0%;
      }

      .cache-progress-text {
        text-align: center;
        font-size: 16px;
        color: #495057;
        margin-bottom: 25px;
        font-weight: 500;
      }

      .cache-progress-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .stat-label {
        font-weight: 500;
        color: #6c757d;
        font-size: 14px;
      }

      .stat-value {
        font-weight: 600;
        color: #495057;
        font-size: 16px;
        min-width: 30px;
        text-align: right;
      }
      #combinedFilesContainer {
        width: 20%;
        height: 98%;
        
      }
    </style>
  </head>
  <body>
    <!-- Header -->
    <header class="custom-header">
      <img
        src="static/itsoli-logo-color-full-positive.jpg"
        alt="Left Logo"
        class="header-logo left-logo"
      />
      <span class="header-title">Retinal Image Viewer and File Processor</span>
      <img
        src="static/Kodiak_logo - high res.jpg"
        alt="Right Logo"
        class="header-logo right-logo"
      />
    </header>

    <!-- Left Sidebar Navigation -->
    <div class="sidebar">
      <h2><i class="fas fa-bars"></i></h2>
      <nav>
        <a href="#" id="fileNav" onclick="toggleFileFrame()">Browse</a>
        <a href="#">Edit</a>
        <a href="#">Help</a>
      </nav>
    </div>

    <!-- Right Toolbar -->

    <div class="main-content">
      <!-- DICOM View Section -->
      <div
        id="dicomView"
        style="
          display: none;
          width: 100%;
          flex-direction: column;
          justify-content: center;
          align-items: flex-start;
        "
      >
        <div id="bindSlidersContainer" style="display: none">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 10px;
            "
          >
            <div>
              <input type="checkbox" id="bindSliders" />
              <label for="bindSliders">Bind Sliders</label>
            </div>
            <button class="layout-toggle" onclick="toggleDicomViewportLayout()">
              <i class="fas fa-columns" id="dicomLayoutIcon"></i>
              <span id="dicomLayoutText">Switch to Stacked</span>
            </button>
          </div>
        </div>

        <div class="dicom-viewports-container" id="dicomViewportsContainer">
          <div class="viewport-container">
            <h2 id="viewportTitle1_s3">Viewport 1</h2>
            <div
              class="dicom-prompt"
              id="dicomPrompt1_s3"
              onclick="document.getElementById('dicomFile1_s3').click();"
            >
              Click to upload a DICOM file for Viewport 1
            </div>
            <input
              type="file"
              id="dicomFile1_s3"
              style="display: none"
              onchange="uploadDICOM(1)"
            />
            <img
              id="viewportImage1_s3"
              class="viewport-image-original"
              alt="DICOM Viewport 1"
              data-dicom-file-path=""
            />
            <div class="loader" id="loaderViewport1_s3"></div>
            <div
              class="slider-section"
              id="sliderSection1_s3"
              style="display: none"
            >
              <label for="frameSlider1_s3">Select Frame</label>
              <input
                type="range"
                id="frameSlider1_s3"
                min="0"
                max="100"
                value="0"
              />
              <p id="frameNumber1_s3">Current Frame: 1 of X</p>
            </div>
          </div>

          <div class="horizontal-line"></div>

          <div class="viewport-container">
            <h2 id="viewportTitle2_s3">Viewport 2</h2>
            <div
              class="dicom-prompt"
              id="dicomPrompt2_s3"
              onclick="document.getElementById('dicomFile2_s3').click();"
            >
              Click to upload a DICOM file for Viewport 2
            </div>
            <input
              type="file"
              id="dicomFile2_s3"
              style="display: none"
              onchange="uploadDICOM(2)"
            />
            <img
              id="viewportImage2_s3"
              class="viewport-image-original"
              alt="DICOM Viewport 2"
              data-dicom-file-path=""
            />
            <div class="loader" id="loaderViewport2_s3"></div>
            <div
              class="slider-section"
              id="sliderSection2_s3"
              style="display: none"
            >
              <label for="frameSlider2_s3">Select Frame</label>
              <input
                type="range"
                id="frameSlider2_s3"
                min="0"
                max="100"
                value="0"
              />
              <p id="frameNumber2_s3">Current Frame: 1 of X</p>
            </div>
          </div>
        </div>
      </div>

      <!-- S3 File Browser Section -->
      <div id="fileBrowserContainer" class="file-browser-container">
        <div class="file-browser-layout">
          <!-- Left Panel: S3 Tree Explorer -->
          <div class="tree-panel">
            <div class="s3-header">
              <h3><i class="fas fa-folder-tree"></i> S3 File Browser</h3>
              <div class="s3-selection-controls">
                <button id="selectModeBtn" class="select-mode-btn" onclick="toggleSelectionMode()">
                  <i class="fas fa-check-square"></i> Select
                </button>
                <button id="saveToCache" class="cache-btn" style="display: none;" onclick="saveSelectedToCache()">
                  <i class="fas fa-save"></i> Save to Cache
                </button>
                <button id="cancelSelection" class="cancel-btn" style="display: none;" onclick="cancelSelectionMode()">
                  <i class="fas fa-times"></i> Cancel
                </button>
              </div>
            </div>

            <!-- Navigation -->
            <div class="tree-navigation">
              <button
                id="backButton"
                class="back-button"
                onclick="s3Browser.goBack()"
              >
                <i class="fas fa-arrow-left"></i>
                Back
              </button>
              <span id="currentPath" class="current-path">Root</span>
            </div>

            <!-- Search -->
            <input
              type="text"
              id="treeSearchInput"
              class="tree-search"
              placeholder="Search current folder..."
            />
            <select id="extensionFilter" class="tree-search">
              <option value="">All File Types</option>
              <option value=".dcm">.dcm</option>
              <option value=".dicom">.dicom</option>
              <option value=".e2e">.e2e</option>
              <option value=".fds">.fds</option>
              <option value=".fda">.fda</option>
            </select>

            <!-- Simple Refresh Button -->
            <div class="refresh-controls">
              <button class="refresh-btn" onclick="loadS3Tree()" title="Refresh S3 List">
                <i class="fas fa-sync-alt"></i> Refresh
              </button>
            </div>

            <!-- Tree Container -->
            <div id="fileTreeContainer" class="file-tree-container">
              <div class="tree-loading">
                <div class="loader"></div>
                <span style="margin-left: 10px">Initializing...</span>
              </div>
            </div>
          </div>

          <!-- Right Panel: Dual Viewports -->
          <div class="viewport-panel">
            <h3>
              <span><i class="fas fa-images"></i> Image Viewports</span>
              <div style="display: flex; align-items: center; gap: 10px;">
                <button class="layout-toggle" onclick="toggleViewportLayout()">
                  <i class="fas fa-columns" id="layoutIcon"></i>
                  <span id="layoutText">Switch to Stacked</span>
                </button>
                <div class="eye-focus-menu">
                  <button class="eye-focus-burger" onclick="toggleEyeFocusMenu()">
                    <i class="fas fa-eye"></i>
                    <i class="fas fa-chevron-down"></i>
                  </button>
                  <div class="eye-focus-dropdown-menu" id="eyeFocusDropdownMenu">
                    <div class="eye-focus-item" onclick="focusOnEye('left')">
                      <i class="fas fa-eye"></i>
                       Hide Right viewport
                    </div>
                    <div class="eye-focus-item" onclick="focusOnEye('right')">
                      <i class="fas fa-eye"></i>
                      Hide Left viewport
                    </div>
                  </div>
                </div>
                <button class="reset-button" onclick="resetEyeFocus()">
                  <i class="fas fa-undo"></i>
                  Reset
                </button>
              </div>
            </h3>

            

            <div class="viewports-container" id="viewportsContainer">
              <!-- Viewport 1 -->
              <div class="viewport" id="viewport1">
                <h4>Viewport 1</h4>
                <div class="viewport-content" id="viewportContent1">
                  <div class="viewport-placeholder">
                    Right-click a DICOM file to load here
                  </div>
                  <img
                    id="viewportImage1"
                    class="viewport-image"
                    style="display: none"
                    alt="DICOM Image 1"
                  />
                  <!-- Enhanced Progress Overlay for Viewport 1 -->
                  <div class="progress-overlay" id="progressOverlay1">
                    <div class="progress-content">
                      <div class="progress-circle">
                        <svg class="progress-ring">
                          <circle
                            class="progress-ring-bg"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                          <circle
                            class="progress-ring-fill"
                            id="progressRing1"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                        </svg>
                        <div
                          class="progress-percentage"
                          id="progressPercentage1"
                        >
                          0%
                        </div>
                      </div>
                      <div class="progress-text" id="progressText1">
                        Initializing...
                      </div>
                      <div
                        class="progress-metadata"
                        id="progressMetadata1"
                      ></div>
                      <div class="progress-steps" id="progressSteps1">
                        <div class="progress-step" id="step1_1"></div>
                        <div class="progress-step" id="step2_1"></div>
                        <div class="progress-step" id="step3_1"></div>
                        <div class="progress-step" id="step4_1"></div>
                        <div class="progress-step" id="step5_1"></div>
                      </div>
                      <!-- Cancel Button for Viewport 1 -->
                      <button
                        class="cancel-button"
                        id="cancelButton1"
                        onclick="cancelOperation(1)"
                        style="display: none"
                      >
                        <i class="fas fa-times"></i>
                        Cancel Download
                      </button>
                    </div>
                  </div>
                  <div
                    id="error1"
                    class="error-message"
                    style="display: none"
                  ></div>
                </div>
                <div class="zoom-controls">
                  <button class="zoom-btn" onclick="zoomViewport(1, 0.8)">
                    -
                  </button>
                  <div class="zoom-level" id="zoomLevel1">100%</div>
                  <button class="zoom-btn" onclick="zoomViewport(1, 1.25)">
                    +
                  </button>
                  <button class="zoom-btn" onclick="resetZoom(1)">Reset</button>
                </div>
                <!-- Frame slider for Viewport 1 -->
                <div class="frame-slider-container" id="frameSliderContainer1">
                  <label for="frameSlider1">Frame:</label>
                  <div class="frame-controls">
                    <button class="frame-btn" onclick="previousFrame(1)" title="Previous Frame">
                      <i class="fas fa-minus"></i>
                    </button>
                    <input
                      type="range"
                      id="frameSlider1"
                      class="frame-slider"
                      min="0"
                      max="0"
                      value="0"
                    />
                    <button class="frame-btn" onclick="nextFrame(1)" title="Next Frame">
                      <i class="fas fa-plus"></i>
                    </button>
                  </div>
                  <div class="frame-info" id="frameInfo1">Frame 1 of 1</div>
                  <div class="frame-help">Use ← → arrows or click ± buttons</div>
                </div>

                <!-- Left Eye Tree Structure Container -->
                <div
                  id="leftEyeTreeContainer"
                  class="eye-tree-container"
                  style="display: none"
                >
                  <div class="eye-tree-header">
                    <h5><i class="fas fa-folder-tree"></i> Left Eye Files</h5>
                    <button
                      class="tree-collapse-btn"
                      onclick="toggleEyeTree('left')"
                    >
                      <i class="fas fa-chevron-down"></i>
                    </button>
                  </div>
                  <div class="eye-tree-content" id="leftEyeTreeContent">
                    <div class="tree-placeholder">No files loaded yet...</div>
                  </div>
                </div>
              </div>

              <!-- Viewport 2 -->
              <div class="viewport" id="viewport2">
                <h4>Viewport 2</h4>
                <div class="viewport-content" id="viewportContent2">
                  <div class="viewport-placeholder">
                    Right-click a DICOM file to load here
                  </div>
                  <img
                    id="viewportImage2"
                    class="viewport-image"
                    style="display: none"
                    alt="DICOM Image 2"
                  />
                  <!-- Enhanced Progress Overlay for Viewport 2 -->
                  <div class="progress-overlay" id="progressOverlay2">
                    <div class="progress-content">
                      <div class="progress-circle">
                        <svg class="progress-ring">
                          <circle
                            class="progress-ring-bg"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                          <circle
                            class="progress-ring-fill"
                            id="progressRing2"
                            cx="40"
                            cy="40"
                            r="36"
                          ></circle>
                        </svg>
                        <div
                          class="progress-percentage"
                          id="progressPercentage2"
                        >
                          0%
                        </div>
                      </div>
                      <div class="progress-text" id="progressText2">
                        Initializing...
                      </div>
                      <div
                        class="progress-metadata"
                        id="progressMetadata2"
                      ></div>
                      <div class="progress-steps" id="progressSteps2">
                        <div class="progress-step" id="step1_2"></div>
                        <div class="progress-step" id="step2_2"></div>
                        <div class="progress-step" id="step3_2"></div>
                        <div class="progress-step" id="step4_2"></div>
                        <div class="progress-step" id="step5_2"></div>
                      </div>
                      <!-- Cancel Button for Viewport 2 -->
                      <button
                        class="cancel-button"
                        id="cancelButton2"
                        onclick="cancelOperation(2)"
                        style="display: none"
                      >
                        <i class="fas fa-times"></i>
                        Cancel Download
                      </button>
                    </div>
                  </div>
                  <div
                    id="error2"
                    class="error-message"
                    style="display: none"
                  ></div>
                </div>
                <div class="zoom-controls">
                  <button class="zoom-btn" onclick="zoomViewport(2, 0.8)">
                    -
                  </button>
                  <div class="zoom-level" id="zoomLevel2">100%</div>
                  <button class="zoom-btn" onclick="zoomViewport(2, 1.25)">
                    +
                  </button>
                  <button class="zoom-btn" onclick="resetZoom(2)">Reset</button>
                </div>
                <!-- Frame slider for Viewport 2 -->
                <div class="frame-slider-container" id="frameSliderContainer2">
                  <label for="frameSlider2">Frame:</label>
                  <div class="frame-controls">
                    <button class="frame-btn" onclick="previousFrame(2)" title="Previous Frame">
                      <i class="fas fa-minus"></i>
                    </button>
                    <input
                      type="range"
                      id="frameSlider2"
                      class="frame-slider"
                      min="0"
                      max="0"
                      value="0"
                    />
                    <button class="frame-btn" onclick="nextFrame(2)" title="Next Frame">
                      <i class="fas fa-plus"></i>
                    </button>
                  </div>
                  <div class="frame-info" id="frameInfo2">Frame 1 of 1</div>
                  <div class="frame-help">Use ← → arrows or click ± buttons</div>
                </div>

                <!-- Right Eye Tree Structure Container -->
                <div
                  id="rightEyeTreeContainer"
                  class="eye-tree-container"
                  style="display: none"
                >
                  <div class="eye-tree-header">
                    <h5><i class="fas fa-folder-tree"></i> Right Eye Files</h5>
                    <button
                      class="tree-collapse-btn"
                      onclick="toggleEyeTree('right')"
                    >
                      <i class="fas fa-chevron-down"></i>
                    </button>
                  </div>
                  <div class="eye-tree-content" id="rightEyeTreeContent">
                    <div class="tree-placeholder">No files loaded yet...</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
      <div class="context-menu-item" id="viewport1Option" onclick="loadIntoViewport(1)">
        <i class="fas fa-eye context-menu-icon"></i>
        View in Viewport 1
      </div>
      <div class="context-menu-item" id="viewport2Option" onclick="loadIntoViewport(2)">
        <i class="fas fa-eye context-menu-icon"></i>
        View in Viewport 2
      </div>
      <div
        class="context-menu-item"
        id="loadE2EOption"
        onclick="loadE2EFile()"
        style="display: none"
      >
        <i class="fas fa-eye-low-vision context-menu-icon"></i>
        Load E2E
      </div>
    </div>

    <footer>
      <span>© 2024 Kodiak Sciences Inc - All Rights Reserved.</span>
      <div class="performance-monitor" id="performanceMonitor">
        Performance: Ready
      </div>
    </footer>

    <!-- S3 Credentials Modal -->
    <div id="s3CredentialsModal" class="s3-credentials-modal">
      <div class="s3-credentials-form">
        <h2><i class="fas fa-cloud"></i> AWS S3 Configuration</h2>

        <div
          id="s3ErrorMessage"
          class="s3-error-message"
          style="display: none"
        ></div>
        <div
          id="s3SuccessMessage"
          class="s3-success-message"
          style="display: none"
        ></div>

        <div id="s3LoadingState" class="s3-loading" style="display: none">
          <div class="loader"></div>
          <p>Testing credentials...</p>
        </div>

        <div id="s3FormContent">
          <p style="color: #666; margin-bottom: 20px; text-align: center">
            Please enter your AWS S3 credentials to access the file browser.
          </p>

          <div class="s3-form-group">
            <label for="s3AccessKey">AWS Access Key ID:</label>
            <input
              type="text"
              id="s3AccessKey"
              placeholder="AKIA..."
              required
            />
          </div>

          <div class="s3-form-group">
            <label for="s3SecretKey">AWS Secret Access Key:</label>
            <input
              type="password"
              id="s3SecretKey"
              placeholder="Enter secret key"
              required
            />
          </div>

          <div class="s3-form-group">
            <label for="s3Region">AWS Region:</label>
            <input
              type="text"
              id="s3Region"
              placeholder="us-east-1"
              value="us-east-1"
              required
            />
          </div>

          <div class="s3-form-group">
            <label for="s3Bucket">S3 Bucket Name:</label>
            <input
              type="text"
              id="s3Bucket"
              placeholder="my-dicom-bucket"
              required
            />
          </div>

          <div class="s3-form-checkbox">
            <input type="checkbox" id="s3SaveToEnv" />
            <label for="s3SaveToEnv"
              >Save credentials to .env file (recommended)</label
            >
          </div>

          <div class="s3-form-buttons">
            <button
              type="button"
              class="s3-btn s3-btn-secondary"
              onclick="closeS3Modal()"
            >
              Cancel
            </button>
            <button
              type="button"
              class="s3-btn s3-btn-primary"
              onclick="submitS3Credentials()"
            >
              Connect
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let fileCRCs = {};
      let selectedFilePath = null;
      let selectedTreeItem = null;
      let viewportZoom = { 1: 1, 2: 1 };
      let viewportPan = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 } };
      let isDragging = { 1: false, 2: false };
      let lastMousePos = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 } };
      let viewportData = { 1: null, 2: null };
      let s3TreeData = null;
      let currentFrames = { 1: 0, 2: 0 };
      let totalFrames = { 1: 1, 2: 1 };
      let s3StatusChecked = false;
      let s3ConfiguredStatus = null;
      let isStackedLayout = false;

      // E2E specific variables
      let isE2EMode = false;
      let currentE2EFile = null;
      let focusedEye = null;

      // Global variables for layout states
      let isDicomStackedLayout = true; // Default to stacked for DICOM view

      // Performance monitoring
      let performanceTimers = { 1: null, 2: null };

      // Active downloads tracking for cancellation
      let activeDownloads = new Map();
      let abortControllers = new Map();

      // Define custom sort order for tree structure
      const SORT_ORDER = [
        "SCR",
        "Day 1",
        "Day 2",
        "Day 3",
        "Day 4",
        "Day 5",
        "Day 6",
        "Day 7",
        "Week 1",
        "Week 2",
        "Week 3",
        "Week 4",
        "Week 5",
        "Week 6",
        "Week 7",
        "Week 8",
        "Week 9",
        "Week 10",
        "Week 11",
        "Week 12",
      ];
      // Debounce function to prevent rapid successive calls
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Enhanced function to load DICOM with CRC-based caching and cancellation support
      const loadIntoViewportWithPath = debounce(async function(viewportNumber, filePath) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`,
        );
        const errorDiv = document.getElementById(`error${viewportNumber}`);
        const frameSliderContainer = document.getElementById(
          `frameSliderContainer${viewportNumber}`,
        );

        // Create abort controller for cancellation
        const abortController = new AbortController();
        const operationId = `load_${viewportNumber}_${Date.now()}`;

        // Store operation for cancellation
        activeDownloads.set(operationId, {
          viewportNumber: viewportNumber,
          abortController: abortController,
          filePath: filePath,
        });

        // If loading a non-E2E file, reset E2E mode
        if (isE2EMode && !filePath.toLowerCase().endsWith(".e2e")) {
            resetE2EMode();
            }

        // Set abort controller in progress manager
        progressManagers[viewportNumber].setAbortController(abortController);

        // Initialize cacheSource variable at function scope
        let cacheSource = "unknown";

        // Start performance timer
        startPerformanceTimer(viewportNumber, "File Selection → Image Loaded");

        // Extract file info for metadata
        const fileName = filePath.split("/").pop();
        const fileExt = fileName.split(".").pop()?.toUpperCase() || "UNKNOWN";

        // Show enhanced progress with cancel support
        const progressOperationId = showProgress(
          viewportNumber,
          "Checking cache...",
          {
            File: fileName,
            Type: fileExt,
            Source: "S3",
            Cache: "Checking...",
          },
        );

        // Hide other elements
        if (placeholder) placeholder.style.display = "none";
        img.style.display = "none";
        errorDiv.style.display = "none";
        frameSliderContainer.classList.remove("active");

        try {
          console.log(`Starting DICOM load process for ${filePath}`);

          // Check if operation was cancelled
          if (abortController.signal.aborted) {
            throw new Error("Operation cancelled by user");
          }

          // Step 1: Check if file is already cached (either in memory or disk)
          nextProgressStep(viewportNumber, "Checking cache...", {
            Status: "Cache Check",
            Progress: "Step 1/5",
          });

          // Get file metadata for CRC calculation
          const fileMetadata = {
            path: filePath,
            size: s3Browser.selectedItem?.size || 0,
            lastModified: s3Browser.selectedItem?.last_modified || "",
            frame: 0,
          };

          // Try to load from CRC cache first
          try {
            const cachedResult = await loadImageWithCRC(filePath, fileMetadata);

            // Check if cancelled after cache check
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            if (
              cachedResult.source === "cache" ||
              cachedResult.source === "cache_backend_crc"
            ) {
              // Image loaded from cache - display immediately
              nextProgressStep(viewportNumber, "Loaded from cache!", {
                Status: "Cache Hit",
                Cache: cachedResult.source.toUpperCase(),
                CRC: cachedResult.cacheKey.substring(0, 8),
                Progress: "Step 5/5",
              });

              img.onload = () => {
                console.log(
                  `Cached image loaded successfully for viewport ${viewportNumber}`,
                );
                img.style.display = "block";
                resetZoom(viewportNumber);
                setupImageInteractions(viewportNumber);

                // Set up single frame (cached images are typically single frame)
                totalFrames[viewportNumber] = 1;
                currentFrames[viewportNumber] = 0;
                setupFrameSlider(viewportNumber);

                hideProgress(viewportNumber);
                endPerformanceTimer(
                  viewportNumber,
                  "File Selection → Image Loaded (Cache)",
                );

                // Clean up operation tracking
                activeDownloads.delete(operationId);
              };

              img.src = cachedResult.imageData;
              return;
            }
          } catch (cacheError) {
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }
            console.warn(`Cache check failed: ${cacheError.message}`);
          }

          // Step 2: Check if file needs to be cached first
          let crc = fileCRCs[filePath];
          if (!crc) {
            nextProgressStep(viewportNumber, "Caching file...", {
              Status: "Caching",
              Progress: "Step 2/5",
            });

            try {
              crc = await ensureFileCached(filePath);
            } catch (err) {
              showNotification(err.message, "error");
              hideProgress(viewportNumber);
              return;
            }
          }

          // Step 3: Download and process DICOM from S3 (should use cache if available)
          nextProgressStep(viewportNumber, "Processing request...", {
            Status: "S3 Download",
            Progress: "Step 3/5",
          });

          try {
            const downloadResponse = await fetch(
              `/api/download_dicom_from_s3?path=${encodeURIComponent(filePath)}`,
              {
                signal: abortController.signal,
              },
            );

            if (!downloadResponse.ok) {
              const errorText = await downloadResponse.text();
              console.error("Download response error:", errorText);
              throw new Error(
                `Download failed: ${downloadResponse.status} ${downloadResponse.statusText}`,
              );
            }

            const dicomData = await downloadResponse.json();
            console.log("DICOM data received:", dicomData);

            // Check if cancelled after download
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            // Update cacheSource from response
            cacheSource = dicomData.cache_source || "fresh_download";
            let cacheMessage = "";
            switch (cacheSource) {
              case "memory":
                cacheMessage = "Loaded from memory cache";
                break;
              case "disk":
                cacheMessage = "Loaded from disk cache";
                break;
              case "fresh_download":
                cacheMessage = "Downloaded from S3";
                break;
              default:
                cacheMessage = "Processed";
            }

            // Store DICOM data for this viewport
            viewportData[viewportNumber] = dicomData;
            viewportData[viewportNumber].s3_key = filePath;

            // Step 4: Processing DICOM
            nextProgressStep(viewportNumber, cacheMessage, {
              Status: "Processing",
              Frames: dicomData.number_of_frames || 1,
              Cache: cacheSource.toUpperCase(),
              Progress: "Step 4/5",
            });

            // Step 5: Get frame information and load first frame
            nextProgressStep(viewportNumber, "Loading frame data...", {
              Status: "Frame Analysis",
              Cache: cacheSource.toUpperCase(),
              Progress: "Step 5/5",
            });

            const framesResponse = await fetch(
              `/api/view_frames/${dicomData.dicom_file_path}`,
              {
                signal: abortController.signal,
              },
            );

            if (!framesResponse.ok) {
              throw new Error(
                `Failed to get frame info: ${framesResponse.statusText}`,
              );
            }

            const framesData = await framesResponse.json();
            console.log("Frames data received:", framesData);

            // Check if cancelled after frame info
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            totalFrames[viewportNumber] = framesData.number_of_frames;
            currentFrames[viewportNumber] = 0;

            // Step 6: Auto image display logic
            const isOCT = isOCTDicom(viewportData[viewportNumber]);
            if (isOCT) {
              // Always show the flattened image for OCTs in the selected viewport
              // Do NOT load any original frame for OCTs
              nextProgressStep(viewportNumber, "Applying OCT flattening...", {
                Status: "OCT Processing",
                Type: "OCT Detected",
                Cache: cacheSource.toUpperCase(),
                Progress: "Step 5/5",
              });

              await flattenImageDirectly(viewportNumber);

              // Override frame data to show only flattened version
              totalFrames[viewportNumber] = 1;
              currentFrames[viewportNumber] = 0;
            } else {
              // Load the first frame with CRC caching for non-OCT images
              await loadFrameWithCRC(viewportNumber, 0, abortController);

              nextProgressStep(viewportNumber, "Finalizing...", {
                Status: "Complete",
                Type: "Standard DICOM",
                Cache: cacheSource.toUpperCase(),
                Progress: "Step 5/5",
              });
            }
          } catch (error) {
            if (abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }
            console.error("Fetch error details:", error);
            throw error;
          }

          // Setup frame slider
          setupFrameSlider(viewportNumber);

          // Populate basic tree data for this file in the appropriate eye tree
          const fileName = filePath.split("/").pop();
          const eyeForViewport = viewportNumber === 1 ? "left" : "right";
          const basicTreeData = {
            dicom: [fileName],
            oct: isOCT ? [fileName] : [],
          };
          populateEyeTree(eyeForViewport, basicTreeData);

          // Complete progress
          updateProgress(viewportNumber, 100, "Loading complete!", {
            Status: "Ready",
            Cache: cacheSource.toUpperCase(),
            Loaded: "Success",
          });

          // Hide progress after a brief delay
          setTimeout(() => {
            hideProgress(viewportNumber);
          }, 1000);

          // End performance timer
          endPerformanceTimer(viewportNumber, "File Selection → Image Loaded");

          console.log(
            `Successfully loaded DICOM into viewport ${viewportNumber} from ${cacheSource}`,
          );
        } catch (error) {
          console.error("Error loading DICOM:", error);

          if (error.message.includes("cancelled")) {
            progressManagers[viewportNumber].updateProgress(
              0,
              "Cancelled by user",
            );
            setTimeout(() => {
              hideProgress(viewportNumber);
              if (placeholder) placeholder.style.display = "block";
            }, 1000);
          } else {
            progressManagers[viewportNumber].setError(
              `Error: ${error.message}`,
            );

            setTimeout(() => {
              hideProgress(viewportNumber);
              errorDiv.textContent = `Error: ${error.message}`;
              errorDiv.style.display = "block";
              if (placeholder) placeholder.style.display = "block";
            }, 2000);
          }

          // End performance timer on error
          endPerformanceTimer(
            viewportNumber,
            "File Selection → Image Loaded (ERROR)",
          );
        } finally {
          // Clean up operation tracking
          activeDownloads.delete(operationId);
        }
      }, 300); // 300ms debounce delay

      // Tree structure sorting functions
      function extractSortKey(itemName) {
        if (!itemName) return "";

        const itemUpper = itemName.toUpperCase();

        // Check for SCR
        if (itemUpper.includes("SCR")) {
          return "SCR";
        }

        // Check for Day patterns
        const dayMatch = itemUpper.match(/DAY\s*(\d+)/);
        if (dayMatch) {
          const dayNum = parseInt(dayMatch[1]);
          return `Day ${dayNum}`;
        }

        // Check for Week patterns
        const weekMatch = itemUpper.match(/WEEK\s*(\d+)/);
        if (weekMatch) {
          const weekNum = parseInt(weekMatch[1]);
          return `Week ${weekMatch[1]}`;
        }

        return itemName;
      }

      function customSortKey(item) {
        const name = item && item.name ? item.name : String(item);
        const sortKey = extractSortKey(name);

        // Get position in sort order
        try {
          const position = SORT_ORDER.indexOf(sortKey);
          return position !== -1
            ? [0, position, sortKey]
            : [1, 0, sortKey.toLowerCase()];
        } catch (error) {
          return [1, 0, sortKey.toLowerCase()];
        }
      }

      function sortTreeStructure(items) {
        try {
          // Separate folders and files
          const folders = items.filter((item) => item.type === "folder");
          const files = items.filter((item) => item.type !== "folder");

          // Sort folders and files separately
          const foldersSorted = folders.sort((a, b) => {
            const aKey = customSortKey(a);
            const bKey = customSortKey(b);

            // Compare arrays element by element
            for (let i = 0; i < Math.max(aKey.length, bKey.length); i++) {
              if (aKey[i] === undefined) return -1;
              if (bKey[i] === undefined) return 1;
              if (aKey[i] !== bKey[i]) {
                return typeof aKey[i] === "string"
                  ? aKey[i].localeCompare(bKey[i])
                  : aKey[i] - bKey[i];
              }
            }
            return 0;
          });

          const filesSorted = files.sort((a, b) => {
            const aKey = customSortKey(a);
            const bKey = customSortKey(b);

            // Compare arrays element by element
            for (let i = 0; i < Math.max(aKey.length, bKey.length); i++) {
              if (aKey[i] === undefined) return -1;
              if (bKey[i] === undefined) return 1;
              if (aKey[i] !== bKey[i]) {
                return typeof aKey[i] === "string"
                  ? aKey[i].localeCompare(bKey[i])
                  : aKey[i] - bKey[i];
              }
            }
            return 0;
          });

          // Recursively sort subfolders
          foldersSorted.forEach((folder) => {
            if (folder.children && folder.children.length > 0) {
              folder.children = sortTreeStructure(folder.children);
            }
          });

          // Return folders first, then files
          return [...foldersSorted, ...filesSorted];
        } catch (error) {
          console.error("Error sorting tree structure:", error);
          return items;
        }
      }

      // CRC-based Image Cache System
      class CRCImageCache {
        constructor() {
          this.cache = new Map();
          this.maxCacheSize = 100; // Maximum number of cached images
          this.cacheStats = {
            hits: 0,
            misses: 0,
            evictions: 0,
          };
        }

        // Calculate CRC32 for a given string/buffer
        calculateCRC32(data) {
          const crcTable = new Uint32Array(256);
          for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) {
              c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
            }
            crcTable[i] = c;
          }

          let crc = 0 ^ -1;
          const bytes = new TextEncoder().encode(data);
          for (let i = 0; i < bytes.length; i++) {
            crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xff];
          }
          return ((crc ^ -1) >>> 0).toString(16).padStart(8, "0");
        }

        // Generate cache key from file path and metadata
        generateCacheKey(filePath, metadata = {}) {
          const keyData = JSON.stringify({
            path: filePath,
            size: metadata.size || 0,
            lastModified: metadata.lastModified || "",
            frame: metadata.frame || 0,
          });
          return this.calculateCRC32(keyData);
        }

        // Check if image exists in cache
        has(cacheKey) {
          return this.cache.has(cacheKey);
        }

        // Get image from cache
        get(cacheKey) {
          if (this.cache.has(cacheKey)) {
            const item = this.cache.get(cacheKey);
            // Update access time for LRU
            item.lastAccessed = Date.now();
            this.cacheStats.hits++;
            console.log(`[CACHE HIT] Key: ${cacheKey}`);
            return item;
          }
          this.cacheStats.misses++;
          console.log(`[CACHE MISS] Key: ${cacheKey}`);
          return null;
        }

        // Store image in cache
        set(cacheKey, imageData, metadata = {}) {
          // Evict oldest items if cache is full
          if (this.cache.size >= this.maxCacheSize) {
            this.evictOldest();
          }

          const cacheItem = {
            imageData: imageData,
            metadata: metadata,
            cachedAt: Date.now(),
            lastAccessed: Date.now(),
            cacheKey: cacheKey,
          };

          this.cache.set(cacheKey, cacheItem);
          console.log(`[CACHE SET] Key: ${cacheKey}, Size: ${this.cache.size}`);
        }

        // Evict oldest cache entry
        evictOldest() {
          let oldestKey = null;
          let oldestTime = Date.now();

          for (const [key, item] of this.cache.entries()) {
            if (item.lastAccessed < oldestTime) {
              oldestTime = item.lastAccessed;
              oldestKey = key;
            }
          }

          if (oldestKey) {
            this.cache.delete(oldestKey);
            this.cacheStats.evictions++;
            console.log(`[CACHE EVICT] Key: ${oldestKey}`);
          }
        }

        // Get cache statistics
        getStats() {
          return {
            ...this.cacheStats,
            size: this.cache.size,
            maxSize: this.maxCacheSize,
            hitRate:
              this.cacheStats.hits /
                (this.cacheStats.hits + this.cacheStats.misses) || 0,
          };
        }

        // Clear cache
        clear() {
          this.cache.clear();
          this.cacheStats = { hits: 0, misses: 0, evictions: 0 };
          console.log("[CACHE CLEAR] Cache cleared");
        }
      }

      // Initialize global cache instance
      const imageCache = new CRCImageCache();

      // Enhanced image loading with CRC-based caching and OCT flattening priority
      async function loadImageWithCRC(filePath, metadata = {}) {
        try {
          // For OCT images, check for flattened version first
          if (metadata.isOCT || filePath.toLowerCase().includes("oct")) {
            const flattenMetadata = {
              path: filePath,
              flattened: true,
              frame: metadata.frame || 0,
            };

            const flattenCacheKey = imageCache.generateCacheKey(
              filePath + "_flattened",
              flattenMetadata,
            );
            const cachedFlattened = imageCache.get(flattenCacheKey);

            if (cachedFlattened) {
              console.log(
                `[OCT CACHE] Using cached flattened image for ${filePath}`,
              );
              return {
                imageData: cachedFlattened.imageData,
                source: "cache_flattened",
                cacheKey: flattenCacheKey,
                metadata: cachedFlattened.metadata,
              };
            }
          }

          // Step 1: Generate CRC-based cache key for original image
          const cacheKey = imageCache.generateCacheKey(filePath, metadata);
          console.log(`[CRC CACHE] Generated key: ${cacheKey} for ${filePath}`);

          // Step 2: Check local cache for original image (only for non-OCT)
          if (!metadata.isOCT && !filePath.toLowerCase().includes("oct")) {
            const cachedItem = imageCache.get(cacheKey);
            if (cachedItem) {
              console.log(`[CRC CACHE] Using cached image for ${filePath}`);
              return {
                imageData: cachedItem.imageData,
                source: "cache",
                cacheKey: cacheKey,
                metadata: cachedItem.metadata,
              };
            }
          }

          // Continue with rest of the function...
          // (Keep the existing backend CRC check and download logic)
          // Step 3: Check if backend has CRC info
          let backendCRC = null;
          try {
            const crcResponse = await fetch(
              `/api/get-file-crc?path=${encodeURIComponent(filePath)}`,
            );
            if (crcResponse.ok) {
              const crcData = await crcResponse.json();
              backendCRC = crcData.crc;

              // If backend CRC differs from our calculated CRC, use backend CRC
              if (backendCRC && backendCRC !== cacheKey) {
                const backendCachedItem = imageCache.get(backendCRC);
                if (backendCachedItem) {
                  console.log(
                    `[CRC CACHE] Using backend CRC cached image: ${backendCRC}`,
                  );
                  return {
                    imageData: backendCachedItem.imageData,
                    source: "cache_backend_crc",
                    cacheKey: backendCRC,
                    metadata: backendCachedItem.metadata,
                  };
                }
              }
            }
          } catch (error) {
            console.warn(
              `[CRC CACHE] Could not get backend CRC: ${error.message}`,
            );
          }

          // Step 4: Download image with CRC query parameter for HTTP caching
          const finalCacheKey = backendCRC || cacheKey;
          const imageUrl = `/api/view_dicom_png?frame=${metadata.frame || 0}&dicom_file_path=${encodeURIComponent(metadata.dicomFilePath || filePath)}&v=${finalCacheKey}`;

          console.log(
            `[CRC CACHE] Downloading image with CRC: ${finalCacheKey}`,
          );
          const response = await fetch(imageUrl, {
            headers: {
              "Cache-Control": "public, max-age=31536000, immutable",
            },
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const imageBlob = await response.blob();
          const imageUrl_cached = URL.createObjectURL(imageBlob);

          // Step 5: Store in cache
          const cacheMetadata = {
            ...metadata,
            downloadedAt: Date.now(),
            contentType: response.headers.get("content-type"),
            size: imageBlob.size,
          };

          imageCache.set(finalCacheKey, imageUrl_cached, cacheMetadata);

          return {
            imageData: imageUrl_cached,
            source: "download",
            cacheKey: finalCacheKey,
            metadata: cacheMetadata,
          };
        } catch (error) {
          console.error(`[CRC CACHE] Error loading image: ${error.message}`);
          throw error;
        }
      }

      // Auto image display logic - determine if DICOM is OCT
      // Enhanced OCT detection
      function isOCTDicom(dicomData) {
        if (!dicomData) return false;

        // Check filename patterns
        if (dicomData.s3_key) {
          const filename = dicomData.s3_key.toLowerCase();
          if (filename.includes("oct") || filename.includes("optical")) {
            return true;
          }
        }

        // Check if it's multi-frame (common for OCT)
        if (dicomData.number_of_frames && dicomData.number_of_frames > 1) {
          return true;
        }

        return false;
      }
      function isOCT(dicomData) {
        return isOCTDicom(dicomData);
      }

      // Performance monitoring functions
      function startPerformanceTimer(viewportNumber, operation) {
        performanceTimers[viewportNumber] = {
          start: performance.now(),
          operation: operation,
        };
        updatePerformanceDisplay(`${operation} started...`);
      }

      function endPerformanceTimer(viewportNumber, operation) {
        if (performanceTimers[viewportNumber]) {
          const elapsed =
            performance.now() - performanceTimers[viewportNumber].start;
          const elapsedSeconds = (elapsed / 1000).toFixed(2);
          updatePerformanceDisplay(
            `${operation} completed in ${elapsedSeconds}s`,
          );

          // Log to console for debugging
          console.log(
            `[PERFORMANCE] Viewport ${viewportNumber} - ${operation}: ${elapsedSeconds}s`,
          );

          // Warn if over 7 seconds
          if (elapsed > 7000) {
            console.warn(
              `[PERFORMANCE WARNING] Operation took ${elapsedSeconds}s (target: <7s)`,
            );
          }

          performanceTimers[viewportNumber] = null;
        }
      }

      function updatePerformanceDisplay(message) {
        const monitor = document.getElementById("performanceMonitor");
        if (monitor) {
          monitor.textContent = `Performance: ${message}`;
        }
      }

      // DICOM Layout toggle functionality
      function toggleDicomViewportLayout() {
        const container = document.getElementById("dicomViewportsContainer");
        const icon = document.getElementById("dicomLayoutIcon");
        const text = document.getElementById("dicomLayoutText");

        isDicomStackedLayout = !isDicomStackedLayout;

        if (isDicomStackedLayout) {
          container.classList.remove("side-by-side");
          container.classList.add("stacked");
          icon.className = "fas fa-columns";
          text.textContent = "Switch to Side-by-Side";
        } else {
          container.classList.remove("stacked");
          container.classList.add("side-by-side");
          icon.className = "fas fa-grip-lines";
          text.textContent = "Switch to Stacked";
        }

        console.log(
          `DICOM viewport layout changed to: ${isDicomStackedLayout ? "stacked" : "side-by-side"}`,
        );
      }

      // Update the existing S3 layout toggle to be more specific
      function toggleViewportLayout() {
        // Don't allow layout toggle in focus mode
        if (focusedEye) {
          console.log("Layout toggle disabled in focus mode");
          return;
        }

        const container = document.getElementById("viewportsContainer");
        const icon = document.getElementById("layoutIcon");
        const text = document.getElementById("layoutText");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");

        isStackedLayout = !isStackedLayout;

        // Remove any previous wrappers
        function removeRowWrappers() {
          const leftRow = document.getElementById("leftViewportRow");
          const rightRow = document.getElementById("rightViewportRow");
          if (leftRow) {
            if (viewport1 && leftRow.contains(viewport1)) container.appendChild(viewport1);
            if (leftTreeContainer && leftRow.contains(leftTreeContainer)) viewport1.appendChild(leftTreeContainer);
            leftRow.remove();
          }
          if (rightRow) {
            if (viewport2 && rightRow.contains(viewport2)) container.appendChild(viewport2);
            if (rightTreeContainer && rightRow.contains(rightTreeContainer)) viewport2.appendChild(rightTreeContainer);
            rightRow.remove();
          }
        }

        if (isStackedLayout) {
          container.classList.add("stacked");
          container.style.flexDirection = "column";
          container.style.gap = "8px";
          icon.className = "fas fa-grip-lines";
          text.textContent = "Switch to Side-by-Side";

          // E2E mode: each viewport + its tree in a row (80/20)
          if (isE2EMode) {
            removeRowWrappers();
            // LEFT
            const leftRow = document.createElement("div");
            leftRow.id = "leftViewportRow";
            leftRow.style.display = "flex";
            leftRow.style.flexDirection = "row";
            leftRow.style.width = "95%";
            leftRow.style.height = "540px";
            leftRow.style.gap = "8px";
            leftRow.style.alignItems = "stretch";
            // Set viewport1 styles
            if (viewport1) {
              viewport1.style.width = "80%";
              viewport1.style.flex = "0 0 80%";
              leftRow.appendChild(viewport1);
            }
            if (leftTreeContainer) {
              leftTreeContainer.style.display = "block";
              leftTreeContainer.style.width = "20%";
              leftTreeContainer.style.height = "620px";
              leftTreeContainer.style.maxHeight = "90%";
              leftTreeContainer.style.flex = "0 0 20%";
              leftTreeContainer.style.marginBottom = "0";
              leftTreeContainer.style.marginTop = "10px";
              leftTreeContainer.style.border = "1px solid #e9ecef";
              leftRow.appendChild(leftTreeContainer);
            }
            container.appendChild(leftRow);
            // RIGHT
            const rightRow = document.createElement("div");
            rightRow.id = "rightViewportRow";
            rightRow.style.display = "flex";
            rightRow.style.flexDirection = "row";
            rightRow.style.width = "95%";
            rightRow.style.height = "540px";
            rightRow.style.gap = "8px";
            rightRow.style.alignItems = "stretch";
            if (viewport2) {
              viewport2.style.width = "80%";
              viewport2.style.flex = "0 0 80%";
              rightRow.appendChild(viewport2);
            }
            if (rightTreeContainer) {
              rightTreeContainer.style.display = "block";
              rightTreeContainer.style.width = "20%";
              rightTreeContainer.style.height = "590px";
              rightTreeContainer.style.flex = "0 0 20%";
              rightTreeContainer.style.marginBottom = "0";
              rightTreeContainer.style.maxHeight = "90%";
              rightTreeContainer.style.marginTop = "10px";
              rightTreeContainer.style.border = "1px solid #e9ecef";
              rightRow.appendChild(rightTreeContainer);
            }
            container.appendChild(rightRow);
          } else {
            // For non-E2E mode, use original stacked behavior
            removeRowWrappers();
            if (viewport1) {
              viewport1.style.width = "";
              viewport1.style.flex = "1";
            }
            if (viewport2) {
              viewport2.style.width = "";
              viewport2.style.flex = "1";
            }
            if (leftTreeContainer) leftTreeContainer.style.display = "none";
            if (rightTreeContainer) rightTreeContainer.style.display = "none";
          }
        } else {
          container.classList.remove("stacked");
          container.style.flexDirection = "row";
          icon.className = "fas fa-columns";
          text.textContent = "Switch to Stacked";

          // Clean up E2E stacked wrappers if present
          removeRowWrappers();

          // Reset viewport styles
          if (viewport1) {
            viewport1.style.width = "";
            viewport1.style.flex = "1";
          }
          if (viewport2) {
            viewport2.style.width = "";
            viewport2.style.flex = "1";
          }

          // Show eye trees in side-by-side layout if E2E
          if (leftTreeContainer && isE2EMode) {
            leftTreeContainer.style.display = "block";
            leftTreeContainer.style.width = "";
            leftTreeContainer.style.flex = "";
            leftTreeContainer.style.border = "2px solid #e9ecef";
            leftTreeContainer.style.marginBottom = "";
            leftTreeContainer.style.maxHeight = "300px";
            if (viewport1 && !viewport1.contains(leftTreeContainer)) {
              viewport1.appendChild(leftTreeContainer);
            }
          }
          if (rightTreeContainer && isE2EMode) {
            rightTreeContainer.style.display = "block";
            rightTreeContainer.style.width = "";
            rightTreeContainer.style.flex = "";
            rightTreeContainer.style.border = "2px solid #e9ecef";
            rightTreeContainer.style.maxHeight = "300px";
            if (viewport2 && !viewport2.contains(rightTreeContainer)) {
              viewport2.appendChild(rightTreeContainer);
            }
          }
        }

        console.log(
          `S3 viewport layout changed to: ${isStackedLayout ? "stacked" : "side-by-side"}`,
        );
      }

      // Enhanced Progress Management with Cancel Support
      class ProgressManager {
        constructor(viewportNumber) {
          this.viewportNumber = viewportNumber;
          this.currentStep = 0;
          this.totalSteps = 5;
          this.percentage = 0;
          this.metadata = {};
          this.abortController = null;
          this.operationId = null;
        }

        show(message = "Loading...", metadata = {}, operationId = null) {
          const overlay = document.getElementById(
            `progressOverlay${this.viewportNumber}`,
          );
          const text = document.getElementById(
            `progressText${this.viewportNumber}`,
          );
          const cancelButton = document.getElementById(
            `cancelButton${this.viewportNumber}`,
          );

          if (overlay && text) {
            text.textContent = message;
            overlay.classList.add("active");
            this.updateMetadata(metadata);
            this.updateProgress(0);
            this.currentStep = 0;
            this.updateSteps();

            // Show cancel button if operation can be cancelled
            if (operationId && cancelButton) {
              this.operationId = operationId;
              cancelButton.style.display = "flex";
            } else if (cancelButton) {
              cancelButton.style.display = "none";
            }
          }
        }

        hide() {
          const overlay = document.getElementById(
            `progressOverlay${this.viewportNumber}`,
          );
          const cancelButton = document.getElementById(
            `cancelButton${this.viewportNumber}`,
          );

          if (overlay) {
            overlay.classList.remove("active");
          }

          if (cancelButton) {
            cancelButton.style.display = "none";
          }

          this.operationId = null;
          this.abortController = null;
        }

        updateProgress(percentage, message = null) {
          this.percentage = Math.max(0, Math.min(100, percentage));

          const ring = document.getElementById(
            `progressRing${this.viewportNumber}`,
          );
          const percentageEl = document.getElementById(
            `progressPercentage${this.viewportNumber}`,
          );
          const text = document.getElementById(
            `progressText${this.viewportNumber}`,
          );

          if (ring) {
            const circumference = 226; // 2 * π * 36
            const offset =
              circumference - (this.percentage / 100) * circumference;
            ring.style.strokeDashoffset = offset;
          }

          if (percentageEl) {
            percentageEl.textContent = `${Math.round(this.percentage)}%`;
          }

          if (message && text) {
            text.textContent = message;
          }
        }

        nextStep(message, metadata = {}) {
          this.currentStep = Math.min(this.currentStep + 1, this.totalSteps);
          const stepPercentage = (this.currentStep / this.totalSteps) * 100;
          this.updateProgress(stepPercentage, message);
          this.updateMetadata(metadata);
          this.updateSteps();
        }

        updateMetadata(metadata) {
          this.metadata = { ...this.metadata, ...metadata };
          const container = document.getElementById(
            `progressMetadata${this.viewportNumber}`,
          );

          if (container) {
            container.innerHTML = "";

            Object.entries(this.metadata).forEach(([key, value], index) => {
              if (value) {
                const tag = document.createElement("div");
                tag.className = "metadata-tag";
                tag.textContent = `${key}: ${value}`;
                tag.style.animationDelay = `${index * 0.1}s`;
                container.appendChild(tag);
              }
            });
          }
        }

        updateSteps() {
          for (let i = 1; i <= this.totalSteps; i++) {
            const step = document.getElementById(
              `step${i}_${this.viewportNumber}`,
            );
            if (step) {
              step.classList.remove("active", "completed");
              if (i < this.currentStep) {
                step.classList.add("completed");
              } else if (i === this.currentStep) {
                step.classList.add("active");
              }
            }
          }
        }

        setError(message) {
          this.updateProgress(0, message);
          const ring = document.getElementById(
            `progressRing${this.viewportNumber}`,
          );
          if (ring) {
            ring.style.stroke = "#dc3545";
          }
        }

        setAbortController(controller) {
          this.abortController = controller;
        }

        cancel() {
          if (this.abortController) {
            this.abortController.abort();
            this.updateProgress(0, "Cancelling...");

            setTimeout(() => {
              this.hide();
            }, 1000);
          }
        }
      }

      // Create progress managers for both viewports
      const progressManagers = {
        1: new ProgressManager(1),
        2: new ProgressManager(2),
      };

      // Cancel operation function
      function cancelOperation(viewportNumber) {
        console.log(`Cancelling operation for viewport ${viewportNumber}`);

        if (progressManagers[viewportNumber]) {
          progressManagers[viewportNumber].cancel();
        }

        // Also cancel any active downloads
        for (const [operationId, downloadInfo] of activeDownloads.entries()) {
          if (downloadInfo.viewportNumber === viewportNumber) {
            if (downloadInfo.abortController) {
              downloadInfo.abortController.abort();
            }
            activeDownloads.delete(operationId);
            console.log(`Cancelled download operation: ${operationId}`);
          }
        }
      }

      // Update the existing progress functions
      function showProgress(
        viewportNumber,
        message = "Loading...",
        metadata = {},
      ) {
        const operationId = `operation_${viewportNumber}_${Date.now()}`;
        progressManagers[viewportNumber].show(message, metadata, operationId);
        return operationId;
      }

      function hideProgress(viewportNumber) {
        progressManagers[viewportNumber].hide();
      }

      function updateProgress(
        viewportNumber,
        percentage,
        message = null,
        metadata = {},
      ) {
        progressManagers[viewportNumber].updateProgress(percentage, message);
        // Only include allowed metadata keys
        const allowedKeys = ["File", "Type", "Eye"];
        const filteredMetadata = {};
        for (const key of allowedKeys) {
            if (metadata[key]) filteredMetadata[key] = metadata[key];
        }
        if (Object.keys(filteredMetadata).length > 0) {
            progressManagers[viewportNumber].updateMetadata(filteredMetadata);
        }
      }

      function nextProgressStep(viewportNumber, message, metadata = {}) {
        const allowedKeys = ["File", "Type", "Eye"];
        const filteredMetadata = {};
        for (const key of allowedKeys) {
            if (metadata[key]) filteredMetadata[key] = metadata[key];
        }
        progressManagers[viewportNumber].nextStep(message, filteredMetadata);
      }

      // Toggle between DICOM view and File Browser
      async function toggleFileFrame() {
        const dicomView = document.getElementById("dicomView");
        const fileBrowser = document.getElementById("fileBrowserContainer");

        if (
          fileBrowser.style.display === "none" ||
          fileBrowser.style.display === ""
        ) {
          const s3Ready = await checkS3Status();
          if (!s3Ready) {
            return;
          }

          dicomView.style.display = "none";
          fileBrowser.style.display = "block";
          if (!s3TreeData) {
            loadS3Tree();
          }
        } else {
          fileBrowser.style.display = "none";
          dicomView.style.display = "flex";
        }
      }

      // Enhanced Tree Browser with Drill-down Navigation and Sorting
      class S3TreeBrowser {
        constructor() {
          this.currentPath = [];
          this.currentData = null;
          this.rootData = null;
          this.selectedItem = null;
          this.isLoading = false;
        }

        async initialize() {
          await this.loadRootLevel();
        }

        async loadRootLevel() {
          try {
            this.showLoading();
            console.log("Loading S3 root tree with fastest method...");

            // Always use the fastest method
            const response = await fetch("/api/s3-fast-list?use_parallel=true&auto_prefixes=true&max_workers=10");

            if (response.status === 503) {
              const data = await response.json();
              if (data.needs_credentials) {
                showS3CredentialsModal();
                return;
              }
            }

            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`,
              );
            }

            const data = await response.json();
            console.log("S3 list data received:", data);

            // Handle the new response format
            let files = [];
            if (data.files && Array.isArray(data.files)) {
              files = data.files;
            } else if (Array.isArray(data)) {
              // Fallback for old format
              files = data;
            } else {
              throw new Error("Invalid response format: expected files array");
            }

            // Update performance info display
            updatePerformanceInfo(data);

            // Log performance metrics
            if (data.duration_seconds) {
              console.log(`S3 listing completed in ${data.duration_seconds.toFixed(2)}s`);
              console.log(`Speed: ${data.files_per_second?.toFixed(1) || 'N/A'} files/second`);
              console.log(`Method: ${data.method || 'unknown'}`);
            }

            // Build the tree from flat list and apply sorting
            this.rootData = this.buildTreeFromFlatList(files);
            this.currentData = this.rootData;
            this.currentPath = [];
            this.renderCurrentLevel();
            this.hideLoading();

            // Optional: hide the progress display
            document
              .getElementById("treeProgressBarContainer")
              ?.style?.setProperty("display", "none", "important");
          } catch (error) {
            console.error("Error loading S3 list:", error);
            this.showError(`Failed to load S3 tree: ${error.message}`);
          }
        }

        buildTreeFromFlatList(files) {
          const root = [];

          files.forEach((file) => {
            const parts = file.key.split("/");
            let current = root;

            parts.forEach((part, index) => {
              let node = current.find((n) => n.name === part);
              if (!node) {
                node = {
                  name: part,
                  type: index === parts.length - 1 ? "file" : "folder",
                  ...(index === parts.length - 1
                    ? {
                        size: file.size,
                        last_modified: file.last_modified,
                        path: file.key,
                      }
                    : { children: [] }),
                };
                current.push(node);
              }
              if (node.type === "folder") {
                current = node.children;
              }
            });
          });

          // Apply custom sorting to the entire tree
          return sortTreeStructure(root);
        }

        showLoading() {
          const container = document.getElementById("fileTreeContainer");
          container.innerHTML = `
      <div class="tree-loading">
        <div class="loader"></div>
        <span style="margin-left: 10px;">Loading...</span>
      </div>
    `;
          this.isLoading = true;
        }

        hideLoading() {
          this.isLoading = false;
        }

        showError(message) {
          const container = document.getElementById("fileTreeContainer");
          container.innerHTML = `
      <div class="tree-error">
        <p>${message}</p>
        <button class="retry-button" onclick="s3Browser.loadRootLevel()">Retry</button>
      </div>
    `;
          this.hideLoading();
        }

        renderCurrentLevel() {
          this.updateNavigation();
          this.renderItems();
        }

        renderSearchResults(results) {
          const container = document.getElementById("fileTreeContainer");

          if (!results.length) {
            container.innerHTML =
              '<div class="tree-empty">No matching files or folders found.</div>';
            return;
          }

          // Helper to format bytes to KB/MB/GB
          function formatFileSize(bytes) {
            if (bytes === 0 || bytes == null) return "";
            const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            const size = bytes / Math.pow(1024, i);
            return `${size.toFixed(1)} ${sizes[i]}`;
          }

          const ul = document.createElement("ul");
          ul.className = "file-tree";

          results.forEach((result) => {
            const li = document.createElement("li");
            li.className = "tree-item";
            li.dataset.fullPath = result.path;
            li.dataset.name = result.name;
            li.dataset.type = result.type;

            const iconClass =
              result.type === "folder" ? "fa-folder" : "fa-file";
            const iconColor =
              result.type === "folder" ? "folder-icon" : "file-icon";
            const sizeText =
              result.type === "file" ? formatFileSize(result.size) : "";

            li.innerHTML = `
      <div class="tree-item-content">
        <div class="tree-icon ${iconColor}">
          <i class="fas ${iconClass}"></i>
        </div>
        <div class="tree-item-name">${result.fullPath}</div>
        <div class="tree-item-info">${sizeText}</div>
      </div>
    `;

            // Right-click to show context menu and set selected file
            li.addEventListener("contextmenu", function (e) {
              selectedTreeItem = li;

              // Call the corrected function with the event and file path
              showContextMenu(e, result.path);

              // Highlight selected item
              document
                .querySelectorAll(".tree-item.selected")
                .forEach((el) => el.classList.remove("selected"));
              li.classList.add("selected");
            });

            ul.appendChild(li);
          });

          container.innerHTML = "";
          container.appendChild(ul);
        }

        updateNavigation() {
          const backButton = document.getElementById("backButton");
          const currentPathSpan = document.getElementById("currentPath");

          if (this.currentPath.length > 0) {
            backButton.classList.add("visible");
            currentPathSpan.textContent = this.currentPath.join(" / ");
          } else {
            backButton.classList.remove("visible");
            currentPathSpan.textContent = "Root";
          }
        }

        renderItems() {
          const container = document.getElementById("fileTreeContainer");

          if (!this.currentData || this.currentData.length === 0) {
            container.innerHTML =
              '<div class="tree-empty">No files or folders found</div>';
            return;
          }

          // Apply sorting to current level before rendering
          const sortedData = sortTreeStructure([...this.currentData]);

          const treeList = document.createElement("ul");
          treeList.className = "file-tree";

          sortedData.forEach((item) => {
            const listItem = this.createTreeItem(item, this.currentPath);
            treeList.appendChild(listItem);
          });

          container.innerHTML = "";
          container.appendChild(treeList);

          // Re-apply selection mode if it was active
          if (isSelectionMode) {
            setTimeout(() => {
              addSelectionCheckboxes();
            }, 50);
          }
        }

        // ...inside S3TreeBrowser class...

        createTreeItem(item, parentPath = []) {
          const li = document.createElement("li");

          const treeItem = document.createElement("div");
          treeItem.className = "tree-item";

          // Build full path for this item
          const fullPath = [...parentPath, item.name].join("/");

          // Always set data-full-path for both files and folders
          treeItem.dataset.fullPath = fullPath;
          treeItem.dataset.name = item.name;
          treeItem.dataset.type = item.type;

          // Add appropriate class for ALL items to enable selection
          if (item.type === "file") {
            treeItem.classList.add("file-item");
            treeItem.dataset.filePath = item.path || fullPath;
          } else if (item.type === "folder") {
            treeItem.classList.add("folder-item");
          }

          // === Click behavior (select or expand) ===
          treeItem.onclick = (e) => {
            if (isSelectionMode) {
              handleFileSelection(e);
            } else {
              this.handleItemClick(item, treeItem);
            }
          };

          // === Right-click context menu for FILES only ===
          if (item.type === "file" && item.path) {
            treeItem.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              selectedFilePath = item.path;
              this.selectedItem = item;

              // Clear previous selection and select this item
              document.querySelectorAll(".tree-item.selected").forEach((el) => {
                el.classList.remove("selected");
              });
              treeItem.classList.add("selected");

              showContextMenu(e, item.path);
            });
          }

          // === Content container ===
          const content = document.createElement("div");
          content.className = "tree-item-content";

          // === Expand arrow (only folders) ===
          const arrow = document.createElement("div");
          arrow.className = "expand-arrow collapsed";
          arrow.textContent = item.type === "folder" ? ">" : "";
          if (item.type !== "folder") {
            arrow.style.width = "16px"; // spacer for file rows
          }
          content.appendChild(arrow);

          // === Icon ===
          const icon = document.createElement("span");
          icon.className = "tree-icon";
          icon.innerHTML =
            item.type === "folder"
              ? '<i class="fas fa-folder folder-icon"></i>'
              : '<i class="fas fa-file-medical file-icon"></i>';
          content.appendChild(icon);

          // === Name ===
          const name = document.createElement("span");
          name.className = "tree-item-name";
          name.textContent = item.name || "Unnamed";
          content.appendChild(name);

          // === File size (for files only) ===
          if (item.type === "file" && item.size) {
            const info = document.createElement("span");
            info.className = "tree-item-info";
            info.textContent = this.formatFileSize(item.size);
            content.appendChild(info);
          }

          // === Selection checkbox (for ALL items - files and folders) ===
          const checkbox = document.createElement("div");
          checkbox.className = "selection-checkbox";
          content.appendChild(checkbox);

          // === Tooltip with full filename ===
          const tooltip = document.createElement("div");
          tooltip.className = "tree-item-tooltip";
          tooltip.textContent = item.name || "";

          // === Assemble final node ===
          treeItem.appendChild(content);
          treeItem.appendChild(tooltip);
          li.appendChild(treeItem);

          // If folder, recursively add children (not shown here, handled in renderItems)
          return li;
        }

        async handleItemClick(item, element) {
          if (this.isLoading) return;

          // If in selection mode, don't handle normal item clicking
          if (isSelectionMode) {
            return;
          }

          // Clear previous selection (only in normal mode)
          document.querySelectorAll(".tree-item.selected").forEach((el) => {
            el.classList.remove("selected");
          });

          // Select current item
          element.classList.add("selected");
          this.selectedItem = item;

          if (item.type === "folder") {
            await this.drillIntoFolder(item);
          } else {
            console.log("File selected:", item.path);
            selectedFilePath = item.path;
          }
        }

        async drillIntoFolder(folder) {
          try {
            // Show loading state
            this.showLoading();

            // Update path
            this.currentPath.push(folder.name);

            // Load folder contents (simulate API call or use cached children)
            let folderContents;
            if (folder.children && folder.children.length > 0) {
              folderContents = folder.children;
            } else {
              // In a real implementation, you might make an API call here
              // For now, we'll use the children if available
              folderContents = folder.children || [];
            }

            this.currentData = folderContents;
            this.renderCurrentLevel();
            this.hideLoading();

            console.log(`Drilled into folder: ${this.currentPath.join("/")}`);
          } catch (error) {
            console.error("Error drilling into folder:", error);
            this.showError(`Failed to load folder contents: ${error.message}`);
            // Revert path on error
            this.currentPath.pop();
          }
        }

        goBack() {
          if (this.currentPath.length === 0) return;

          this.currentPath.pop();

          if (this.currentPath.length === 0) {
            // Back to root
            this.currentData = this.rootData;
          } else {
            // Navigate to parent folder
            this.currentData = this.findFolderByPath(this.currentPath);
          }

          this.renderCurrentLevel();
          console.log(
            `Navigated back to: ${this.currentPath.join("/") || "root"}`,
          );
        }

        findFolderByPath(path) {
          let current = this.rootData;

          for (const segment of path) {
            const folder = current.find(
              (item) => item.name === segment && item.type === "folder",
            );
            if (folder && folder.children) {
              current = folder.children;
            } else {
              console.warn("Could not find path:", path);
              return this.rootData;
            }
          }

          return current;
        }

        handleFileRightClick(e, item, element) {
          e.preventDefault();
          e.stopPropagation();

          console.log("Right-click detected on file:", item.path);
          selectedFilePath = item.path;
          this.selectedItem = item;

          // Clear previous selection and select this item
          document.querySelectorAll(".tree-item.selected").forEach((el) => {
            el.classList.remove("selected");
          });
          element.classList.add("selected");

          showContextMenu(e, item);
        }

        formatFileSize(bytes) {
          if (bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i]
          );
        }

        // Search functionality
        search(query) {
          if (!query.trim()) {
            this.renderCurrentLevel();
            return;
          }

          const filteredItems = this.currentData.filter((item) =>
            item.name.toLowerCase().includes(query.toLowerCase()),
          );

          const container = document.getElementById("fileTreeContainer");

          if (filteredItems.length === 0) {
            container.innerHTML =
              '<div class="tree-empty">No matching files found</div>';
            return;
          }

          // Apply sorting to filtered results
          const sortedFilteredItems = sortTreeStructure([...filteredItems]);

          const treeList = document.createElement("ul");
          treeList.className = "file-tree";

          sortedFilteredItems.forEach((item) => {
            const listItem = this.createTreeItem(item);
            treeList.appendChild(listItem);
          });

          container.innerHTML = "";
          container.appendChild(treeList);
        }
      }

      // Global tree search
      function searchS3Tree(query, tree, path = []) {
        const results = [];

        tree.forEach((node) => {
          const fullPath = [...path, node.name];
          if (node.name.toLowerCase().includes(query)) {
            results.push({ ...node, fullPath: fullPath.join("/") });
          }

          if (node.type === "folder" && node.children?.length > 0) {
            results.push(...searchS3Tree(query, node.children, fullPath));
          }
        });

        return results;
      }

      // Initialize the browser
      let s3Browser = new S3TreeBrowser();

      // Selection mode variables
      let isSelectionMode = false;
      let selectedFiles = new Set();
      let cachedFiles = new Map();

      // Load cached files from localStorage
      try {
        const stored = localStorage.getItem('s3CachedFiles');
        if (stored) {
          cachedFiles = new Map(JSON.parse(stored));
        }
      } catch (e) {
        console.error('Error loading cached files:', e);
      }

      function toggleSelectionMode() {
        isSelectionMode = !isSelectionMode;
        selectedFiles.clear();
        
        const selectBtn = document.getElementById('selectModeBtn');
        const saveBtn = document.getElementById('saveToCache');
        const cancelBtn = document.getElementById('cancelSelection');
        
        if (isSelectionMode) {
          selectBtn.innerHTML = '<i class="fas fa-check-square"></i> Selecting...';
          selectBtn.style.backgroundColor = '#ffc107';
          selectBtn.style.color = '#000';
          saveBtn.style.display = 'none';
          cancelBtn.style.display = 'flex';
          
          // Add selection capability to all items
          addSelectionCheckboxes();
          console.log('Selection mode enabled');
        } else {
          cancelSelectionMode();
        }
      }

      function cancelSelectionMode() {
        isSelectionMode = false;
        selectedFiles.clear();
        
        const selectBtn = document.getElementById('selectModeBtn');
        const saveBtn = document.getElementById('saveToCache');
        const cancelBtn = document.getElementById('cancelSelection');
        
        selectBtn.innerHTML = '<i class="fas fa-check-square"></i> Select';
        selectBtn.style.backgroundColor = '#007bff';
        selectBtn.style.color = 'white';
        saveBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        
        // Remove selection styles and checkboxes
        removeSelectionCheckboxes();
        console.log('Selection mode cancelled');
      }

      function addSelectionCheckboxes() {
        // Add selection capability to ALL tree items (files AND folders)
        const allItems = document.querySelectorAll('.tree-item');
        allItems.forEach(item => {
          item.classList.add('file-item-selectable');

          // Show existing checkbox or create one
          let checkbox = item.querySelector('.selection-checkbox');
          if (!checkbox) {
            checkbox = document.createElement('div');
            checkbox.className = 'selection-checkbox';
            const content = item.querySelector('.tree-item-content');
            if (content) {
              content.appendChild(checkbox);
            }
          }
          checkbox.classList.add('visible');

          // Check if this is an E2E file and disable it
          const itemPath = item.dataset.fullPath;
          if (itemPath && itemPath.toLowerCase().endsWith('.e2e')) {
            checkbox.classList.add('disabled');
            checkbox.title = 'E2E files are cached when loaded, not pre-cached';
            checkbox.style.opacity = '0.5';
            checkbox.style.cursor = 'not-allowed';
          } else {
            checkbox.classList.remove('disabled');
            checkbox.title = '';
            checkbox.style.opacity = '1';
            checkbox.style.cursor = 'pointer';
          }

          // Remove any previous handler to avoid duplicates
          checkbox.onclick = null;
          checkbox.addEventListener('click', handleFileSelection);

          // Prevent the row itself from handling selection in selection mode
          // (let it only handle navigation/expand)
          // Remove any previous click handler for selection mode
          if (item._selectionHandlerAdded) {
            item.removeEventListener('click', handleFileSelection);
            item._selectionHandlerAdded = false;
          }
        });
      }

      function removeSelectionCheckboxes() {
        const allItems = document.querySelectorAll('.file-item-selectable');
        allItems.forEach(item => {
          item.classList.remove('file-item-selectable', 'selected');
          const checkbox = item.querySelector('.selection-checkbox');
          if (checkbox) {
            checkbox.classList.remove('visible', 'checked');
          }
          // Remove only the selection handler
          if (item._selectionHandlerAdded) {
            item.removeEventListener('click', handleFileSelection);
            item._selectionHandlerAdded = false;
          }
        });
      }
      //file handelling-- for s3 bucket 

      function handleFileSelection(event) {
        if (!isSelectionMode) return;

        event.stopPropagation();
        event.preventDefault();

        // The checkbox is the event target, get its parent .tree-item
        const checkbox = event.currentTarget;
        
        // Prevent selection of disabled E2E files
        if (checkbox.classList.contains('disabled')) {
          return;
        }
        
        const treeItem = checkbox.closest('.tree-item');
        const itemPath = treeItem.dataset.fullPath;

        if (!itemPath) {
          console.warn('No full path found for item');
          return;
        }

        if (selectedFiles.has(itemPath)) {
          selectedFiles.delete(itemPath);
          treeItem.classList.remove('selected');
          checkbox.classList.remove('checked');
        } else {
          selectedFiles.add(itemPath);
          treeItem.classList.add('selected');
          checkbox.classList.add('checked');
        }

        // Update save button state
        const saveBtn = document.getElementById('saveToCache');
        if (saveBtn) {
          saveBtn.style.display = selectedFiles.size > 0 ? 'flex' : 'none';
          saveBtn.innerHTML = `<i class="fas fa-save"></i> Save to Cache (${selectedFiles.size})`;
        }

        console.log(`Selected items: ${selectedFiles.size}`, [...selectedFiles]);
      }

      // Save selected files to cache and store CRCs with real-time progress
      async function saveSelectedToCache() {
        if (selectedFiles.size === 0) {
          showNotification('Please select files to cache', 'warning');
          return;
        }

        const filePaths = Array.from(selectedFiles);
        const saveBtn = document.getElementById('saveToCache');

        // Show progress popup with streaming support
        showCacheProgressPopup(filePaths.length, true);

        try {
          // Send the file list to start processing with streaming
          const response = await fetch('/api/save-to-cache-stream', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
              files: filePaths
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          // Handle streaming response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  handleCacheProgressUpdate(data);
                } catch (e) {
                  console.error('Error parsing progress data:', e);
                }
              }
            }
          }

          console.log('Caching operation completed');

          // After caching, user must explicitly select a file to view in a viewport.

        } catch (e) {
          hideCacheProgressPopup();
          showNotification('Error saving to cache: ' + e.message, 'error');
        }
      }

      // Handle real-time progress updates from SSE
      function handleCacheProgressUpdate(data) {
        console.log('Progress update:', data);
        
        switch (data.type) {
          case 'progress':
            updateOverallProgress(data.percentage, data.completed, data.total);
            break;
          case 'file_start':
            updateCurrentFile(data.file, data.index, data.total);
            break;
          case 'download_start':
            updateDownloadStatus(data.file, data.message);
            break;
          case 'download_progress':
            updateDownloadProgress(data.file, data.progress, data.downloaded, data.total);
            break;
          case 'download_complete':
            updateDownloadComplete(data.file, data.message);
            break;
          case 'processing_start':
            updateProcessingStatus(data.file, data.message);
            break;
          case 'crc_calculated':
            updateCRCStatus(data.file, data.crc);
            break;
          case 'processing':
            updateProcessingStatus(data.file, data.message);
            break;
          case 'file_complete':
            updateFileComplete(data.file, data.status, data.crc);
            if (data.crc) {
              fileCRCs[data.file] = data.crc;
            }
            break;
          case 'file_error':
            updateFileError(data.file, data.error);
            // Show backend error message in a notification for the user
            showNotification(`Error caching file: ${data.file}\n${data.error}`, 'error');
            break;
          case 'skipped':
            updateFileSkipped(data.file, data.message);
            break;
          case 'complete':
            handleCachingComplete(data.total, data.completed);
            break;
        }
      }

      // Progress popup functions with enhanced real-time updates
      function showCacheProgressPopup(totalFiles, streaming = false) {
        // Remove existing popup if any
        const existingPopup = document.getElementById('cacheProgressPopup');
        if (existingPopup) {
          existingPopup.remove();
        }

        const popup = document.createElement('div');
        popup.id = 'cacheProgressPopup';
        popup.innerHTML = `
          <div class="cache-progress-overlay">
            <div class="cache-progress-modal">
              <div class="cache-progress-header">
                <h3><i class="fas fa-cloud-download-alt"></i> Caching Files</h3>
                <button class="cache-progress-close" onclick="hideCacheProgressPopup()">×</button>
              </div>
              <div class="cache-progress-content">
                <div class="cache-progress-bar">
                  <div class="cache-progress-fill" id="cacheProgressFill"></div>
                </div>
                <div class="cache-progress-text" id="cacheProgressText">Preparing to cache ${totalFiles} files...</div>
                
                <!-- Current file progress -->
                <div class="current-file-section" id="currentFileSection" style="display: none;">
                  <div class="current-file-header">
                    <h4 id="currentFileName">Current File</h4>
                    <span id="currentFileStatus" class="file-status">Preparing...</span>
                  </div>
                  <div class="current-file-progress-bar">
                    <div class="current-file-progress-fill" id="currentFileProgressFill"></div>
                  </div>
                  <div class="current-file-details" id="currentFileDetails"></div>
                </div>
                
                <div class="cache-progress-stats" id="cacheProgressStats">
                  <div class="stat-item">
                    <span class="stat-label">Total:</span>
                    <span class="stat-value">${totalFiles}</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Cached:</span>
                    <span class="stat-value" id="cachedCount">0</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Skipped:</span>
                    <span class="stat-value" id="skippedCount">0</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">Failed:</span>
                    <span class="stat-value" id="failedCount">0</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(popup);
      }

      function updateOverallProgress(percentage, completed, total) {
        const progressFill = document.getElementById('cacheProgressFill');
        const progressText = document.getElementById('cacheProgressText');
        
        if (progressFill) {
          progressFill.style.width = `${percentage}%`;
        }
        
        if (progressText) {
          progressText.textContent = `Overall Progress: ${Math.round(percentage)}% (${completed}/${total})`;
        }
      }

      function updateCurrentFile(file, index, total) {
        const currentFileSection = document.getElementById('currentFileSection');
        const currentFileName = document.getElementById('currentFileName');
        const currentFileStatus = document.getElementById('currentFileStatus');
        
        if (currentFileSection) {
          currentFileSection.style.display = 'block';
        }
        
        if (currentFileName) {
          const fileName = file.split('/').pop();
          currentFileName.textContent = `File ${index}/${total}: ${fileName}`;
        }
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Starting...';
          currentFileStatus.className = 'file-status preparing';
        }
      }

      function updateDownloadStatus(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Downloading...';
          currentFileStatus.className = 'file-status downloading';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
      }

      function updateDownloadProgress(file, progress, downloaded, total) {
        const currentFileProgressFill = document.getElementById('currentFileProgressFill');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileProgressFill) {
          currentFileProgressFill.style.width = `${progress}%`;
        }
        
        if (currentFileDetails) {
          const downloadedMB = (downloaded / (1024 * 1024)).toFixed(2);
          const totalMB = (total / (1024 * 1024)).toFixed(2);
          currentFileDetails.textContent = `Downloading: ${downloadedMB}MB / ${totalMB}MB (${Math.round(progress)}%)`;
        }
      }

      function updateDownloadComplete(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Processing...';
          currentFileStatus.className = 'file-status processing';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
      }

      function updateProcessingStatus(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Processing...';
          currentFileStatus.className = 'file-status processing';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
      }

      function updateCRCStatus(file, crc) {
        const currentFileDetails = document.getElementById('currentFileDetails');
        
        if (currentFileDetails) {
          currentFileDetails.textContent = `CRC calculated: ${crc}`;
        }
      }

      function updateFileComplete(file, status, crc) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        const cachedCount = document.getElementById('cachedCount');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Complete';
          currentFileStatus.className = 'file-status complete';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = `Successfully cached (CRC: ${crc})`;
        }
        
        if (cachedCount) {
          const current = parseInt(cachedCount.textContent) || 0;
          cachedCount.textContent = current + 1;
        }
      }

      function updateFileError(file, error) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        const failedCount = document.getElementById('failedCount');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Failed';
          currentFileStatus.className = 'file-status failed';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = `Error: ${error}`;
        }
        
        if (failedCount) {
          const current = parseInt(failedCount.textContent) || 0;
          failedCount.textContent = current + 1;
        }
      }

      function updateFileSkipped(file, message) {
        const currentFileStatus = document.getElementById('currentFileStatus');
        const currentFileDetails = document.getElementById('currentFileDetails');
        const skippedCount = document.getElementById('skippedCount');
        
        if (currentFileStatus) {
          currentFileStatus.textContent = 'Skipped';
          currentFileStatus.className = 'file-status skipped';
        }
        
        if (currentFileDetails) {
          currentFileDetails.textContent = message;
        }
        
        if (skippedCount) {
          const current = parseInt(skippedCount.textContent) || 0;
          skippedCount.textContent = current + 1;
        }
      }

      function handleCachingComplete(total, completed) {
        const progressText = document.getElementById('cacheProgressText');
        const currentFileSection = document.getElementById('currentFileSection');
        
        if (progressText) {
          progressText.textContent = 'Caching complete!';
        }
        
        if (currentFileSection) {
          currentFileSection.style.display = 'none';
        }
        
        // Update save button
          const saveBtn = document.getElementById('saveToCache');
        if (saveBtn) {
          saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved!';
          saveBtn.style.backgroundColor = '#28a745';
          setTimeout(() => {
            saveBtn.innerHTML = `<i class="fas fa-save"></i> Save to Cache`;
            saveBtn.style.backgroundColor = '#28a745';
          }, 2000);
        }

        // Clear selection
          selectedFiles.clear();
          removeSelectionCheckboxes();
          addSelectionCheckboxes();
        if (saveBtn) {
          saveBtn.style.display = 'none';
        }
        
        // Auto-hide popup after completion
        setTimeout(() => {
          hideCacheProgressPopup();
        }, 3000);
      }

      function hideCacheProgressPopup() {
        const popup = document.getElementById('cacheProgressPopup');
        if (popup) {
          popup.remove();
        }
      }

      // Notification system to replace alerts
      function showNotification(message, type = 'info', duration = 5000) {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.notification');
        existingNotifications.forEach(notification => notification.remove());

        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
          <div class="notification-content">
            <span class="notification-message">${message}</span>
            <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
          </div>
        `;

        // Add styles if not already present
        if (!document.getElementById('notification-styles')) {
          const style = document.createElement('style');
          style.id = 'notification-styles';
          style.textContent = `
            .notification {
              position: fixed;
              top: 20px;
              right: 20px;
              z-index: 10000;
              max-width: 400px;
              border-radius: 8px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
              animation: slideIn 0.3s ease-out;
            }
            .notification-info {
              background: #e3f2fd;
              border: 1px solid #2196f3;
              color: #1976d2;
            }
            .notification-warning {
              background: #fff3e0;
              border: 1px solid #ff9800;
              color: #f57c00;
            }
            .notification-error {
              background: #ffebee;
              border: 1px solid #f44336;
              color: #d32f2f;
            }
            .notification-success {
              background: #e8f5e8;
              border: 1px solid #4caf50;
              color: #388e3c;
            }
            .notification-content {
              padding: 12px 16px;
              display: flex;
              align-items: center;
              justify-content: space-between;
            }
            .notification-message {
              flex: 1;
              margin-right: 8px;
            }
            .notification-close {
              background: none;
              border: none;
              font-size: 18px;
              cursor: pointer;
              color: inherit;
              opacity: 0.7;
            }
            .notification-close:hover {
              opacity: 1;
            }
            @keyframes slideIn {
              from { transform: translateX(100%); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
            }
          `;
          document.head.appendChild(style);
        }

        document.body.appendChild(notification);

        // Auto-remove after duration
        setTimeout(() => {
          if (notification.parentElement) {
            notification.remove();
          }
        }, duration);
      }

      function reviewCachedFiles() {
        const cached = [...cachedFiles.entries()];
        console.log('Cached items:', cached);
        
        // Display cached items in a more user-friendly way
        const cacheDisplay = cached.map(([path, data]) => ({
          path: path,
          type: data.type,
          cachedAt: new Date(data.cachedAt).toLocaleString()
        }));
        
        console.table(cacheDisplay);
        return cached;
      }

      // Show selection controls when S3 browser is loaded
      document.addEventListener('DOMContentLoaded', () => {
        const controls = document.querySelector('.s3-selection-controls');
        if (controls) {
          controls.style.display = 'flex';
          document.getElementById('selectModeBtn').style.display = 'block';
        }
      });

      // Update search event listener
      function runTreeSearch() {
        const query = document
          .getElementById("treeSearchInput")
          .value.toLowerCase()
          .trim();
        const extension = document.getElementById("extensionFilter").value;

        if (!query && !extension) {
          s3Browser.renderCurrentLevel(); // Show default tree
          return;
        }

        let results = searchS3Tree(query, s3Browser.rootData || []);

        if (extension) {
          results = results.filter(
            (item) =>
              item.type === "file" &&
              item.name.toLowerCase().endsWith(extension),
          );
        }

        s3Browser.renderSearchResults(results);
      }

      document
        .getElementById("treeSearchInput")
        .addEventListener("input", runTreeSearch);
      document
        .getElementById("extensionFilter")
        .addEventListener("change", runTreeSearch);

      // Replace the existing loadS3Tree function with:
      async function loadS3Tree() {
        s3Browser.showLoading();
        try {
          // Always use the fastest method
          const response = await fetch("/api/s3-fast-list?use_parallel=true&auto_prefixes=true&max_workers=10");
          const data = await response.json();

          // Handle the new response format
          let files = [];
          if (data.files && Array.isArray(data.files)) {
            files = data.files;
          } else if (Array.isArray(data)) {
            // Fallback for old format
            files = data;
          } else {
            throw new Error("Invalid S3 response format");
          }

          // Log performance metrics
          if (data.duration_seconds) {
            console.log(`S3 listing completed in ${data.duration_seconds.toFixed(2)}s`);
            console.log(`Speed: ${data.files_per_second?.toFixed(1) || 'N/A'} files/second`);
            console.log(`Method: ${data.method || 'unknown'}`);
          }

          // Convert flat list to tree with sorting
          const treeData = s3Browser.buildTreeFromFlatList(files);
          s3Browser.rootData = treeData;
          s3Browser.currentData = treeData;
          s3Browser.currentPath = [];
          s3Browser.renderCurrentLevel();
          s3Browser.hideLoading();
        } catch (err) {
          console.error("Failed to load S3 list:", err);
          s3Browser.showError("Failed to load S3 file list. " + err.message);
        }
      }



      // Initialize on page load
      document.addEventListener("DOMContentLoaded", () => {
        // Initialize zoom displays
        updateZoomDisplay(1);
        updateZoomDisplay(2);

        // Initialize DICOM viewport layout (default to stacked)
        const dicomContainer = document.getElementById(
          "dicomViewportsContainer",
        );
        if (dicomContainer) {
          dicomContainer.classList.add("stacked");
        }

        // Initialize S3 viewport layout (default to side-by-side)
        const s3Container = document.getElementById("viewportsContainer");
        if (s3Container) {
          s3Container.classList.remove("stacked");
        }

        console.log("Application initialized with layout controls and sorting");
      });

      // Original functions for DICOM upload (keeping for compatibility)
      const crcTable = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
          c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
        }
        crcTable[i] = c;
      }

      // Calculate CRC32 from string (for frontend use)
      function calculateCRC32FromString(str) {
        let crc = 0 ^ -1;
        const bytes = new TextEncoder().encode(str);
        for (let i = 0; i < bytes.length; i++) {
          crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xff];
        }
        return ((crc ^ -1) >>> 0).toString(16).padStart(8, "0");
      }

      async function calculateFileCRC32(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            const buffer = e.target.result;
            const array = new Uint8Array(buffer);
            let crc = 0 ^ -1;
            for (let i = 0; i < array.length; i++) {
              crc = (crc >>> 8) ^ crcTable[(crc ^ array[i]) & 0xff];
            }
            const crcValue = ((crc ^ -1) >>> 0).toString(16).padStart(8, "0");
            resolve(crcValue);
          };
          reader.onerror = reject;
          reader.readAsArrayBuffer(file);
        });
      }

      async function uploadDICOM(viewportNumber) {
        const fileInput = document.getElementById(
          "dicomFile" + viewportNumber + "_s3",
        );
        if (fileInput.files.length === 0) return;

        const file = fileInput.files[0];
        console.log(
          "Uploading DICOM file:",
          file.name,
          "to viewport:",
          viewportNumber,
        );
      }

      // Toolbar functionality
      document
        .getElementById("e2eToDicomConverter")
        .addEventListener("click", async function () {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".e2e";
          fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            console.log("Converting E2E file:", file.name);
          };
          fileInput.click();
        });

      document
        .getElementById("dicomMetadataExtractorTool")
        .addEventListener("click", async function () {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".dcm";
          fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            console.log("Extracting metadata from:", file.name);
          };
          fileInput.click();
        });

      // S3 Credentials Management
      async function checkS3Status() {
        if (s3StatusChecked && s3ConfiguredStatus !== null) {
          if (
            !s3ConfiguredStatus.configured &&
            s3ConfiguredStatus.needs_credentials
          ) {
            showS3CredentialsModal();
            return false;
          }
          return true;
        }

        try {
          const response = await fetch("/api/s3-status");
          const status = await response.json();

          s3StatusChecked = true;
          s3ConfiguredStatus = status;

          if (!status.configured && status.needs_credentials) {
            showS3CredentialsModal();
            return false;
          }
          return true;
        } catch (error) {
          console.error("Error checking S3 status:", error);
          s3StatusChecked = true;
          s3ConfiguredStatus = { configured: false, needs_credentials: true };
          showS3CredentialsModal();
          return false;
        }
      }

      function showS3CredentialsModal() {
        document.getElementById("s3CredentialsModal").style.display = "flex";
        document.getElementById("s3ErrorMessage").style.display = "none";
        document.getElementById("s3SuccessMessage").style.display = "none";
      }

      function closeS3Modal() {
        document.getElementById("s3CredentialsModal").style.display = "none";
      }

      async function submitS3Credentials() {
        const accessKey = document.getElementById("s3AccessKey").value.trim();
        const secretKey = document.getElementById("s3SecretKey").value.trim();
        const region = document.getElementById("s3Region").value.trim();
        const bucket = document.getElementById("s3Bucket").value.trim();
        const saveToEnv = document.getElementById("s3SaveToEnv").checked;

        if (!accessKey || !secretKey || !region || !bucket) {
          showS3Error("Please fill in all fields.");
          return;
        }

        document.getElementById("s3FormContent").style.display = "none";
        document.getElementById("s3LoadingState").style.display = "block";
        document.getElementById("s3ErrorMessage").style.display = "none";

        try {
          const response = await fetch("/api/set-s3-credentials", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              accessKey: accessKey,
              secretKey: secretKey,
              region: region,
              bucket: bucket,
              saveToEnv: saveToEnv,
            }),
          });

          const result = await response.json();

          if (response.ok) {
            showS3Success(
              result.message +
                (result.saved_to_env ? " Credentials saved to .env file." : ""),
            );

            s3StatusChecked = false;
            s3ConfiguredStatus = null;
            s3TreeData = null;

            setTimeout(() => {
              closeS3Modal();
              loadS3Tree();
            }, 2000);
          } else {
            throw new Error(result.error || "Failed to set credentials");
          }
        } catch (error) {
          console.error("Error setting S3 credentials:", error);
          showS3Error("Error: " + error.message);
        } finally {
          document.getElementById("s3LoadingState").style.display = "none";
          document.getElementById("s3FormContent").style.display = "block";
        }
      }

      function showS3Error(message) {
        const errorDiv = document.getElementById("s3ErrorMessage");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        document.getElementById("s3SuccessMessage").style.display = "none";
      }

      function showS3Success(message) {
        const successDiv = document.getElementById("s3SuccessMessage");
        successDiv.textContent = message;
        successDiv.style.display = "block";
        document.getElementById("s3ErrorMessage").style.display = "none";
      }

      // Add responsive resize handler
      window.addEventListener("resize", () => {
        // Recalculate constraints for both viewports
        for (let viewportNumber of [1, 2]) {
          if (viewportData[viewportNumber]) {
            updateImageTransform(viewportNumber);
          }
        }
      });

      // Show context menu
      function showContextMenu(event, filePath) {
        // Prevent the default browser context menu
        event.preventDefault();

        // Set the selected file path for menu actions
        selectedFilePath = filePath;

        const contextMenu = document.getElementById("contextMenu");
        const loadE2EOption = document.getElementById("loadE2EOption");
        const viewport1Option = document.getElementById("viewport1Option");
        const viewport2Option = document.getElementById("viewport2Option");
        if (!contextMenu) return;

        // Show/hide options based on file extension
        const isE2EFile = filePath && filePath.toLowerCase().endsWith(".e2e");
        
        if (loadE2EOption) {
          loadE2EOption.style.display = isE2EFile ? "block" : "none";
        }
        
        if (viewport1Option) {
          viewport1Option.style.display = isE2EFile ? "none" : "block";
        }
        
        if (viewport2Option) {
          viewport2Option.style.display = isE2EFile ? "none" : "block";
        }

        // Make the menu visible to measure its dimensions
        contextMenu.style.display = "block";
        const menuWidth = contextMenu.offsetWidth;
        const menuHeight = contextMenu.offsetHeight;

        const pageWidth = window.innerWidth;
        const pageHeight = window.innerHeight;

        // Get cursor position from the event object
        let x = event.pageX;
        let y = event.pageY;

        // Adjust position if the menu would go off-screen
        if (x + menuWidth > pageWidth) {
          x = pageWidth - menuWidth - 10; // Add a small margin
        }
        if (y + menuHeight > pageHeight) {
          y = pageHeight - menuHeight - 10; // Add a small margin
        }

        // Apply the calculated position
        contextMenu.style.left = `${x}px`;
        contextMenu.style.top = `${y}px`;
      }

      document
        .getElementById("fileTreeContainer")
        .addEventListener("contextmenu", (e) => {
          // Find the nearest .tree-item element
          const treeItem = e.target.closest(".tree-item");

          // Ensure it's a file item with a path
          if (!treeItem || !treeItem.dataset.filePath) {
            return;
          }

          // Get the file path from the data attribute
          const filePath = treeItem.dataset.filePath;

          // Call our standardized function to show the menu
          showContextMenu(e, filePath);

          // Optional: Highlight the selected item
          document
            .querySelectorAll(".tree-item.selected")
            .forEach((el) => el.classList.remove("selected"));
          if (treeItem.parentElement.matches("li.tree-item")) {
            // check if it's the li or the div inside it
            treeItem.parentElement.classList.add("selected");
          } else {
            treeItem.classList.add("selected");
          }
        });

      // Hide context menu on click outside
      document.addEventListener("click", (e) => {
        const menu = document.getElementById("contextMenu");
        if (!menu) return;
        if (!menu.contains(e.target)) {
          menu.style.display = "none";
        }
      });

      // Load DICOM image into viewport from context menu
        async function loadIntoViewport(viewportNumber) {
            if (!selectedFilePath) {
                        console.error("No file path selected");
        showNotification("Please select a DICOM file first.", "warning");
        return;
            }

            // Show progress bar right away
            showProgress(
                viewportNumber,
                "Preparing to load...",
                { File: selectedFilePath.split("/").pop() }
            );

            document.getElementById("contextMenu").style.display = "none";

            try {
                await loadIntoViewportWithPath(viewportNumber, selectedFilePath);
            } catch (error) {
                console.error("Error in loadIntoViewport:", error);
                showNotification(`Error loading file: ${error.message}`, "error");
                hideProgress(viewportNumber);
            }
     }
      //ensurefilechached 

      async function ensureFileCached(filePath) {
        let crc = fileCRCs[filePath];
        if (!crc) {
          // First check if the file is already cached in the backend
          try {
            const checkResponse = await fetch(`/api/download_dicom_from_s3?path=${encodeURIComponent(filePath)}`);
            if (checkResponse.ok) {
              const checkData = await checkResponse.json();
              if (checkData.cache_source === "memory" || checkData.cache_source === "disk") {
                // File is already cached, get the CRC from the response
                console.log(`File ${filePath} is already cached (${checkData.cache_source})`);
                // Generate a CRC for this file path to store locally
                const pathCRC = calculateCRC32FromString(filePath);
                fileCRCs[filePath] = pathCRC;
                return pathCRC;
              }
            }
          } catch (error) {
            console.warn(`Could not check if file is cached: ${error.message}`);
          }

          // Not cached, so cache it now
          const response = await fetch('/api/save-to-cache', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: [filePath] }),
          });
          const data = await response.json();
          const result = data.results && data.results.find(r => r.file === filePath && r.status === "cached");
          if (result && result.crc) {
            fileCRCs[filePath] = result.crc;
            crc = result.crc;
          } else {
            throw new Error("Failed to cache file for viewing.");
          }
        }
        return crc;
      }

      

      // Enhanced frame loading with CRC caching and cancellation support
      async function loadFrameWithCRC(
        viewportNumber,
        frameNumber,
        abortController = null,
      ) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const data = viewportData[viewportNumber];

        if (!data) {
          console.error("No DICOM data available for viewport", viewportNumber);
          return;
        }

        try {
          console.log(
            `Loading frame ${frameNumber} for viewport ${viewportNumber} with CRC caching`,
          );

          // Check if operation was cancelled
          if (abortController && abortController.signal.aborted) {
            throw new Error("Operation cancelled by user");
          }

          // Create metadata for this specific frame
          const frameMetadata = {
            path: data.s3_key,
            dicomFilePath: data.dicom_file_path,
            frame: frameNumber,
            size: data.size || 0,
            lastModified: data.last_modified || "",
          };

          // Try CRC cache first
          try {
            const cachedResult = await loadImageWithCRC(
              data.s3_key,
              frameMetadata,
            );

            // Check if cancelled after cache check
            if (abortController && abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }

            img.onload = () => {
              console.log(
                `Frame ${frameNumber} loaded successfully with CRC caching (${cachedResult.source})`,
              );
              img.style.display = "block";
              img.style.maxWidth = "100%";
              img.style.maxHeight = "100%";
              img.style.width = "auto";
              img.style.height = "auto";

              resetZoom(viewportNumber);
              setupImageInteractions(viewportNumber);
              updateFrameInfo(viewportNumber, frameNumber);
            };

            img.onerror = () => {
              console.error(
                `Failed to load cached image for frame ${frameNumber}`,
              );
              throw new Error("Failed to load cached image");
            };

            img.src = cachedResult.imageData;
            currentFrames[viewportNumber] = frameNumber;

            console.log(
              `Frame ${frameNumber} loaded from ${cachedResult.source} with CRC: ${cachedResult.cacheKey.substring(0, 8)}`,
            );
            return;
          } catch (cacheError) {
            if (abortController && abortController.signal.aborted) {
              throw new Error("Operation cancelled by user");
            }
            console.warn(
              `CRC cache failed for frame ${frameNumber}: ${cacheError.message}`,
            );
            // Fall back to original method
          }

          // Fallback to original PNG endpoint
          const fetchOptions = abortController
            ? { signal: abortController.signal }
            : {};
          const pngResponse = await fetch(
            `/api/view_dicom_png?frame=${frameNumber}&dicom_file_path=${encodeURIComponent(data.dicom_file_path)}&v=${Date.now()}`,
            fetchOptions,
          );

          if (!pngResponse.ok) {
            throw new Error(`Failed to get PNG: ${pngResponse.statusText}`);
          }

          const pngBlob = await pngResponse.blob();
          const pngUrl = URL.createObjectURL(pngBlob);

          // Check if cancelled after download
          if (abortController && abortController.signal.aborted) {
            throw new Error("Operation cancelled by user");
          }

          // Cache this frame for future use
          try {
            imageCache.set(
              imageCache.generateCacheKey(data.s3_key, frameMetadata),
              pngUrl,
              frameMetadata,
            );
          } catch (cacheSetError) {
            console.warn(
              `Failed to cache frame ${frameNumber}: ${cacheSetError.message}`,
            );
          }

          // Display the image with proper constraints
          img.onload = () => {
            console.log(
              `Image loaded successfully for viewport ${viewportNumber} (fallback method)`,
            );
            img.style.display = "block";
            img.style.maxWidth = "100%";
            img.style.maxHeight = "100%";
            img.style.width = "auto";
            img.style.height = "auto";

            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
            updateFrameInfo(viewportNumber, frameNumber);
          };

          img.onerror = () => {
            console.error(`Failed to load image for frame ${frameNumber}`);
            throw new Error("Failed to load image");
          };

          img.src = pngUrl;
          currentFrames[viewportNumber] = frameNumber;
        } catch (error) {
          console.error("Error loading frame:", error);
          throw error;
        }
      }

      // Load specific frame (updated to use CRC caching)
      async function loadFrame(viewportNumber, frameNumber) {
        return await loadFrameWithCRC(viewportNumber, frameNumber);
      }

      // Setup frame slider - enhanced for OCT frame navigation
      function setupFrameSlider(viewportNumber) {
        console.log(`Setting up frame slider for viewport ${viewportNumber}`);

        const frameSlider = document.getElementById(
          `frameSlider${viewportNumber}`,
        );
        const frameSliderContainer = document.getElementById(
          `frameSliderContainer${viewportNumber}`,
        );
        const data = viewportData[viewportNumber];

        if (!frameSlider || !frameSliderContainer) {
          console.error(
            "Frame slider elements not found for viewport",
            viewportNumber,
          );
          return;
        }

        // Hide frame slider for flattened OCT images (legacy behavior)
        if (data && data.isFlattened && !data.octFrameMode) {
          frameSliderContainer.classList.remove("active");
          console.log(
            `Frame slider hidden for flattened OCT image in viewport ${viewportNumber}`,
          );
          return;
        }

        const numFrames = totalFrames[viewportNumber];

        frameSlider.min = 0;
        frameSlider.max = Math.max(0, numFrames - 1);
        frameSlider.value = currentFrames[viewportNumber] || 0;

        frameSlider.onchange = null;
        frameSlider.oninput = null;

        if (numFrames <= 1) {
          frameSlider.disabled = true;
          console.log(
            `Single-frame content detected for viewport ${viewportNumber}, slider disabled`,
          );
        } else {
          frameSlider.disabled = false;
          frameSlider.oninput = async (e) => {
            const frameNumber = parseInt(e.target.value);
            console.log(
              `Frame slider changed to ${frameNumber} for viewport ${viewportNumber}`,
            );
            try {
              // Check if we're in OCT frame mode
              if (data && data.octFrameMode) {
                await loadOCTFrameFromSlider(viewportNumber, frameNumber);
              } else {
                await loadFrame(viewportNumber, frameNumber);
              }
            } catch (error) {
              console.error("Error loading frame from slider:", error);
            }
          };
        }

        frameSliderContainer.classList.add("active");
        updateFrameInfo(viewportNumber, currentFrames[viewportNumber] || 0);

        console.log(
          `Frame slider setup complete for viewport ${viewportNumber}, ${numFrames} frame(s), OCT mode: ${data?.octFrameMode || false}`,
        );
        
        // Update button states
        updateFrameButtonStates(viewportNumber);
      }

      // Update frame button states (enable/disable based on current frame)
      function updateFrameButtonStates(viewportNumber) {
        const data = viewportData[viewportNumber];
        const currentFrame = currentFrames[viewportNumber] || 0;
        const totalFramesCount = totalFrames[viewportNumber] || 0;
        
        const prevBtn = document.querySelector(`#frameSliderContainer${viewportNumber} .frame-btn:first-child`);
        const nextBtn = document.querySelector(`#frameSliderContainer${viewportNumber} .frame-btn:last-child`);
        
        if (prevBtn) {
          prevBtn.disabled = currentFrame <= 0;
        }
        
        if (nextBtn) {
          nextBtn.disabled = currentFrame >= totalFramesCount - 1;
        }
      }

      // Navigate to previous frame
      async function previousFrame(viewportNumber) {
        const data = viewportData[viewportNumber];
        const currentFrame = currentFrames[viewportNumber] || 0;
        const totalFramesCount = totalFrames[viewportNumber] || 0;
        
        if (currentFrame <= 0) {
          console.log(`Already at first frame for viewport ${viewportNumber}`);
          return;
        }
        
        const newFrame = currentFrame - 1;
        console.log(`Navigating to previous frame: ${newFrame} for viewport ${viewportNumber}`);
        
        try {
          // Check if we're in OCT frame mode
          if (data && data.octFrameMode) {
            await loadOCTFrameFromSlider(viewportNumber, newFrame);
          } else {
            await loadFrame(viewportNumber, newFrame);
          }
          
          // Update slider value
          const frameSlider = document.getElementById(`frameSlider${viewportNumber}`);
          if (frameSlider) {
            frameSlider.value = newFrame;
          }
          
          // Update button states
          updateFrameButtonStates(viewportNumber);
          
        } catch (error) {
          console.error(`Error navigating to previous frame:`, error);
        }
      }

      // Navigate to next frame
      async function nextFrame(viewportNumber) {
        const data = viewportData[viewportNumber];
        const currentFrame = currentFrames[viewportNumber] || 0;
        const totalFramesCount = totalFrames[viewportNumber] || 0;
        
        if (currentFrame >= totalFramesCount - 1) {
          console.log(`Already at last frame for viewport ${viewportNumber}`);
          return;
        }
        
        const newFrame = currentFrame + 1;
        console.log(`Navigating to next frame: ${newFrame} for viewport ${viewportNumber}`);
        
        try {
          // Check if we're in OCT frame mode
          if (data && data.octFrameMode) {
            await loadOCTFrameFromSlider(viewportNumber, newFrame);
          } else {
            await loadFrame(viewportNumber, newFrame);
          }
          
          // Update slider value
          const frameSlider = document.getElementById(`frameSlider${viewportNumber}`);
          if (frameSlider) {
            frameSlider.value = newFrame;
          }
          
          // Update button states
          updateFrameButtonStates(viewportNumber);
          
        } catch (error) {
          console.error(`Error navigating to next frame:`, error);
        }
      }

      // Update frame info display
      function updateFrameInfo(viewportNumber, frameNumber) {
        const frameInfo = document.getElementById(`frameInfo${viewportNumber}`);
        if (frameInfo) {
          const data = viewportData[viewportNumber];
          const totalFramesCount = totalFrames[viewportNumber];
          
          if (data && data.octFrameMode) {
            // Show OCT frame specific info
            const frameType = data.octFrameType || "original";
            const eye = data.octFrameEye || "unknown";
            frameInfo.textContent = `OCT ${frameType} - ${eye} eye - Frame ${frameNumber + 1} of ${totalFramesCount}`;
          } else {
            // Show regular frame info
            frameInfo.textContent = `Frame ${frameNumber + 1} of ${totalFramesCount}`;
          }
        }
        
        // Update button states when frame info changes
        updateFrameButtonStates(viewportNumber);
      }

      // Enhanced flatten function that caches only the flattened result for OCT images
      async function flattenImageDirectly(viewportNumber) {
        const data = viewportData[viewportNumber];
        if (!data) {
          throw new Error("No DICOM data loaded in this viewport.");
        }

        const img = document.getElementById(`viewportImage${viewportNumber}`);

        try {
          // Generate cache key for flattened OCT image
          const flattenMetadata = {
            path: data.s3_key,
            flattened: true,
            frame: 0,
          };

          const flattenCacheKey = imageCache.generateCacheKey(
            data.s3_key + "_flattened",
            flattenMetadata,
          );

          // Check if flattened version is already cached
          const cachedFlattened = imageCache.get(flattenCacheKey);
          if (cachedFlattened) {
            console.log("Using cached flattened OCT image");
            img.onload = () => {
              console.log("Cached flattened OCT image loaded successfully");
              img.style.display = "block";
              resetZoom(viewportNumber);
              setupImageInteractions(viewportNumber);
            };
            img.src = cachedFlattened.imageData;
            return;
          }

          console.log("Flattening OCT image and caching result...");
          const flattenResponse = await fetch(
            `/api/flatten_dicom_image?dicom_file_path=${encodeURIComponent(data.dicom_file_path)}`,
          );

          if (!flattenResponse.ok) {
            const errorData = await flattenResponse.json().catch(() => ({}));
            throw new Error(
              errorData.error ||
                `OCT flattening failed: ${flattenResponse.statusText}`,
            );
          }

          const flattenedBlob = await flattenResponse.blob();
          const flattenedUrl = URL.createObjectURL(flattenedBlob);

          // Cache ONLY the flattened image for OCT
          const cacheMetadata = {
            path: data.s3_key,
            flattened: true,
            size: flattenedBlob.size,
            lastModified: Date.now(),
            contentType: "image/png",
          };

          imageCache.set(flattenCacheKey, flattenedUrl, cacheMetadata);
          console.log(
            `Flattened OCT image cached with CRC: ${flattenCacheKey.substring(0, 8)}`,
          );

          // Store flattened URL in viewport data
          viewportData[viewportNumber].flattenedUrl = flattenedUrl;
          viewportData[viewportNumber].isFlattened = true;

          img.onload = () => {
            console.log("Flattened OCT image loaded and cached successfully");
            img.style.display = "block";
            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
          };

          img.src = flattenedUrl;
        } catch (error) {
          console.error("Error flattening OCT image:", error);
          throw error;
        }
      }

      // Flatten and show flattened image (enhanced with caching)
      async function flattenImage(viewportNumber) {
        const data = viewportData[viewportNumber];
        if (!data) {
          alert("No DICOM data loaded in this viewport.");
          return;
        }

        const img = document.getElementById(`viewportImage${viewportNumber}`);

        try {
          // Check cache first
          if (data.flattenedUrl) {
            console.log("Using cached flattened image");
            img.src = data.flattenedUrl;
            return;
          }

          console.log("Flattening image...");
          const flattenResponse = await fetch(
            `/api/flatten_dicom_image?dicom_file_path=${encodeURIComponent(data.dicom_file_path)}`,
          );

          if (!flattenResponse.ok) {
            const errorData = await flattenResponse.json().catch(() => ({}));
            throw new Error(
              errorData.error ||
                `Flattening failed: ${flattenResponse.statusText}`,
            );
          }

          const flattenedBlob = await flattenResponse.blob();
          const flattenedUrl = URL.createObjectURL(flattenedBlob);

          // Cache flattened image URL
          viewportData[viewportNumber].flattenedUrl = flattenedUrl;

          // Also cache in CRC cache
          try {
            const flattenMetadata = {
              path: data.s3_key,
              flattened: true,
              size: flattenedBlob.size,
              lastModified: Date.now(),
            };

            const flattenCacheKey = imageCache.generateCacheKey(
              data.s3_key + "_flattened",
              flattenMetadata,
            );
            imageCache.set(flattenCacheKey, flattenedUrl, flattenMetadata);
            console.log(
              `Flattened image cached with CRC: ${flattenCacheKey.substring(0, 8)}`,
            );
          } catch (cacheError) {
            console.warn(
              `Failed to cache flattened image: ${cacheError.message}`,
            );
          }

          img.onload = () => {
            console.log("Flattened image loaded successfully");
          };

          img.src = flattenedUrl;
        } catch (error) {
          console.error("Error flattening image:", error);
          alert(`Error flattening image: ${error.message}`);
        }
      }

      // Setup image interactions (zoom, pan)
      function setupImageInteractions(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const container = document.getElementById(
          `viewportContent${viewportNumber}`,
        );

        if (!img || !container) return;

        container.onwheel = null;
        img.onmousedown = null;
        img.onmouseup = null;
        img.onmouseleave = null;
        img.onmousemove = null;

        container.onwheel = (e) => {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          zoomViewport(viewportNumber, zoomFactor);
        };

        img.onmousedown = (e) => {
          isDragging[viewportNumber] = true;
          lastMousePos[viewportNumber] = { x: e.clientX, y: e.clientY };
          img.style.cursor = 'grabbing';
          e.preventDefault();
        };
        img.onmouseup = () => {
          isDragging[viewportNumber] = false;
          img.style.cursor = 'grab';
        };
        img.onmouseleave = () => {
          isDragging[viewportNumber] = false;
          img.style.cursor = 'grab';
        };
        img.onmousemove = (e) => {
          if (isDragging[viewportNumber]) {
            const deltaX = e.clientX - lastMousePos[viewportNumber].x;
            const deltaY = e.clientY - lastMousePos[viewportNumber].y;
            lastMousePos[viewportNumber] = { x: e.clientX, y: e.clientY };
            viewportPan[viewportNumber].x += deltaX;
            viewportPan[viewportNumber].y += deltaY;
            updateImageTransform(viewportNumber);
          }
        };
        img.style.cursor = 'grab';
      }

      // Global mouse event handlers
      document.addEventListener("mousemove", (e) => {
        for (let viewportNumber of [1, 2]) {
          if (isDragging[viewportNumber]) {
            const deltaX = e.clientX - lastMousePos[viewportNumber].x;
            const deltaY = e.clientY - lastMousePos[viewportNumber].y;

            viewportPan[viewportNumber].x += deltaX;
            viewportPan[viewportNumber].y += deltaY;

            updateImageTransform(viewportNumber);

            lastMousePos[viewportNumber] = { x: e.clientX, y: e.clientY };
          }
        }
      });

      document.addEventListener("mouseup", () => {
        for (let viewportNumber of [1, 2]) {
          if (isDragging[viewportNumber]) {
            isDragging[viewportNumber] = false;
            const img = document.getElementById(
              `viewportImage${viewportNumber}`,
            );
            // if (img) img.style.cursor = "grab"; // Remove setting grab cursor
          }
        }
      });

      // Zoom viewport
      function zoomViewport(viewportNumber, factor) {
        const oldZoom = viewportZoom[viewportNumber];
        viewportZoom[viewportNumber] *= factor;
        viewportZoom[viewportNumber] = Math.max(
          0.1,
          Math.min(20, viewportZoom[viewportNumber]), // Increased max zoom from 5x (500%) to 20x (2000%)
        );

        // Adjust pan to maintain center point during zoom
        const zoomRatio = viewportZoom[viewportNumber] / oldZoom;
        viewportPan[viewportNumber].x *= zoomRatio;
        viewportPan[viewportNumber].y *= zoomRatio;

        updateImageTransform(viewportNumber);
        updateZoomDisplay(viewportNumber);
      }

      // Reset zoom and pan
      function resetZoom(viewportNumber) {
        viewportZoom[viewportNumber] = 1;
        viewportPan[viewportNumber] = { x: 0, y: 0 };
        updateImageTransform(viewportNumber);
        updateZoomDisplay(viewportNumber);
      }

      // Update image transform
      function constrainPan(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const container = document.getElementById(
          `viewportContent${viewportNumber}`,
        );

        if (!img || !container) return;

        const containerRect = container.getBoundingClientRect();
        const imgRect = img.getBoundingClientRect();
        const zoom = viewportZoom[viewportNumber];

        // Calculate the scaled image dimensions
        const scaledWidth = img.naturalWidth * zoom;
        const scaledHeight = img.naturalHeight * zoom;

        // Calculate maximum allowed pan values
        const maxPanX = Math.max(0, (scaledWidth - containerRect.width) / 2);
        const maxPanY = Math.max(0, (scaledHeight - containerRect.height) / 2);

        // Constrain pan values
        viewportPan[viewportNumber].x = Math.max(
          -maxPanX,
          Math.min(maxPanX, viewportPan[viewportNumber].x),
        );
        viewportPan[viewportNumber].y = Math.max(
          -maxPanY,
          Math.min(maxPanY, viewportPan[viewportNumber].y),
        );
      }

      function updateImageTransform(viewportNumber) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        if (!img) return;

        // Apply constraints before updating transform
        constrainPan(viewportNumber);

        const zoom = viewportZoom[viewportNumber];
        const pan = viewportPan[viewportNumber];

        img.style.transform = `scale(${zoom}) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`;
      }

      // Update zoom display
      function updateZoomDisplay(viewportNumber) {
        const zoomDisplay = document.getElementById(
          `zoomLevel${viewportNumber}`,
        );
        if (zoomDisplay) {
          zoomDisplay.textContent = `${Math.round(viewportZoom[viewportNumber] * 100)}%`;
        }
      }

      function updateS3TreeProgress(percent) {
        const container = document.getElementById("fileTreeContainer");
        container.innerHTML = `
    <div class="tree-loading">
      <div class="loader"></div>
      <span style="margin-left: 10px;">Loading... ${percent}%</span>
    </div>
  `;
      }

      // Add cache status function
      async function getCacheStatus() {
        try {
          const response = await fetch("/api/cache-status");
          const status = await response.json();
          console.log("Cache Status:", status);

          // Also log CRC cache stats
          const crcStats = imageCache.getStats();
          console.log("CRC Cache Stats:", crcStats);

          return { ...status, crcCache: crcStats };
        } catch (error) {
          console.error("Error getting cache status:", error);
          return null;
        }
      }

      // Add function to display cache statistics
      function displayCacheStats() {
        const stats = imageCache.getStats();
        const message = `CRC Cache: ${stats.size}/${stats.maxSize} items, ${(stats.hitRate * 100).toFixed(1)}% hit rate`;
        updatePerformanceDisplay(message);
      }

      // Periodically update cache stats display
      setInterval(displayCacheStats, 10000); // Every 10 seconds

      // E2E File Loading Function
      async function loadE2EFile() {
        if (
                !selectedFilePath ||
                !selectedFilePath.toLowerCase().endsWith(".e2e")
            ) {
                alert("Please select a valid E2E file");
                return;
            }

            // Show progress bars for both viewports right away
            showProgress(1, "Preparing to load E2E...", {
                File: selectedFilePath.split("/").pop(),
                Type: "E2E",
                Eye: "Left",
            });
            showProgress(2, "Preparing to load E2E...", {
                File: selectedFilePath.split("/").pop(),
                Type: "E2E",
                Eye: "Right",
            });

            document.getElementById("contextMenu").style.display = "none";
        // Reset E2E mode if already in it
        try {
          // Switch to E2E mode
          isE2EMode = true;
          currentE2EFile = selectedFilePath;

          // Update viewport titles
          updateViewportTitles();

          // Show E2E controls
          showE2EControls();

          // Download and process the E2E file
          const operationId1 = showProgress(1, "Processing E2E file...", {
            File: selectedFilePath.split("/").pop(),
            Type: "E2E",
            Eye: "Left",
          });

          const operationId2 = showProgress(2, "Processing E2E file...", {
            File: selectedFilePath.split("/").pop(),
            Type: "E2E",
            Eye: "Right",
          });

          const response = await fetch(
            `/api/download_dicom_from_s3?path=${encodeURIComponent(selectedFilePath)}`,
          );

          if (!response.ok) {
            throw new Error(
              `Failed to download E2E file: ${response.statusText}`,
            );
          }

          const e2eData = await response.json();
          console.log("E2E data received:", e2eData);
          console.log("Left eye data:", e2eData.left_eye_data);
          console.log("Right eye data:", e2eData.right_eye_data);

          // Store E2E data for both viewports
          viewportData[1] = {
            ...e2eData,
            eye: "left",
            s3_key: selectedFilePath,
          };
          viewportData[2] = {
            ...e2eData,
            eye: "right",
            s3_key: selectedFilePath,
          };

          // Get tree data and populate eye trees
          await populateE2ETreeData(e2eData.dicom_file_path);

          // Check if we have any frames before trying to load
          const leftFrames = (e2eData.left_eye_data?.dicom?.length || 0) + (e2eData.left_eye_data?.oct?.length || 0);
          const rightFrames = (e2eData.right_eye_data?.dicom?.length || 0) + (e2eData.right_eye_data?.oct?.length || 0);
          
          console.log(`Left frames: ${leftFrames}, Right frames: ${rightFrames}`);

          // Only load images if we have frames
          if (leftFrames > 0) {
          await loadE2EEyeImage(1, 0, e2eData.dicom_file_path, "left");
          } else {
            console.warn("No left eye frames available");
            updateProgress(1, 100, "No left eye data available");
          }
          
          if (rightFrames > 0) {
          await loadE2EEyeImage(2, 0, e2eData.dicom_file_path, "right");
          } else {
            console.warn("No right eye frames available");
            updateProgress(2, 100, "No right eye data available");
          }

          // Setup frame sliders for both eyes - use actual eye data counts
          totalFrames[1] =
            (e2eData.left_eye_data?.dicom?.length || 0) +
              (e2eData.left_eye_data?.oct?.length || 0) || 1;
          totalFrames[2] =
            (e2eData.right_eye_data?.dicom?.length || 0) +
              (e2eData.right_eye_data?.oct?.length || 0) || 1;
          setupFrameSlider(1);
          setupFrameSlider(2);

          hideProgress(1);
          hideProgress(2);

          console.log("E2E file loaded successfully");
        } catch (error) {
          console.error("Error loading E2E file:", error);
          hideProgress(1);
          hideProgress(2);
          alert(`Error loading E2E file: ${error.message}`);
          resetE2EMode();
        }
      }

      // Load specific eye image from E2E file
      async function loadE2EEyeImage(
        viewportNumber,
        frameNumber,
        dicomFilePath,
        eye,
      ) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`,
        );

        try {
          console.log(`Loading ${eye} eye frame ${frameNumber} from ${dicomFilePath}`);
          
          updateProgress(
            viewportNumber,
            50,
            `Loading ${eye} eye frame ${frameNumber + 1}...`,
          );

          // Use the existing E2E eye endpoint
          const url = `/api/view_e2e_eye?frame=${frameNumber}&dicom_file_path=${encodeURIComponent(dicomFilePath)}&eye=${eye}`;
          console.log(`Fetching: ${url}`);
          
          const response = await fetch(url);

          if (!response.ok) {
            const errorText = await response.text();
            console.error(`E2E eye endpoint error: ${response.status} ${response.statusText}`);
            console.error(`Error details: ${errorText}`);
            throw new Error(
              `Failed to get ${eye} eye image: ${response.statusText}`,
            );
          }

          const imageBlob = await response.blob();
          const imageUrl = URL.createObjectURL(imageBlob);

          img.onload = () => {
            console.log(`${eye} eye image loaded for frame ${frameNumber}`);
            img.style.display = "block";
            if (placeholder) placeholder.style.display = "none";
            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
            updateFrameInfo(viewportNumber, frameNumber);
            updateProgress(
              viewportNumber,
              100,
              `${eye} eye loaded successfully`,
            );
          };

          img.onerror = () => {
            throw new Error(`Failed to load ${eye} eye image`);
          };

          img.src = imageUrl;
          currentFrames[viewportNumber] = frameNumber;
        } catch (error) {
          console.error(`Error loading ${eye} eye image:`, error);
          throw error;
        }
      }

      // Update viewport titles for E2E mode
      function updateViewportTitles() {
        const title1 = document.querySelector("#viewport1 h4");
        const title2 = document.querySelector("#viewport2 h4");

        if (isE2EMode) {
          if (title1) title1.textContent = "Viewport 1 - Left Eye";
          if (title2) title2.textContent = "Viewport 2 - Right Eye";
        } else {
          if (title1) title1.textContent = "Viewport 1";
          if (title2) title2.textContent = "Viewport 2";
        }
      }

      // Show E2E controls
      function showE2EControls() {
        const controlsContainer = document.getElementById(
          "e2eControlsContainer",
        );
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );

        if (controlsContainer) {
          controlsContainer.style.display = "block";
        }

        // Show tree containers for both eyes
        if (leftTreeContainer) {
          leftTreeContainer.style.display = "block";
        }
        if (rightTreeContainer) {
          rightTreeContainer.style.display = "block";
        }
      }

      // Hide E2E controls
      function hideE2EControls() {
        const controlsContainer = document.getElementById(
          "e2eControlsContainer",
        );
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );

        if (controlsContainer) {
          controlsContainer.style.display = "none";
        }

        // Hide tree containers
        if (leftTreeContainer) {
          leftTreeContainer.style.display = "none";
        }
        if (rightTreeContainer) {
          rightTreeContainer.style.display = "none";
        }
      }

      // Focus on specific eye
      function focusOnEye(eye) {
        focusedEye = eye;

        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewportsContainer =
          document.getElementById("viewportsContainer");

        // Update button states with new styling
        const leftBtn = document.getElementById("focusLeftEye");
        const rightBtn = document.getElementById("focusRightEye");

        // Remove active class from all buttons
        document.querySelectorAll(".eye-focus-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Add active class to focused button
        if (eye === "left" && leftBtn) {
          leftBtn.classList.add("active");
        } else if (eye === "right" && rightBtn) {
          rightBtn.classList.add("active");
        }

        // Force viewports container to column layout for focus mode
        if (viewportsContainer) {
          viewportsContainer.classList.remove("stacked");
          viewportsContainer.style.display = "flex";
          viewportsContainer.style.flexDirection = "column";
          viewportsContainer.style.gap = "20px";
        }

        // Focus on left eye: show left viewport expanded with left tree below
        if (eye === "left") {
          if (viewport1) {
            viewport1.style.display = "flex";
            viewport1.style.border = "3px solid #28a745";
            viewport1.style.width = "100%";
            viewport1.style.flex = "1";
            viewport1.style.minHeight = "500px";
          }
          if (viewport2) {
            viewport2.style.display = "none";
          }

          // Show left eye tree container and position it below viewport1
          if (leftTreeContainer) {
            leftTreeContainer.style.display = "block";
            leftTreeContainer.style.width = "100%";
            leftTreeContainer.style.flex = "0 0 auto";
            leftTreeContainer.style.visibility = "visible";
            leftTreeContainer.style.opacity = "1";
            leftTreeContainer.style.border = "2px solid #28a745";
            leftTreeContainer.style.borderRadius = "8px";
            leftTreeContainer.style.backgroundColor = "white";
            leftTreeContainer.style.minHeight = "200px";
            leftTreeContainer.style.maxHeight = "300px";
            leftTreeContainer.style.overflowY = "auto";
            leftTreeContainer.style.marginTop = "10px";

            // Move the tree container to be a direct child of viewportsContainer
            if (leftTreeContainer.parentNode !== viewportsContainer) {
              viewportsContainer.appendChild(leftTreeContainer);
            }
          }
          if (rightTreeContainer) {
            rightTreeContainer.style.display = "none";
          }
        }
        // Focus on right eye: show right viewport expanded with right tree below
        else if (eye === "right") {
          if (viewport1) {
            viewport1.style.display = "none";
          }
          if (viewport2) {
            viewport2.style.display = "flex";
            viewport2.style.border = "3px solid #007bff";
            viewport2.style.width = "100%";
            viewport2.style.flex = "1";
            viewport2.style.minHeight = "500px";
          }

          // Show right eye tree container and position it below viewport2
          if (rightTreeContainer) {
            rightTreeContainer.style.display = "block";
            rightTreeContainer.style.width = "100%";
            rightTreeContainer.style.flex = "0 0 auto";
            rightTreeContainer.style.visibility = "visible";
            rightTreeContainer.style.opacity = "1";
            rightTreeContainer.style.border = "2px solid #007bff";
            rightTreeContainer.style.borderRadius = "8px";
            rightTreeContainer.style.backgroundColor = "white";
            rightTreeContainer.style.minHeight = "200px";
            rightTreeContainer.style.maxHeight = "300px";
            rightTreeContainer.style.overflowY = "auto";
            rightTreeContainer.style.marginTop = "10px";

            // Move the tree container to be a direct child of viewportsContainer
            if (rightTreeContainer.parentNode !== viewportsContainer) {
              viewportsContainer.appendChild(rightTreeContainer);
            }
          }
          if (leftTreeContainer) {
            leftTreeContainer.style.display = "none";
          }
        }

        console.log(
          `Focused on ${eye} eye - showing expanded viewport with tree below`,
        );
      }

      // Reset eye focus
      function resetEyeFocus() {
        focusedEye = null;

        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewportsContainer =
          document.getElementById("viewportsContainer");

        // Reset button states - remove active class from all buttons
        document.querySelectorAll(".eye-focus-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Reset viewports container to default state
        if (viewportsContainer) {
          viewportsContainer.style.display = "flex";
          if (isStackedLayout && isE2EMode) {
            // For E2E stacked layout, maintain the 80/20 split
            viewportsContainer.style.flexDirection = "row";
          } else {
          viewportsContainer.style.flexDirection = isStackedLayout
            ? "column"
            : "row";
          }
          viewportsContainer.style.gap = "20px";
        }

        // Show both viewports and reset borders and widths
        if (viewport1) {
          viewport1.style.display = "flex";
          viewport1.style.border = "2px solid #ccc";
          viewport1.style.width = "";
          viewport1.style.flex = "1";
          viewport1.style.minHeight = "";
        }
        if (viewport2) {
          viewport2.style.display = "flex";
          viewport2.style.border = "2px solid #ccc";
          viewport2.style.width = "";
          viewport2.style.flex = "1";
          viewport2.style.minHeight = "";
        }

        // Move eye trees back to their original parent containers (inside viewports) and reset styling
        if (leftTreeContainer) {
          // Move back to viewport1 if it's not already there
          if (leftTreeContainer.parentNode !== viewport1) {
            viewport1.appendChild(leftTreeContainer);
          }
          leftTreeContainer.style.display = isE2EMode ? "block" : "none";
          leftTreeContainer.style.width = "";
          leftTreeContainer.style.flex = "";
          leftTreeContainer.style.border = "2px solid #e9ecef";
          leftTreeContainer.style.backgroundColor = "white";
          leftTreeContainer.style.minHeight = "";
          leftTreeContainer.style.maxHeight = "300px";
          leftTreeContainer.style.visibility = "visible";
          leftTreeContainer.style.opacity = "1";
        }
        if (rightTreeContainer) {
          // Move back to viewport2 if it's not already there
          if (rightTreeContainer.parentNode !== viewport2) {
            viewport2.appendChild(rightTreeContainer);
          }
          rightTreeContainer.style.display = isE2EMode ? "block" : "none";
          rightTreeContainer.style.width = "";
          rightTreeContainer.style.flex = "";
          rightTreeContainer.style.border = "2px solid #e9ecef";
          rightTreeContainer.style.backgroundColor = "white";
          rightTreeContainer.style.minHeight = "";
          rightTreeContainer.style.maxHeight = "300px";
          rightTreeContainer.style.visibility = "visible";
          rightTreeContainer.style.opacity = "1";
        }

        console.log("Eye focus reset to normal layout");
      }

      // Reset E2E mode
      function resetE2EMode() {
        isE2EMode = false;
        currentE2EFile = null;
        focusedEye = null;

        hideE2EControls();
        updateViewportTitles();
        resetEyeFocus();

        // --- Clear Viewport 1 UI ---
        const img1 = document.getElementById("viewportImage1");
        const placeholder1 = document.querySelector(
          "#viewportContent1 .viewport-placeholder",
        );
        const error1 = document.getElementById("error1");
        const frameSliderContainer1 = document.getElementById(
          "frameSliderContainer1",
        );
        if (img1) img1.style.display = "none";
        if (placeholder1) placeholder1.style.display = "block";
        if (error1) error1.style.display = "none";
        if (frameSliderContainer1)
          frameSliderContainer1.classList.remove("active");

        // --- Clear Viewport 2 UI ---
        const img2 = document.getElementById("viewportImage2");
        const placeholder2 = document.querySelector(
          "#viewportContent2 .viewport-placeholder",
        );
        const error2 = document.getElementById("error2");
        const frameSliderContainer2 = document.getElementById(
          "frameSliderContainer2",
        );
        if (img2) img2.style.display = "none";
        if (placeholder2) placeholder2.style.display = "block";
        if (error2) error2.style.display = "none";
        if (frameSliderContainer2)
          frameSliderContainer2.classList.remove("active");

        console.log("E2E mode reset");
      }

      // Enhanced frame loading for E2E files
      async function loadFrame(viewportNumber, frameNumber) {
        if (isE2EMode && currentE2EFile) {
          const data = viewportData[viewportNumber];
          if (data && data.dicom_file_path) {
            const eye = data.eye || (viewportNumber === 1 ? "left" : "right");
            await loadE2EEyeImage(
              viewportNumber,
              frameNumber,
              data.dicom_file_path,
              eye,
            );
          }
        } else {
          // Call original frame loading function
          return await loadFrameWithCRC(viewportNumber, frameNumber);
        }
      }

      // Toggle eye tree container visibility
      function toggleEyeTree(eye) {
        const containerId =
          eye === "left" ? "leftEyeTreeContainer" : "rightEyeTreeContainer";
        const container = document.getElementById(containerId);
        const button = container.querySelector(".tree-collapse-btn");
        const content = container.querySelector(".eye-tree-content");

        if (content.style.display === "none") {
          content.style.display = "block";
          container.classList.add("expanded");
          button.classList.remove("collapsed");
        } else {
          content.style.display = "none";
          container.classList.remove("expanded");
          button.classList.add("collapsed");
        }
      }

      // Update eye tree with file data (placeholder for future implementation)
      function updateEyeTree(eye, treeData) {
        const contentId =
          eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        if (!content) return;

        if (!treeData || treeData.length === 0) {
          content.innerHTML =
            '<div class="tree-placeholder">No files available for this eye</div>';
          return;
        }

        // Build tree HTML (you can customize this later)
        let treeHTML = "";
        treeData.forEach((item, index) => {
          treeHTML += `
      <div class="eye-tree-item" onclick="selectEyeTreeItem('${eye}', ${index})">
        <i class="fas fa-file-medical"></i>
        <span>${item.name || `File ${index + 1}`}</span>
      </div>
    `;
        });

        content.innerHTML = treeHTML;
      }

      // Populate E2E tree data
      async function populateE2ETreeData(dicomFilePath) {
        try {
          const response = await fetch(
            `/api/get_e2e_tree_data?dicom_file_path=${encodeURIComponent(dicomFilePath)}`,
          );

          if (!response.ok) {
            throw new Error(`Failed to get tree data: ${response.statusText}`);
          }

          const treeData = await response.json();
          console.log("E2E tree data received:", treeData);

          // Populate left eye tree with hierarchical structure
          const leftEyeData = treeData.left_eye || {};
          populateEyeTree("left", leftEyeData);

          // Populate right eye tree with hierarchical structure
          const rightEyeData = treeData.right_eye || {};
          populateEyeTree("right", rightEyeData);

          console.log(`Populated hierarchical trees for both eyes`);
        } catch (error) {
          console.error("Error populating E2E tree data:", error);
        }
      }

      // Populate eye tree with hierarchical file data (eye -> type -> files)
      function populateEyeTree(eye, eyeData) {
        const contentId =
          eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        if (!content) return;

        // Check if we have any data with enhanced structure
        const octFiles = eyeData.oct || [];
        const dicomFiles = eyeData.dicom || [];
        const originalOctFiles = eyeData.original_oct || [];
        const flattenedOctFiles = eyeData.flattened_oct || [];

        // Debug logging to help identify separation issues
        console.log(`=== Eye Tree Population for ${eye} eye ===`);
        console.log(`Fundus/DICOM files: ${dicomFiles.length}`, dicomFiles);
        console.log(`Original OCT files: ${originalOctFiles.length}`, originalOctFiles);
        console.log(`Flattened OCT files: ${flattenedOctFiles.length}`, flattenedOctFiles);
        console.log(`Legacy OCT files: ${octFiles.length}`, octFiles);
        
        // Validate that fundus and OCT files are properly separated
        const fundusKeys = dicomFiles.filter(key => key.includes('fundus'));
        const octKeys = originalOctFiles.filter(key => key.includes('oct_original'));
        
        console.log(`Fundus keys (should be in dicom): ${fundusKeys.length}`, fundusKeys);
        console.log(`OCT keys (should be in original_oct): ${octKeys.length}`, octKeys);
        
        // Check for any misclassified files
        const misclassifiedFundus = originalOctFiles.filter(key => key.includes('fundus'));
        const misclassifiedOCT = dicomFiles.filter(key => key.includes('oct_original'));
        
        if (misclassifiedFundus.length > 0) {
          console.warn(`WARNING: Found fundus images in original_oct:`, misclassifiedFundus);
        }
        if (misclassifiedOCT.length > 0) {
          console.warn(`WARNING: Found OCT images in dicom:`, misclassifiedOCT);
        }
        console.log(`=== End Eye Tree Population ===`);

        if (octFiles.length === 0 && dicomFiles.length === 0 && originalOctFiles.length === 0 && flattenedOctFiles.length === 0) {
          content.innerHTML =
            '<div class="tree-placeholder">No files loaded for this eye yet</div>';
          return;
        }

        // Build hierarchical tree HTML
        let treeHTML = "";

        // Original OCT frames folder (NEW)
        if (originalOctFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'original_oct')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-original_oct-arrow"></i>
                <i class="fas fa-film folder-icon"></i>
                <span>Original OCT Frames (${originalOctFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-original_oct-children">
          `;

          originalOctFiles.forEach((item, index) => {
            // Extract frame number from key (e.g., "key_L_oct_original_frame_0001" -> "frame_0001")
            const frameId = item.split("_").slice(-1)[0] || `frame_${String(index).padStart(4, '0')}`;
            const displayName = `${frameId}.jpg`;
            
            treeHTML += `
              <div class="eye-tree-item file-item" onclick="selectOCTFrame('${eye}', 'original', ${index}, '${item}', event)">
                <i class="fas fa-image file-icon"></i>
                <span>${displayName}</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        // Flattened OCT frames folder (NEW)
        if (flattenedOctFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'flattened_oct')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-flattened_oct-arrow"></i>
                <i class="fas fa-compress-alt folder-icon"></i>
                <span>Flattened OCT Frames (${flattenedOctFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-flattened_oct-children">
          `;

          flattenedOctFiles.forEach((item, index) => {
            // Extract frame number from key
            const frameId = item.split("_").slice(-1)[0] || `frame_${String(index).padStart(4, '0')}`;
            const displayName = `${frameId}.jpg`;
            
            treeHTML += `
              <div class="eye-tree-item file-item" onclick="selectOCTFrame('${eye}', 'flattened', ${index}, '${item}', event)">
                <i class="fas fa-image file-icon"></i>
                <span>${displayName}</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        // Legacy OCT folder (for backward compatibility)
        if (octFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'oct')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-oct-arrow"></i>
                <i class="fas fa-eye folder-icon"></i>
                <span>OCT (Legacy) (${octFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-oct-children">
          `;

          octFiles.forEach((item, index) => {
            const fileName =
              item.split("_").slice(-2).join("_") || `OCT File ${index + 1}`;
            treeHTML += `
              <div class="eye-tree-item file-item" onclick="selectEyeTreeFile('${eye}', 'oct', ${index}, '${item}', event)">
                <i class="fas fa-file-medical file-icon"></i>
                <span>${fileName}</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        // Fundus/DICOM folder
        if (dicomFiles.length > 0) {
          treeHTML += `
            <div class="eye-tree-folder" onclick="toggleEyeTreeFolder('${eye}', 'dicom')">
              <div class="eye-tree-item folder-header">
                <i class="fas fa-chevron-down folder-arrow" id="${eye}-dicom-arrow"></i>
                <i class="fas fa-camera folder-icon"></i>
                <span>Fundus/DICOM (${dicomFiles.length})</span>
              </div>
              <div class="eye-tree-children" id="${eye}-dicom-children">
          `;

          dicomFiles.forEach((item, index) => {
            const fileName =
              item.split("_").slice(-2).join("_") || `Fundus File ${index + 1}`;
            treeHTML += `
              <div class="eye-tree-item file-item" onclick="selectEyeTreeFile('${eye}', 'dicom', ${index}, '${item}', event)">
                <i class="fas fa-file-medical file-icon"></i>
                <span>${fileName}</span>
              </div>
            `;
          });

          treeHTML += `
              </div>
            </div>
          `;
        }

        // Add validation button for debugging
        treeHTML += `
          <div class="eye-tree-item" style="margin-top: 10px; padding: 8px; background-color: #f8f9fa; border-radius: 4px;">
            <button onclick="validateE2ESeparation('${eye}')" style="width: 100%; padding: 5px; background-color: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">
              <i class="fas fa-check-circle"></i> Validate Separation
            </button>
          </div>
        `;

        content.innerHTML = treeHTML;
      }

      // Toggle eye tree folder (OCT, DICOM/Fundus, or OCT frames)
      function toggleEyeTreeFolder(eye, type) {
        const childrenId = `${eye}-${type}-children`;
        const arrowId = `${eye}-${type}-arrow`;

        const children = document.getElementById(childrenId);
        const arrow = document.getElementById(arrowId);

        if (children && arrow) {
          if (children.style.display === "none") {
            children.style.display = "block";
            arrow.style.transform = "rotate(0deg)";
          } else {
            children.style.display = "none";
            arrow.style.transform = "rotate(-90deg)";
          }
        }
      }

      // Select OCT frame and switch to OCT frame mode
      function selectOCTFrame(eye, frameType, frameNumber, frameKey, event) {
        // Prevent event bubbling to parent folder
        if (event) {
          event.stopPropagation();
        }

        const viewportNumber = eye === "left" ? 1 : 2;
        const data = viewportData[viewportNumber];
        
        if (!data || !data.dicom_file_path) {
          console.error("No E2E data available for viewport", viewportNumber);
          return;
        }

        console.log(`Loading OCT frame ${frameNumber} (${frameType}) for ${eye} eye`);

        // Update visual selection
        const contentId = eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        // Remove previous selection
        content.querySelectorAll(".file-item").forEach((item) => {
          item.classList.remove("selected");
        });

        // Select the clicked item
        const fileItems = content.querySelectorAll(".file-item");
        fileItems.forEach((item) => {
          if (item.onclick && item.onclick.toString().includes(`selectOCTFrame('${eye}', '${frameType}', ${frameNumber}`)) {
            item.classList.add("selected");
          }
        });

        // Load the OCT frame
        loadOCTFrame(viewportNumber, eye, frameNumber, data.dicom_file_path, frameType);

        // Switch frame slider to OCT frame mode
        switchToOCTFrameMode(viewportNumber, eye, frameType, frameNumber);

        console.log(`Selected OCT frame ${frameNumber} (${frameType}) in ${eye} eye tree`);
      }

      // Load OCT frame from backend
      async function loadOCTFrame(viewportNumber, eye, frameNumber, dicomFilePath, frameType) {
        const img = document.getElementById(`viewportImage${viewportNumber}`);
        const placeholder = document.querySelector(
          `#viewportContent${viewportNumber} .viewport-placeholder`
        );

        try {
          console.log(`Loading OCT frame ${frameNumber} (${frameType}) for ${eye} eye`);
          
          updateProgress(
            viewportNumber,
            50,
            `Loading OCT frame ${frameNumber + 1} (${frameType})...`
          );

          // Use the new OCT frame endpoint
          const url = `/api/view_e2e_oct_frame?dicom_file_path=${encodeURIComponent(dicomFilePath)}&eye=${eye}&frame_number=${frameNumber}&frame_type=${frameType}`;
          console.log(`Fetching: ${url}`);
          
          const response = await fetch(url);

          if (!response.ok) {
            const errorText = await response.text();
            console.error(`OCT frame endpoint error: ${response.status} ${response.statusText}`);
            console.error(`Error details: ${errorText}`);
            throw new Error(
              `Failed to get OCT frame: ${response.statusText}`
            );
          }

          const imageBlob = await response.blob();
          const imageUrl = URL.createObjectURL(imageBlob);

          img.onload = () => {
            console.log(`OCT frame ${frameNumber} (${frameType}) loaded for ${eye} eye`);
            img.style.display = "block";
            if (placeholder) placeholder.style.display = "none";
            resetZoom(viewportNumber);
            setupImageInteractions(viewportNumber);
            updateFrameInfo(viewportNumber, frameNumber);
            updateProgress(
              viewportNumber,
              100,
              `OCT frame ${frameNumber + 1} (${frameType}) loaded successfully`
            );
          };

          img.onerror = () => {
            throw new Error(`Failed to load OCT frame ${frameNumber} (${frameType})`);
          };

          img.src = imageUrl;
          currentFrames[viewportNumber] = frameNumber;
        } catch (error) {
          console.error(`Error loading OCT frame:`, error);
          throw error;
        }
      }

      // Switch frame slider to OCT frame mode
      function switchToOCTFrameMode(viewportNumber, eye, frameType, currentFrame) {
        const data = viewportData[viewportNumber];
        if (!data || !data.dicom_file_path) return;

        // Get OCT frame count for this eye and type
        const eyeData = data[eye === "left" ? "left_eye_data" : "right_eye_data"];
        const frameList = frameType === "flattened" ? eyeData.flattened_oct : eyeData.original_oct;
        const totalFrames = frameList.length;

        if (totalFrames > 0) {
          // Set OCT frame mode
          data.octFrameMode = true;
          data.octFrameEye = eye;
          data.octFrameType = frameType;
          
          // Update total frames for this viewport
          totalFrames[viewportNumber] = totalFrames;
          
          // Update current frame
          currentFrames[viewportNumber] = currentFrame;
          
          // Update frame slider
          setupFrameSlider(viewportNumber);
          
          // Update frame info display
          updateFrameInfo(viewportNumber, currentFrame);
          
          console.log(`Switched viewport ${viewportNumber} to OCT frame mode: ${totalFrames} frames, current: ${currentFrame}, type: ${frameType}`);
        }
      }

      // Load OCT frame from slider navigation
      async function loadOCTFrameFromSlider(viewportNumber, frameNumber) {
        const data = viewportData[viewportNumber];
        if (!data || !data.octFrameMode) {
          console.error("Not in OCT frame mode for viewport", viewportNumber);
          return;
        }

        const eye = data.octFrameEye;
        const frameType = data.octFrameType;
        const dicomFilePath = data.dicom_file_path;

        console.log(`Loading OCT frame ${frameNumber} from slider for ${eye} eye (${frameType})`);

        try {
          await loadOCTFrame(viewportNumber, eye, frameNumber, dicomFilePath, frameType);
          
          // Update current frame
          currentFrames[viewportNumber] = frameNumber;
          
          // Update frame info
          updateFrameInfo(viewportNumber, frameNumber);
          
        } catch (error) {
          console.error("Error loading OCT frame from slider:", error);
          throw error;
        }
      }

      // Select file in hierarchical eye tree
      function selectEyeTreeFile(eye, type, index, fileName, event) {
        // Prevent event bubbling to parent folder
        if (event) {
          event.stopPropagation();
        }
        const contentId =
          eye === "left" ? "leftEyeTreeContent" : "rightEyeTreeContent";
        const content = document.getElementById(contentId);

        // Remove previous selection
        content.querySelectorAll(".file-item").forEach((item) => {
          item.classList.remove("selected");
        });

        // Find and select the clicked file item
        const fileItems = content.querySelectorAll(".file-item");
        let globalIndex = 0;

        // Calculate the global index based on type and position
        if (type === "dicom") {
          const octFiles =
            viewportData[eye === "left" ? 1 : 2]?.left_eye_data?.oct?.length ||
            viewportData[eye === "left" ? 1 : 2]?.right_eye_data?.oct?.length ||
            0;
          globalIndex = octFiles + index;
        } else {
          globalIndex = index;
        }

        // Select the appropriate file item
        fileItems.forEach((item, itemIndex) => {
          if (
            item.onclick &&
            item.onclick.toString().includes(`${type}', ${index}`)
          ) {
            item.classList.add("selected");
          }
        });

        // Load the selected image
        if (isE2EMode && currentE2EFile) {
          const viewportNumber = eye === "left" ? 1 : 2;
          const data = viewportData[viewportNumber];
          if (data && data.dicom_file_path) {
            loadE2EEyeImage(
              viewportNumber,
              globalIndex,
              data.dicom_file_path,
              eye,
            );
          }
        }
        // Tree remains open after file selection for better user experience

        console.log(
          `Selected ${type} file ${index} (${fileName}) in ${eye} eye tree`,
        );
      }

      // Legacy function for backward compatibility
      function selectEyeTreeItem(eye, index) {
        selectEyeTreeFile(eye, "oct", index, `file_${index}`);
      }

      // Validate E2E separation for debugging
      async function validateE2ESeparation(eye) {
        const viewportNumber = eye === "left" ? 1 : 2;
        const data = viewportData[viewportNumber];
        
        if (!data || !data.dicom_file_path) {
          alert("No E2E data available for validation");
          return;
        }

        try {
          console.log(`Validating E2E separation for ${eye} eye...`);
          
          const response = await fetch(`/api/validate_e2e_separation?dicom_file_path=${encodeURIComponent(data.dicom_file_path)}`);
          
          if (!response.ok) {
            throw new Error(`Validation failed: ${response.statusText}`);
          }
          
          const validationResult = await response.json();
          
          console.log("E2E Separation Validation Result:", validationResult);
          
          // Create a detailed validation report
          let report = `=== E2E Separation Validation Report ===\n\n`;
          report += `File: ${validationResult.file_key}\n`;
          report += `Total Images: ${validationResult.total_images}\n\n`;
          
          report += `Fundus Images: ${validationResult.fundus_images.count}\n`;
          report += `Keys: ${validationResult.fundus_images.keys.join(', ')}\n\n`;
          
          report += `OCT Original Images: ${validationResult.oct_original_images.count}\n`;
          report += `Keys: ${validationResult.oct_original_images.keys.join(', ')}\n\n`;
          
          report += `OCT Flattened Images: ${validationResult.oct_flattened_images.count}\n`;
          report += `Keys: ${validationResult.oct_flattened_images.keys.join(', ')}\n\n`;
          
          if (validationResult.misclassified_images.length > 0) {
            report += `⚠️ MISCLASSIFIED IMAGES:\n`;
            validationResult.misclassified_images.forEach(item => {
              report += `- ${item.key}: ${item.issue}\n`;
            });
            report += `\n`;
          }
          
          report += `Validation Passed: ${validationResult.validation_passed ? '✅ YES' : '❌ NO'}\n`;
          
          // Show the report in an alert (you might want to create a modal for better display)
          alert(report);
          
          // Also log to console for detailed inspection
          console.log("Detailed validation report:", report);
          
        } catch (error) {
          console.error("Error validating E2E separation:", error);
          alert(`Validation error: ${error.message}`);
        }
      }

      // Eye Focus Menu Functions
      function toggleEyeFocusMenu() {
        const menu = document.getElementById('eyeFocusDropdownMenu');
        const burger = document.querySelector('.eye-focus-burger');
        
        if (menu.classList.contains('show')) {
          menu.classList.remove('show');
          burger.classList.remove('active');
        } else {
          menu.classList.add('show');
          burger.classList.add('active');
        }
      }

      // Close menu when clicking outside
      document.addEventListener('click', function(event) {
        const menu = document.getElementById('eyeFocusDropdownMenu');
        const burger = document.querySelector('.eye-focus-burger');
        const eyeFocusMenu = document.querySelector('.eye-focus-menu');
        
        if (!eyeFocusMenu.contains(event.target)) {
          menu.classList.remove('show');
          burger.classList.remove('active');
        }
      });

      // Keyboard shortcuts for frame navigation
      document.addEventListener('keydown', function(event) {
        // Only handle keyboard shortcuts if not typing in an input field
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
          return;
        }

        // Get the currently focused viewport (you might want to implement viewport focus tracking)
        let activeViewport = 1; // Default to viewport 1
        
        // Check if viewport 2 has focus (you can implement this based on your UI logic)
        // For now, we'll use viewport 1 as default
        
        switch (event.key) {
          case 'ArrowLeft':
            event.preventDefault();
            previousFrame(activeViewport);
            break;
          case 'ArrowRight':
            event.preventDefault();
            nextFrame(activeViewport);
            break;
          case 'Home':
            event.preventDefault();
            // Jump to first frame
            const firstFrame = 0;
            const data = viewportData[activeViewport];
            if (data && data.octFrameMode) {
              loadOCTFrameFromSlider(activeViewport, firstFrame);
            } else {
              loadFrame(activeViewport, firstFrame);
            }
            break;
          case 'End':
            event.preventDefault();
            // Jump to last frame
            const totalFramesCount = totalFrames[activeViewport] || 0;
            const lastFrame = Math.max(0, totalFramesCount - 1);
            const data2 = viewportData[activeViewport];
            if (data2 && data2.octFrameMode) {
              loadOCTFrameFromSlider(activeViewport, lastFrame);
            } else {
              loadFrame(activeViewport, lastFrame);
            }
            break;
        }
      });

      // Enhanced resetEyeFocus to also close menu
      function resetEyeFocus() {
        focusedEye = null;

        const viewport1 = document.getElementById("viewport1");
        const viewport2 = document.getElementById("viewport2");
        const leftTreeContainer = document.getElementById(
          "leftEyeTreeContainer",
        );
        const rightTreeContainer = document.getElementById(
          "rightEyeTreeContainer",
        );
        const viewportsContainer =
          document.getElementById("viewportsContainer");
        const menu = document.getElementById('eyeFocusDropdownMenu');
        const burger = document.querySelector('.eye-focus-burger');

        // Close menu
        if (menu) {
          menu.classList.remove('show');
        }
        if (burger) {
          burger.classList.remove('active');
        }

        // Reset button states - remove active class from all buttons
        document.querySelectorAll(".eye-focus-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Reset viewports container to default state
        if (viewportsContainer) {
          viewportsContainer.style.display = "flex";
          if (isStackedLayout && isE2EMode) {
            // For E2E stacked layout, maintain the 80/20 split
            viewportsContainer.style.flexDirection = "row";
          } else {
          viewportsContainer.style.flexDirection = isStackedLayout
            ? "column"
            : "row";
          }
          viewportsContainer.style.gap = "20px";
        }

        // Show both viewports and reset borders and widths
        if (viewport1) {
          viewport1.style.display = "flex";
          viewport1.style.border = "2px solid #ccc";
          viewport1.style.width = "";
          viewport1.style.flex = "1";
          viewport1.style.minHeight = "";
        }
        if (viewport2) {
          viewport2.style.display = "flex";
          viewport2.style.border = "2px solid #ccc";
          viewport2.style.width = "";
          viewport2.style.flex = "1";
          viewport2.style.minHeight = "";
        }

        // Move eye trees back to their original parent containers (inside viewports) and reset styling
        if (leftTreeContainer) {
          // Move back to viewport1 if it's not already there
          if (leftTreeContainer.parentNode !== viewport1) {
            viewport1.appendChild(leftTreeContainer);
          }
          leftTreeContainer.style.display = isE2EMode ? "block" : "none";
          leftTreeContainer.style.width = "";
          leftTreeContainer.style.flex = "";
          leftTreeContainer.style.border = "2px solid #e9ecef";
          leftTreeContainer.style.backgroundColor = "white";
          leftTreeContainer.style.minHeight = "";
          leftTreeContainer.style.maxHeight = "300px";
          leftTreeContainer.style.visibility = "visible";
          leftTreeContainer.style.opacity = "1";
        }
        if (rightTreeContainer) {
          // Move back to viewport2 if it's not already there
          if (rightTreeContainer.parentNode !== viewport2) {
            viewport2.appendChild(rightTreeContainer);
          }
          rightTreeContainer.style.display = isE2EMode ? "block" : "none";
          rightTreeContainer.style.width = "";
          rightTreeContainer.style.flex = "";
          rightTreeContainer.style.border = "2px solid #e9ecef";
          rightTreeContainer.style.backgroundColor = "white";
          rightTreeContainer.style.minHeight = "";
          rightTreeContainer.style.maxHeight = "300px";
          rightTreeContainer.style.visibility = "visible";
          rightTreeContainer.style.opacity = "1";
        }

        console.log("Eye focus reset to normal layout");
      }

      // Add keyboard shortcut for cancelling operations (ESC key)
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          // Cancel any active operations
          for (let viewportNumber of [1, 2]) {
            if (progressManagers[viewportNumber].operationId) {
              cancelOperation(viewportNumber);
              console.log(
                `Cancelled operation in viewport ${viewportNumber} via ESC key`,
              );
            }
          }

          // Also hide E2E controls if ESC is pressed
          if (isE2EMode) {
            hideE2EControls();
          }
        }
      });
    </script>
  </body>
</html>
